//! Structs.
//! 
// 
// NOTE: Do not edit this file directly; it is auto-generated.


use std::ffi::{CStr};
use std::marker::PhantomData;
use std::slice;
use libc::{c_void, c_char};
use ::*;
use vks;
use vks::{PFN_vkAllocationFunction, PFN_vkReallocationFunction, PFN_vkFreeFunction, 
    PFN_vkInternalAllocationNotification, PFN_vkInternalFreeNotification, 
    PFN_vkDebugReportCallbackEXT};



/// A `VkOffset2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Offset2d {
    raw: vks::VkOffset2D,
}

impl Offset2d {
    pub fn builder() -> Offset2dBuilder {
        Offset2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkOffset2D) -> Offset2d {
        Offset2d { raw, }
    }

    pub fn x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn set_x<'m>(&mut self, x: i32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: i32) {
        self.raw.y = y.into();
    }

    pub fn as_raw(&self) -> &vks::VkOffset2D {
        &self.raw
    }
}

impl From<Offset2d> for vks::VkOffset2D {
    fn from(f: Offset2d) -> vks::VkOffset2D {
        f.raw
    }
}


/// Bitflags for `VkOffset2D`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Offset2dFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
    }
}


/// A builder for `VkOffset2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Offset2dBuilder {
    raw: vks::VkOffset2D,
    set_mask: Offset2dFlags,
}

impl Offset2dBuilder {
    pub fn new() -> Offset2dBuilder {
        Offset2dBuilder {
            raw: vks::VkOffset2D::default(),
            set_mask: Offset2dFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: i32) -> Offset2dBuilder {
        self.raw.x = x.into();
        self.set_mask |= Offset2dFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: i32) -> Offset2dBuilder {
        self.raw.y = y.into();
        self.set_mask |= Offset2dFlags::FLAG_Y;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<i32> {
        if self.set_mask & Offset2dFlags::FLAG_X != Offset2dFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<i32> {
        if self.set_mask & Offset2dFlags::FLAG_Y != Offset2dFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn build(self) -> Offset2d {
        Offset2d {
            raw: self.raw,
        }
    }
}


/// A `VkOffset3D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Offset3d {
    raw: vks::VkOffset3D,
}

impl Offset3d {
    pub fn builder() -> Offset3dBuilder {
        Offset3dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkOffset3D) -> Offset3d {
        Offset3d { raw, }
    }

    pub fn x<'a>(&'a self) -> i32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> i32 {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> i32 {
        self.raw.z.into()
    }

    pub fn set_x<'m>(&mut self, x: i32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: i32) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: i32) {
        self.raw.z = z.into();
    }

    pub fn as_raw(&self) -> &vks::VkOffset3D {
        &self.raw
    }
}

impl From<Offset3d> for vks::VkOffset3D {
    fn from(f: Offset3d) -> vks::VkOffset3D {
        f.raw
    }
}


/// Bitflags for `VkOffset3D`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Offset3dFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
        const FLAG_Z			 = 0b100;
    }
}


/// A builder for `VkOffset3D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Offset3dBuilder {
    raw: vks::VkOffset3D,
    set_mask: Offset3dFlags,
}

impl Offset3dBuilder {
    pub fn new() -> Offset3dBuilder {
        Offset3dBuilder {
            raw: vks::VkOffset3D::default(),
            set_mask: Offset3dFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: i32) -> Offset3dBuilder {
        self.raw.x = x.into();
        self.set_mask |= Offset3dFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: i32) -> Offset3dBuilder {
        self.raw.y = y.into();
        self.set_mask |= Offset3dFlags::FLAG_Y;
        self
    }

    pub fn z<'m>(mut self, z: i32) -> Offset3dBuilder {
        self.raw.z = z.into();
        self.set_mask |= Offset3dFlags::FLAG_Z;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<i32> {
        if self.set_mask & Offset3dFlags::FLAG_X != Offset3dFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<i32> {
        if self.set_mask & Offset3dFlags::FLAG_Y != Offset3dFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn get_z<'a>(&'a self) -> Option<i32> {
        if self.set_mask & Offset3dFlags::FLAG_Z != Offset3dFlags::FLAG_Z { return None }
        Some( self.raw.z.into() )
    }

    pub fn build(self) -> Offset3d {
        Offset3d {
            raw: self.raw,
        }
    }
}


/// A `VkExtent2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Extent2d {
    raw: vks::VkExtent2D,
}

impl Extent2d {
    pub fn builder() -> Extent2dBuilder {
        Extent2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtent2D) -> Extent2d {
        Extent2d { raw, }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn as_raw(&self) -> &vks::VkExtent2D {
        &self.raw
    }
}

impl From<Extent2d> for vks::VkExtent2D {
    fn from(f: Extent2d) -> vks::VkExtent2D {
        f.raw
    }
}


/// Bitflags for `VkExtent2D`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Extent2dFlags: u32 {
        const FLAG_WIDTH			 = 0b1;
        const FLAG_HEIGHT			 = 0b10;
    }
}


/// A builder for `VkExtent2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Extent2dBuilder {
    raw: vks::VkExtent2D,
    set_mask: Extent2dFlags,
}

impl Extent2dBuilder {
    pub fn new() -> Extent2dBuilder {
        Extent2dBuilder {
            raw: vks::VkExtent2D::default(),
            set_mask: Extent2dFlags::default(),
        }
    }

    pub fn width<'m>(mut self, width: u32) -> Extent2dBuilder {
        self.raw.width = width.into();
        self.set_mask |= Extent2dFlags::FLAG_WIDTH;
        self
    }

    pub fn height<'m>(mut self, height: u32) -> Extent2dBuilder {
        self.raw.height = height.into();
        self.set_mask |= Extent2dFlags::FLAG_HEIGHT;
        self
    }

    pub fn get_width<'a>(&'a self) -> Option<u32> {
        if self.set_mask & Extent2dFlags::FLAG_WIDTH != Extent2dFlags::FLAG_WIDTH { return None }
        Some( self.raw.width.into() )
    }

    pub fn get_height<'a>(&'a self) -> Option<u32> {
        if self.set_mask & Extent2dFlags::FLAG_HEIGHT != Extent2dFlags::FLAG_HEIGHT { return None }
        Some( self.raw.height.into() )
    }

    pub fn build(self) -> Extent2d {
        Extent2d {
            raw: self.raw,
        }
    }
}


/// A `VkExtent3D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Extent3d {
    raw: vks::VkExtent3D,
}

impl Extent3d {
    pub fn builder() -> Extent3dBuilder {
        Extent3dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtent3D) -> Extent3d {
        Extent3d { raw, }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn depth<'a>(&'a self) -> u32 {
        self.raw.depth.into()
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn set_depth<'m>(&mut self, depth: u32) {
        self.raw.depth = depth.into();
    }

    pub fn as_raw(&self) -> &vks::VkExtent3D {
        &self.raw
    }
}

impl From<Extent3d> for vks::VkExtent3D {
    fn from(f: Extent3d) -> vks::VkExtent3D {
        f.raw
    }
}


/// Bitflags for `VkExtent3D`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Extent3dFlags: u32 {
        const FLAG_WIDTH			 = 0b1;
        const FLAG_HEIGHT			 = 0b10;
        const FLAG_DEPTH			 = 0b100;
    }
}


/// A builder for `VkExtent3D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Extent3dBuilder {
    raw: vks::VkExtent3D,
    set_mask: Extent3dFlags,
}

impl Extent3dBuilder {
    pub fn new() -> Extent3dBuilder {
        Extent3dBuilder {
            raw: vks::VkExtent3D::default(),
            set_mask: Extent3dFlags::default(),
        }
    }

    pub fn width<'m>(mut self, width: u32) -> Extent3dBuilder {
        self.raw.width = width.into();
        self.set_mask |= Extent3dFlags::FLAG_WIDTH;
        self
    }

    pub fn height<'m>(mut self, height: u32) -> Extent3dBuilder {
        self.raw.height = height.into();
        self.set_mask |= Extent3dFlags::FLAG_HEIGHT;
        self
    }

    pub fn depth<'m>(mut self, depth: u32) -> Extent3dBuilder {
        self.raw.depth = depth.into();
        self.set_mask |= Extent3dFlags::FLAG_DEPTH;
        self
    }

    pub fn get_width<'a>(&'a self) -> Option<u32> {
        if self.set_mask & Extent3dFlags::FLAG_WIDTH != Extent3dFlags::FLAG_WIDTH { return None }
        Some( self.raw.width.into() )
    }

    pub fn get_height<'a>(&'a self) -> Option<u32> {
        if self.set_mask & Extent3dFlags::FLAG_HEIGHT != Extent3dFlags::FLAG_HEIGHT { return None }
        Some( self.raw.height.into() )
    }

    pub fn get_depth<'a>(&'a self) -> Option<u32> {
        if self.set_mask & Extent3dFlags::FLAG_DEPTH != Extent3dFlags::FLAG_DEPTH { return None }
        Some( self.raw.depth.into() )
    }

    pub fn build(self) -> Extent3d {
        Extent3d {
            raw: self.raw,
        }
    }
}


/// A `VkViewport`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Viewport {
    raw: vks::VkViewport,
}

impl Viewport {
    pub fn builder() -> ViewportBuilder {
        ViewportBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewport) -> Viewport {
        Viewport { raw, }
    }

    pub fn x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn width<'a>(&'a self) -> f32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> f32 {
        self.raw.height.into()
    }

    pub fn min_depth<'a>(&'a self) -> f32 {
        self.raw.minDepth.into()
    }

    pub fn max_depth<'a>(&'a self) -> f32 {
        self.raw.maxDepth.into()
    }

    pub fn set_x<'m>(&mut self, x: f32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: f32) {
        self.raw.y = y.into();
    }

    pub fn set_width<'m>(&mut self, width: f32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: f32) {
        self.raw.height = height.into();
    }

    pub fn set_min_depth<'m>(&mut self, min_depth: f32) {
        self.raw.minDepth = min_depth.into();
    }

    pub fn set_max_depth<'m>(&mut self, max_depth: f32) {
        self.raw.maxDepth = max_depth.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewport {
        &self.raw
    }
}

impl From<Viewport> for vks::VkViewport {
    fn from(f: Viewport) -> vks::VkViewport {
        f.raw
    }
}


/// Bitflags for `VkViewport`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ViewportFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
        const FLAG_WIDTH			 = 0b100;
        const FLAG_HEIGHT			 = 0b1000;
        const FLAG_MINDEPTH			 = 0b10000;
        const FLAG_MAXDEPTH			 = 0b100000;
    }
}


/// A builder for `VkViewport`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportBuilder {
    raw: vks::VkViewport,
    set_mask: ViewportFlags,
}

impl ViewportBuilder {
    pub fn new() -> ViewportBuilder {
        ViewportBuilder {
            raw: vks::VkViewport::default(),
            set_mask: ViewportFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: f32) -> ViewportBuilder {
        self.raw.x = x.into();
        self.set_mask |= ViewportFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: f32) -> ViewportBuilder {
        self.raw.y = y.into();
        self.set_mask |= ViewportFlags::FLAG_Y;
        self
    }

    pub fn width<'m>(mut self, width: f32) -> ViewportBuilder {
        self.raw.width = width.into();
        self.set_mask |= ViewportFlags::FLAG_WIDTH;
        self
    }

    pub fn height<'m>(mut self, height: f32) -> ViewportBuilder {
        self.raw.height = height.into();
        self.set_mask |= ViewportFlags::FLAG_HEIGHT;
        self
    }

    pub fn min_depth<'m>(mut self, min_depth: f32) -> ViewportBuilder {
        self.raw.minDepth = min_depth.into();
        self.set_mask |= ViewportFlags::FLAG_MINDEPTH;
        self
    }

    pub fn max_depth<'m>(mut self, max_depth: f32) -> ViewportBuilder {
        self.raw.maxDepth = max_depth.into();
        self.set_mask |= ViewportFlags::FLAG_MAXDEPTH;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_X != ViewportFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_Y != ViewportFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn get_width<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_WIDTH != ViewportFlags::FLAG_WIDTH { return None }
        Some( self.raw.width.into() )
    }

    pub fn get_height<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_HEIGHT != ViewportFlags::FLAG_HEIGHT { return None }
        Some( self.raw.height.into() )
    }

    pub fn get_min_depth<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_MINDEPTH != ViewportFlags::FLAG_MINDEPTH { return None }
        Some( self.raw.minDepth.into() )
    }

    pub fn get_max_depth<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportFlags::FLAG_MAXDEPTH != ViewportFlags::FLAG_MAXDEPTH { return None }
        Some( self.raw.maxDepth.into() )
    }

    pub fn build(self) -> Viewport {
        Viewport {
            raw: self.raw,
        }
    }
}


/// A `VkRect2D`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Rect2d {
    raw: vks::VkRect2D,
}

impl Rect2d {
    pub fn builder() -> Rect2dBuilder {
        Rect2dBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRect2D) -> Rect2d {
        Rect2d { raw, }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn set_offset<'m>(&mut self, offset: Offset2d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent2d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkRect2D {
        &self.raw
    }
}

impl From<Rect2d> for vks::VkRect2D {
    fn from(f: Rect2d) -> vks::VkRect2D {
        f.raw
    }
}


/// Bitflags for `VkRect2D`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Rect2dFlags: u32 {
        const FLAG_OFFSET			 = 0b1;
        const FLAG_EXTENT			 = 0b10;
    }
}


/// A builder for `VkRect2D`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Rect2dBuilder {
    raw: vks::VkRect2D,
    set_mask: Rect2dFlags,
}

impl Rect2dBuilder {
    pub fn new() -> Rect2dBuilder {
        Rect2dBuilder {
            raw: vks::VkRect2D::default(),
            set_mask: Rect2dFlags::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: Offset2d) -> Rect2dBuilder {
        self.raw.offset = offset.raw;
        self.set_mask |= Rect2dFlags::FLAG_OFFSET;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent2d) -> Rect2dBuilder {
        self.raw.extent = extent.raw;
        self.set_mask |= Rect2dFlags::FLAG_EXTENT;
        self
    }

    pub fn get_offset<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & Rect2dFlags::FLAG_OFFSET != Rect2dFlags::FLAG_OFFSET { return None }
        Some(  unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & Rect2dFlags::FLAG_OFFSET != Rect2dFlags::FLAG_OFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & Rect2dFlags::FLAG_EXTENT != Rect2dFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & Rect2dFlags::FLAG_EXTENT != Rect2dFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn build(self) -> Rect2d {
        Rect2d {
            raw: self.raw,
        }
    }
}


/// A `VkClearRect`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearRect {
    raw: vks::VkClearRect,
}

impl ClearRect {
    pub fn builder() -> ClearRectBuilder {
        ClearRectBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearRect) -> ClearRect {
        ClearRect { raw, }
    }

    pub fn rect<'a>(&'a self) -> &'a Rect2d {
         unsafe { &*(&self.raw.rect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.rect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_rect<'m>(&mut self, rect: Rect2d) {
        self.raw.rect = rect.raw;
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearRect {
        &self.raw
    }
}

impl From<ClearRect> for vks::VkClearRect {
    fn from(f: ClearRect) -> vks::VkClearRect {
        f.raw
    }
}


/// Bitflags for `VkClearRect`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ClearRectFlags: u32 {
        const FLAG_RECT			 = 0b1;
        const FLAG_BASEARRAYLAYER			 = 0b10;
        const FLAG_LAYERCOUNT			 = 0b100;
    }
}


/// A builder for `VkClearRect`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearRectBuilder {
    raw: vks::VkClearRect,
    set_mask: ClearRectFlags,
}

impl ClearRectBuilder {
    pub fn new() -> ClearRectBuilder {
        ClearRectBuilder {
            raw: vks::VkClearRect::default(),
            set_mask: ClearRectFlags::default(),
        }
    }

    pub fn rect<'m>(mut self, rect: Rect2d) -> ClearRectBuilder {
        self.raw.rect = rect.raw;
        self.set_mask |= ClearRectFlags::FLAG_RECT;
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ClearRectBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self.set_mask |= ClearRectFlags::FLAG_BASEARRAYLAYER;
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ClearRectBuilder {
        self.raw.layerCount = layer_count.into();
        self.set_mask |= ClearRectFlags::FLAG_LAYERCOUNT;
        self
    }

    pub fn get_rect<'a>(&'a self) -> Option<&'a Rect2d> {
        if self.set_mask & ClearRectFlags::FLAG_RECT != ClearRectFlags::FLAG_RECT { return None }
        Some(  unsafe { &*(&self.raw.rect as *const vks::VkRect2D as *const Rect2d) } )
    }

    pub fn get_rect_mut<'a>(&'a mut self) -> Option<&'a mut Rect2d> {
        if self.set_mask & ClearRectFlags::FLAG_RECT != ClearRectFlags::FLAG_RECT { return None }
        Some( unsafe { &mut *(&mut self.raw.rect as *mut  vks::VkRect2D as *mut Rect2d) } )
    }

    pub fn get_base_array_layer<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ClearRectFlags::FLAG_BASEARRAYLAYER != ClearRectFlags::FLAG_BASEARRAYLAYER { return None }
        Some( self.raw.baseArrayLayer.into() )
    }

    pub fn get_layer_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ClearRectFlags::FLAG_LAYERCOUNT != ClearRectFlags::FLAG_LAYERCOUNT { return None }
        Some( self.raw.layerCount.into() )
    }

    pub fn build(self) -> ClearRect {
        ClearRect {
            raw: self.raw,
        }
    }
}


/// A `VkComponentMapping`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ComponentMapping {
    raw: vks::VkComponentMapping,
}

impl ComponentMapping {
    pub fn builder() -> ComponentMappingBuilder {
        ComponentMappingBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkComponentMapping) -> ComponentMapping {
        ComponentMapping { raw, }
    }

    pub fn r<'a>(&'a self) -> ComponentSwizzle {
        self.raw.r.into()
    }

    pub fn g<'a>(&'a self) -> ComponentSwizzle {
        self.raw.g.into()
    }

    pub fn b<'a>(&'a self) -> ComponentSwizzle {
        self.raw.b.into()
    }

    pub fn a<'a>(&'a self) -> ComponentSwizzle {
        self.raw.a.into()
    }

    pub fn set_r<'m>(&mut self, r: ComponentSwizzle) {
        self.raw.r = r.into();
    }

    pub fn set_g<'m>(&mut self, g: ComponentSwizzle) {
        self.raw.g = g.into();
    }

    pub fn set_b<'m>(&mut self, b: ComponentSwizzle) {
        self.raw.b = b.into();
    }

    pub fn set_a<'m>(&mut self, a: ComponentSwizzle) {
        self.raw.a = a.into();
    }

    pub fn as_raw(&self) -> &vks::VkComponentMapping {
        &self.raw
    }
}

impl From<ComponentMapping> for vks::VkComponentMapping {
    fn from(f: ComponentMapping) -> vks::VkComponentMapping {
        f.raw
    }
}


/// Bitflags for `VkComponentMapping`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ComponentMappingFlags: u32 {
        const FLAG_R			 = 0b1;
        const FLAG_G			 = 0b10;
        const FLAG_B			 = 0b100;
        const FLAG_A			 = 0b1000;
    }
}


/// A builder for `VkComponentMapping`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ComponentMappingBuilder {
    raw: vks::VkComponentMapping,
    set_mask: ComponentMappingFlags,
}

impl ComponentMappingBuilder {
    pub fn new() -> ComponentMappingBuilder {
        ComponentMappingBuilder {
            raw: vks::VkComponentMapping::default(),
            set_mask: ComponentMappingFlags::default(),
        }
    }

    pub fn r<'m>(mut self, r: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.r = r.into();
        self.set_mask |= ComponentMappingFlags::FLAG_R;
        self
    }

    pub fn g<'m>(mut self, g: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.g = g.into();
        self.set_mask |= ComponentMappingFlags::FLAG_G;
        self
    }

    pub fn b<'m>(mut self, b: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.b = b.into();
        self.set_mask |= ComponentMappingFlags::FLAG_B;
        self
    }

    pub fn a<'m>(mut self, a: ComponentSwizzle) -> ComponentMappingBuilder {
        self.raw.a = a.into();
        self.set_mask |= ComponentMappingFlags::FLAG_A;
        self
    }

    pub fn get_r<'a>(&'a self) -> Option<ComponentSwizzle> {
        if self.set_mask & ComponentMappingFlags::FLAG_R != ComponentMappingFlags::FLAG_R { return None }
        Some( self.raw.r.into() )
    }

    pub fn get_g<'a>(&'a self) -> Option<ComponentSwizzle> {
        if self.set_mask & ComponentMappingFlags::FLAG_G != ComponentMappingFlags::FLAG_G { return None }
        Some( self.raw.g.into() )
    }

    pub fn get_b<'a>(&'a self) -> Option<ComponentSwizzle> {
        if self.set_mask & ComponentMappingFlags::FLAG_B != ComponentMappingFlags::FLAG_B { return None }
        Some( self.raw.b.into() )
    }

    pub fn get_a<'a>(&'a self) -> Option<ComponentSwizzle> {
        if self.set_mask & ComponentMappingFlags::FLAG_A != ComponentMappingFlags::FLAG_A { return None }
        Some( self.raw.a.into() )
    }

    pub fn build(self) -> ComponentMapping {
        ComponentMapping {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceProperties {
    raw: vks::VkPhysicalDeviceProperties,
}

impl PhysicalDeviceProperties {
    pub fn builder() -> PhysicalDevicePropertiesBuilder {
        PhysicalDevicePropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceProperties) -> PhysicalDeviceProperties {
        PhysicalDeviceProperties { raw, }
    }

    pub fn api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub fn driver_version<'a>(&'a self) -> Version {
        self.raw.driverVersion.into()
    }

    pub fn vendor_id<'a>(&'a self) -> u32 {
        self.raw.vendorID.into()
    }

    pub fn device_id<'a>(&'a self) -> u32 {
        self.raw.deviceID.into()
    }

    pub fn device_type<'a>(&'a self) -> PhysicalDeviceType {
        self.raw.deviceType.into()
    }

    pub fn device_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.deviceName as *const _) }
    }

    pub fn pipeline_cache_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.pipelineCacheUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn limits<'a>(&'a self) -> &'a PhysicalDeviceLimits {
         unsafe { &*(&self.raw.limits as *const vks::VkPhysicalDeviceLimits as *const PhysicalDeviceLimits) }
    }

    pub fn limits_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceLimits {
        unsafe { &mut *(&mut self.raw.limits as *mut  vks::VkPhysicalDeviceLimits as *mut PhysicalDeviceLimits) }
    }

    pub fn sparse_properties<'a>(&'a self) -> &'a PhysicalDeviceSparseProperties {
         unsafe { &*(&self.raw.sparseProperties as *const vks::VkPhysicalDeviceSparseProperties as *const PhysicalDeviceSparseProperties) }
    }

    pub fn sparse_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceSparseProperties {
        unsafe { &mut *(&mut self.raw.sparseProperties as *mut  vks::VkPhysicalDeviceSparseProperties as *mut PhysicalDeviceSparseProperties) }
    }

    pub fn set_api_version<'m, T>(&mut self, api_version: T)
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
    }

    pub fn set_driver_version<'m, T>(&mut self, driver_version: T)
            where T: Into<Version> {
        self.raw.driverVersion = driver_version.into().into();
    }

    pub fn set_vendor_id<'m>(&mut self, vendor_id: u32) {
        self.raw.vendorID = vendor_id.into();
    }

    pub fn set_device_id<'m>(&mut self, device_id: u32) {
        self.raw.deviceID = device_id.into();
    }

    pub fn set_device_type<'m>(&mut self, device_type: PhysicalDeviceType) {
        self.raw.deviceType = device_type.into();
    }

    pub unsafe fn set_device_name<'m>(&mut self, device_name: [i8; vks::VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]) {
        self.raw.deviceName = device_name;
    }

    pub fn set_pipeline_cache_uuid<'m>(&mut self, pipeline_cache_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.pipelineCacheUUID = pipeline_cache_uuid;
    }

    pub fn set_limits<'m>(&mut self, limits: PhysicalDeviceLimits) {
        self.raw.limits = limits.raw;
    }

    pub fn set_sparse_properties<'m>(&mut self, sparse_properties: PhysicalDeviceSparseProperties) {
        self.raw.sparseProperties = sparse_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceProperties> for vks::VkPhysicalDeviceProperties {
    fn from(f: PhysicalDeviceProperties) -> vks::VkPhysicalDeviceProperties {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDevicePropertiesFlags: u32 {
        const FLAG_APIVERSION			 = 0b1;
        const FLAG_DRIVERVERSION			 = 0b10;
        const FLAG_VENDORID			 = 0b100;
        const FLAG_DEVICEID			 = 0b1000;
        const FLAG_DEVICETYPE			 = 0b10000;
        const FLAG_DEVICENAME			 = 0b100000;
        const FLAG_PIPELINECACHEUUID			 = 0b1000000;
        const FLAG_LIMITS			 = 0b10000000;
        const FLAG_SPARSEPROPERTIES			 = 0b100000000;
    }
}


/// A builder for `VkPhysicalDeviceProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevicePropertiesBuilder {
    raw: vks::VkPhysicalDeviceProperties,
    set_mask: PhysicalDevicePropertiesFlags,
}

impl PhysicalDevicePropertiesBuilder {
    pub fn new() -> PhysicalDevicePropertiesBuilder {
        PhysicalDevicePropertiesBuilder {
            raw: vks::VkPhysicalDeviceProperties::default(),
            set_mask: PhysicalDevicePropertiesFlags::default(),
        }
    }

    pub fn api_version<'m, T>(mut self, api_version: T) -> PhysicalDevicePropertiesBuilder
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_APIVERSION;
        self
    }

    pub fn driver_version<'m, T>(mut self, driver_version: T) -> PhysicalDevicePropertiesBuilder
            where T: Into<Version> {
        self.raw.driverVersion = driver_version.into().into();
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_DRIVERVERSION;
        self
    }

    pub fn vendor_id<'m>(mut self, vendor_id: u32) -> PhysicalDevicePropertiesBuilder {
        self.raw.vendorID = vendor_id.into();
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_VENDORID;
        self
    }

    pub fn device_id<'m>(mut self, device_id: u32) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceID = device_id.into();
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_DEVICEID;
        self
    }

    pub fn device_type<'m>(mut self, device_type: PhysicalDeviceType) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceType = device_type.into();
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_DEVICETYPE;
        self
    }

    pub unsafe fn device_name<'m>(mut self, device_name: [i8; vks::VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]) -> PhysicalDevicePropertiesBuilder {
        self.raw.deviceName = device_name;
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_DEVICENAME;
        self
    }

    pub fn pipeline_cache_uuid<'m>(mut self, pipeline_cache_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDevicePropertiesBuilder {
        self.raw.pipelineCacheUUID = pipeline_cache_uuid;
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_PIPELINECACHEUUID;
        self
    }

    pub fn limits<'m>(mut self, limits: PhysicalDeviceLimits) -> PhysicalDevicePropertiesBuilder {
        self.raw.limits = limits.raw;
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_LIMITS;
        self
    }

    pub fn sparse_properties<'m>(mut self, sparse_properties: PhysicalDeviceSparseProperties) -> PhysicalDevicePropertiesBuilder {
        self.raw.sparseProperties = sparse_properties.raw;
        self.set_mask |= PhysicalDevicePropertiesFlags::FLAG_SPARSEPROPERTIES;
        self
    }

    pub fn get_api_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_APIVERSION != PhysicalDevicePropertiesFlags::FLAG_APIVERSION { return None }
        Some( self.raw.apiVersion.into() )
    }

    pub fn get_driver_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_DRIVERVERSION != PhysicalDevicePropertiesFlags::FLAG_DRIVERVERSION { return None }
        Some( self.raw.driverVersion.into() )
    }

    pub fn get_vendor_id<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_VENDORID != PhysicalDevicePropertiesFlags::FLAG_VENDORID { return None }
        Some( self.raw.vendorID.into() )
    }

    pub fn get_device_id<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_DEVICEID != PhysicalDevicePropertiesFlags::FLAG_DEVICEID { return None }
        Some( self.raw.deviceID.into() )
    }

    pub fn get_device_type<'a>(&'a self) -> Option<PhysicalDeviceType> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_DEVICETYPE != PhysicalDevicePropertiesFlags::FLAG_DEVICETYPE { return None }
        Some( self.raw.deviceType.into() )
    }

    pub fn get_device_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_DEVICENAME != PhysicalDevicePropertiesFlags::FLAG_DEVICENAME { return None }
        Some( unsafe { CStr::from_ptr(&self.raw.deviceName as *const _) } )
    }

    pub fn get_pipeline_cache_uuid<'a>(&'a self) -> Option<&[u8]> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_PIPELINECACHEUUID != PhysicalDevicePropertiesFlags::FLAG_PIPELINECACHEUUID { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.pipelineCacheUUID as *const _, vks::VK_UUID_SIZE as usize) } )
    }

    pub fn get_limits<'a>(&'a self) -> Option<&'a PhysicalDeviceLimits> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_LIMITS != PhysicalDevicePropertiesFlags::FLAG_LIMITS { return None }
        Some(  unsafe { &*(&self.raw.limits as *const vks::VkPhysicalDeviceLimits as *const PhysicalDeviceLimits) } )
    }

    pub fn get_limits_mut<'a>(&'a mut self) -> Option<&'a mut PhysicalDeviceLimits> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_LIMITS != PhysicalDevicePropertiesFlags::FLAG_LIMITS { return None }
        Some( unsafe { &mut *(&mut self.raw.limits as *mut  vks::VkPhysicalDeviceLimits as *mut PhysicalDeviceLimits) } )
    }

    pub fn get_sparse_properties<'a>(&'a self) -> Option<&'a PhysicalDeviceSparseProperties> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_SPARSEPROPERTIES != PhysicalDevicePropertiesFlags::FLAG_SPARSEPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.sparseProperties as *const vks::VkPhysicalDeviceSparseProperties as *const PhysicalDeviceSparseProperties) } )
    }

    pub fn get_sparse_properties_mut<'a>(&'a mut self) -> Option<&'a mut PhysicalDeviceSparseProperties> {
        if self.set_mask & PhysicalDevicePropertiesFlags::FLAG_SPARSEPROPERTIES != PhysicalDevicePropertiesFlags::FLAG_SPARSEPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.sparseProperties as *mut  vks::VkPhysicalDeviceSparseProperties as *mut PhysicalDeviceSparseProperties) } )
    }

    pub fn build(self) -> PhysicalDeviceProperties {
        PhysicalDeviceProperties {
            raw: self.raw,
        }
    }
}


/// A `VkExtensionProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExtensionProperties {
    raw: vks::VkExtensionProperties,
}

impl ExtensionProperties {
    pub fn builder() -> ExtensionPropertiesBuilder {
        ExtensionPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExtensionProperties) -> ExtensionProperties {
        ExtensionProperties { raw, }
    }

    pub fn extension_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.extensionName as *const _) }
    }

    pub fn spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub unsafe fn set_extension_name<'m>(&mut self, extension_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) {
        self.raw.extensionName = extension_name;
    }

    pub fn set_spec_version<'m, T>(&mut self, spec_version: T)
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
    }

    pub fn as_raw(&self) -> &vks::VkExtensionProperties {
        &self.raw
    }
}

impl From<ExtensionProperties> for vks::VkExtensionProperties {
    fn from(f: ExtensionProperties) -> vks::VkExtensionProperties {
        f.raw
    }
}


/// Bitflags for `VkExtensionProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExtensionPropertiesFlags: u32 {
        const FLAG_EXTENSIONNAME			 = 0b1;
        const FLAG_SPECVERSION			 = 0b10;
    }
}


/// A builder for `VkExtensionProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExtensionPropertiesBuilder {
    raw: vks::VkExtensionProperties,
    set_mask: ExtensionPropertiesFlags,
}

impl ExtensionPropertiesBuilder {
    pub fn new() -> ExtensionPropertiesBuilder {
        ExtensionPropertiesBuilder {
            raw: vks::VkExtensionProperties::default(),
            set_mask: ExtensionPropertiesFlags::default(),
        }
    }

    pub unsafe fn extension_name<'m>(mut self, extension_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) -> ExtensionPropertiesBuilder {
        self.raw.extensionName = extension_name;
        self.set_mask |= ExtensionPropertiesFlags::FLAG_EXTENSIONNAME;
        self
    }

    pub fn spec_version<'m, T>(mut self, spec_version: T) -> ExtensionPropertiesBuilder
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
        self.set_mask |= ExtensionPropertiesFlags::FLAG_SPECVERSION;
        self
    }

    pub fn get_extension_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & ExtensionPropertiesFlags::FLAG_EXTENSIONNAME != ExtensionPropertiesFlags::FLAG_EXTENSIONNAME { return None }
        Some( unsafe { CStr::from_ptr(&self.raw.extensionName as *const _) } )
    }

    pub fn get_spec_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & ExtensionPropertiesFlags::FLAG_SPECVERSION != ExtensionPropertiesFlags::FLAG_SPECVERSION { return None }
        Some( self.raw.specVersion.into() )
    }

    pub fn build(self) -> ExtensionProperties {
        ExtensionProperties {
            raw: self.raw,
        }
    }
}


/// A `VkLayerProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct LayerProperties {
    raw: vks::VkLayerProperties,
}

impl LayerProperties {
    pub fn builder() -> LayerPropertiesBuilder {
        LayerPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkLayerProperties) -> LayerProperties {
        LayerProperties { raw, }
    }

    pub fn layer_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.layerName as *const _) }
    }

    pub fn spec_version<'a>(&'a self) -> Version {
        self.raw.specVersion.into()
    }

    pub fn implementation_version<'a>(&'a self) -> Version {
        self.raw.implementationVersion.into()
    }

    pub fn description<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(&self.raw.description as *const _) }
    }

    pub unsafe fn set_layer_name<'m>(&mut self, layer_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) {
        self.raw.layerName = layer_name;
    }

    pub fn set_spec_version<'m, T>(&mut self, spec_version: T)
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
    }

    pub fn set_implementation_version<'m, T>(&mut self, implementation_version: T)
            where T: Into<Version> {
        self.raw.implementationVersion = implementation_version.into().into();
    }

    pub unsafe fn set_description<'m>(&mut self, description: [i8; vks::VK_MAX_DESCRIPTION_SIZE]) {
        self.raw.description = description;
    }

    pub fn as_raw(&self) -> &vks::VkLayerProperties {
        &self.raw
    }
}

impl From<LayerProperties> for vks::VkLayerProperties {
    fn from(f: LayerProperties) -> vks::VkLayerProperties {
        f.raw
    }
}


/// Bitflags for `VkLayerProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct LayerPropertiesFlags: u32 {
        const FLAG_LAYERNAME			 = 0b1;
        const FLAG_SPECVERSION			 = 0b10;
        const FLAG_IMPLEMENTATIONVERSION			 = 0b100;
        const FLAG_DESCRIPTION			 = 0b1000;
    }
}


/// A builder for `VkLayerProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct LayerPropertiesBuilder {
    raw: vks::VkLayerProperties,
    set_mask: LayerPropertiesFlags,
}

impl LayerPropertiesBuilder {
    pub fn new() -> LayerPropertiesBuilder {
        LayerPropertiesBuilder {
            raw: vks::VkLayerProperties::default(),
            set_mask: LayerPropertiesFlags::default(),
        }
    }

    pub unsafe fn layer_name<'m>(mut self, layer_name: [i8; vks::VK_MAX_EXTENSION_NAME_SIZE]) -> LayerPropertiesBuilder {
        self.raw.layerName = layer_name;
        self.set_mask |= LayerPropertiesFlags::FLAG_LAYERNAME;
        self
    }

    pub fn spec_version<'m, T>(mut self, spec_version: T) -> LayerPropertiesBuilder
            where T: Into<Version> {
        self.raw.specVersion = spec_version.into().into();
        self.set_mask |= LayerPropertiesFlags::FLAG_SPECVERSION;
        self
    }

    pub fn implementation_version<'m, T>(mut self, implementation_version: T) -> LayerPropertiesBuilder
            where T: Into<Version> {
        self.raw.implementationVersion = implementation_version.into().into();
        self.set_mask |= LayerPropertiesFlags::FLAG_IMPLEMENTATIONVERSION;
        self
    }

    pub unsafe fn description<'m>(mut self, description: [i8; vks::VK_MAX_DESCRIPTION_SIZE]) -> LayerPropertiesBuilder {
        self.raw.description = description;
        self.set_mask |= LayerPropertiesFlags::FLAG_DESCRIPTION;
        self
    }

    pub fn get_layer_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & LayerPropertiesFlags::FLAG_LAYERNAME != LayerPropertiesFlags::FLAG_LAYERNAME { return None }
        Some( unsafe { CStr::from_ptr(&self.raw.layerName as *const _) } )
    }

    pub fn get_spec_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & LayerPropertiesFlags::FLAG_SPECVERSION != LayerPropertiesFlags::FLAG_SPECVERSION { return None }
        Some( self.raw.specVersion.into() )
    }

    pub fn get_implementation_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & LayerPropertiesFlags::FLAG_IMPLEMENTATIONVERSION != LayerPropertiesFlags::FLAG_IMPLEMENTATIONVERSION { return None }
        Some( self.raw.implementationVersion.into() )
    }

    pub fn get_description<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & LayerPropertiesFlags::FLAG_DESCRIPTION != LayerPropertiesFlags::FLAG_DESCRIPTION { return None }
        Some( unsafe { CStr::from_ptr(&self.raw.description as *const _) } )
    }

    pub fn build(self) -> LayerProperties {
        LayerProperties {
            raw: self.raw,
        }
    }
}


/// A `VkApplicationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ApplicationInfo<'s> {
    raw: vks::VkApplicationInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ApplicationInfo<'s> {
    pub fn builder<'b>() -> ApplicationInfoBuilder<'b> {
        ApplicationInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkApplicationInfo) -> ApplicationInfo<'s> {
        ApplicationInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn application_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pApplicationName) }
    }

    pub fn application_version<'a>(&'a self) -> Version {
        self.raw.applicationVersion.into()
    }

    pub fn engine_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pEngineName) }
    }

    pub fn engine_version<'a>(&'a self) -> Version {
        self.raw.engineVersion.into()
    }

    pub fn api_version<'a>(&'a self) -> Version {
        self.raw.apiVersion.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_application_name<'m, 'a>(&mut self, application_name: &'a CStr)
            where 'a: 's {
        self.raw.pApplicationName = application_name.as_ptr();
    }

    pub fn set_application_version<'m, T>(&mut self, application_version: T)
            where T: Into<Version> {
        self.raw.applicationVersion = application_version.into().into();
    }

    pub fn set_engine_name<'m, 'a>(&mut self, engine_name: &'a CStr)
            where 'a: 's {
        self.raw.pEngineName = engine_name.as_ptr();
    }

    pub fn set_engine_version<'m, T>(&mut self, engine_version: T)
            where T: Into<Version> {
        self.raw.engineVersion = engine_version.into().into();
    }

    pub fn set_api_version<'m, T>(&mut self, api_version: T)
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
    }

    pub fn as_raw(&self) -> &vks::VkApplicationInfo {
        &self.raw
    }
}

impl<'s> From<ApplicationInfo<'s>> for vks::VkApplicationInfo {
    fn from(f: ApplicationInfo<'s>) -> vks::VkApplicationInfo {
        f.raw
    }
}


/// Bitflags for `VkApplicationInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ApplicationInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PAPPLICATIONNAME			 = 0b100;
        const FLAG_APPLICATIONVERSION			 = 0b1000;
        const FLAG_PENGINENAME			 = 0b10000;
        const FLAG_ENGINEVERSION			 = 0b100000;
        const FLAG_APIVERSION			 = 0b1000000;
    }
}


/// A builder for `VkApplicationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ApplicationInfoBuilder<'b> {
    raw: vks::VkApplicationInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: ApplicationInfoFlags,
}

impl<'b> ApplicationInfoBuilder<'b> {
    pub fn new() -> ApplicationInfoBuilder<'b> {
        ApplicationInfoBuilder {
            raw: vks::VkApplicationInfo::default(),
            _p: PhantomData,
            set_mask: ApplicationInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ApplicationInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ApplicationInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn application_name<'m, 'a>(mut self, application_name: &'a CStr) -> ApplicationInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pApplicationName = application_name.as_ptr();
        self.set_mask |= ApplicationInfoFlags::FLAG_PAPPLICATIONNAME;
        self
    }

    pub fn application_version<'m, T>(mut self, application_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.applicationVersion = application_version.into().into();
        self.set_mask |= ApplicationInfoFlags::FLAG_APPLICATIONVERSION;
        self
    }

    pub fn engine_name<'m, 'a>(mut self, engine_name: &'a CStr) -> ApplicationInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pEngineName = engine_name.as_ptr();
        self.set_mask |= ApplicationInfoFlags::FLAG_PENGINENAME;
        self
    }

    pub fn engine_version<'m, T>(mut self, engine_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.engineVersion = engine_version.into().into();
        self.set_mask |= ApplicationInfoFlags::FLAG_ENGINEVERSION;
        self
    }

    pub fn api_version<'m, T>(mut self, api_version: T) -> ApplicationInfoBuilder<'b>
            where T: Into<Version> {
        self.raw.apiVersion = api_version.into().into();
        self.set_mask |= ApplicationInfoFlags::FLAG_APIVERSION;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ApplicationInfoFlags::FLAG_PNEXT != ApplicationInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_application_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & ApplicationInfoFlags::FLAG_PAPPLICATIONNAME != ApplicationInfoFlags::FLAG_PAPPLICATIONNAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.pApplicationName) } )
    }

    pub fn get_application_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & ApplicationInfoFlags::FLAG_APPLICATIONVERSION != ApplicationInfoFlags::FLAG_APPLICATIONVERSION { return None }
        Some( self.raw.applicationVersion.into() )
    }

    pub fn get_engine_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & ApplicationInfoFlags::FLAG_PENGINENAME != ApplicationInfoFlags::FLAG_PENGINENAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.pEngineName) } )
    }

    pub fn get_engine_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & ApplicationInfoFlags::FLAG_ENGINEVERSION != ApplicationInfoFlags::FLAG_ENGINEVERSION { return None }
        Some( self.raw.engineVersion.into() )
    }

    pub fn get_api_version<'a>(&'a self) -> Option<Version> {
        if self.set_mask & ApplicationInfoFlags::FLAG_APIVERSION != ApplicationInfoFlags::FLAG_APIVERSION { return None }
        Some( self.raw.apiVersion.into() )
    }

    pub fn build(self) -> ApplicationInfo<'b> {
        ApplicationInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkAllocationCallbacks`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AllocationCallbacks<'s> {
    raw: vks::VkAllocationCallbacks,
    _p: PhantomData<&'s ()>,
}

impl<'s> AllocationCallbacks<'s> {
    pub fn builder<'b>() -> AllocationCallbacksBuilder<'b> {
        AllocationCallbacksBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAllocationCallbacks) -> AllocationCallbacks<'s> {
        AllocationCallbacks { raw, _p: PhantomData }
    }

    pub fn user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub fn pfn_allocation<'a>(&'a self) -> PFN_vkAllocationFunction {
        self.raw.pfnAllocation.into()
    }

    pub fn pfn_reallocation<'a>(&'a self) -> PFN_vkReallocationFunction {
        self.raw.pfnReallocation.into()
    }

    pub fn pfn_free<'a>(&'a self) -> PFN_vkFreeFunction {
        self.raw.pfnFree.into()
    }

    pub fn pfn_internal_allocation<'a>(&'a self) -> PFN_vkInternalAllocationNotification {
        self.raw.pfnInternalAllocation.into()
    }

    pub fn pfn_internal_free<'a>(&'a self) -> PFN_vkInternalFreeNotification {
        self.raw.pfnInternalFree.into()
    }

    pub unsafe fn set_user_data<'m>(&mut self, user_data: *mut c_void) {
        self.raw.pUserData = user_data;
    }

    pub unsafe fn set_pfn_allocation<'m>(&mut self, pfn_allocation: PFN_vkAllocationFunction) {
        self.raw.pfnAllocation = pfn_allocation.into();
    }

    pub unsafe fn set_pfn_reallocation<'m>(&mut self, pfn_reallocation: PFN_vkReallocationFunction) {
        self.raw.pfnReallocation = pfn_reallocation.into();
    }

    pub unsafe fn set_pfn_free<'m>(&mut self, pfn_free: PFN_vkFreeFunction) {
        self.raw.pfnFree = pfn_free.into();
    }

    pub unsafe fn set_pfn_internal_allocation<'m>(&mut self, pfn_internal_allocation: PFN_vkInternalAllocationNotification) {
        self.raw.pfnInternalAllocation = pfn_internal_allocation.into();
    }

    pub unsafe fn set_pfn_internal_free<'m>(&mut self, pfn_internal_free: PFN_vkInternalFreeNotification) {
        self.raw.pfnInternalFree = pfn_internal_free.into();
    }

    pub fn as_raw(&self) -> &vks::VkAllocationCallbacks {
        &self.raw
    }
}

impl<'s> From<AllocationCallbacks<'s>> for vks::VkAllocationCallbacks {
    fn from(f: AllocationCallbacks<'s>) -> vks::VkAllocationCallbacks {
        f.raw
    }
}


/// Bitflags for `VkAllocationCallbacks`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct AllocationCallbacksFlags: u32 {
        const FLAG_PUSERDATA			 = 0b1;
        const FLAG_PFNALLOCATION			 = 0b10;
        const FLAG_PFNREALLOCATION			 = 0b100;
        const FLAG_PFNFREE			 = 0b1000;
        const FLAG_PFNINTERNALALLOCATION			 = 0b10000;
        const FLAG_PFNINTERNALFREE			 = 0b100000;
    }
}


/// A builder for `VkAllocationCallbacks`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AllocationCallbacksBuilder<'b> {
    raw: vks::VkAllocationCallbacks,
    _p: PhantomData<&'b ()>, 
    set_mask: AllocationCallbacksFlags,
}

impl<'b> AllocationCallbacksBuilder<'b> {
    pub fn new() -> AllocationCallbacksBuilder<'b> {
        AllocationCallbacksBuilder {
            raw: vks::VkAllocationCallbacks::default(),
            _p: PhantomData,
            set_mask: AllocationCallbacksFlags::default(),
        }
    }

    pub unsafe fn user_data<'m>(mut self, user_data: *mut c_void) -> AllocationCallbacksBuilder<'b> {
        self.raw.pUserData = user_data;
        self.set_mask |= AllocationCallbacksFlags::FLAG_PUSERDATA;
        self
    }

    pub unsafe fn pfn_allocation<'m>(mut self, pfn_allocation: PFN_vkAllocationFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnAllocation = pfn_allocation.into();
        self.set_mask |= AllocationCallbacksFlags::FLAG_PFNALLOCATION;
        self
    }

    pub unsafe fn pfn_reallocation<'m>(mut self, pfn_reallocation: PFN_vkReallocationFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnReallocation = pfn_reallocation.into();
        self.set_mask |= AllocationCallbacksFlags::FLAG_PFNREALLOCATION;
        self
    }

    pub unsafe fn pfn_free<'m>(mut self, pfn_free: PFN_vkFreeFunction) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnFree = pfn_free.into();
        self.set_mask |= AllocationCallbacksFlags::FLAG_PFNFREE;
        self
    }

    pub unsafe fn pfn_internal_allocation<'m>(mut self, pfn_internal_allocation: PFN_vkInternalAllocationNotification) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnInternalAllocation = pfn_internal_allocation.into();
        self.set_mask |= AllocationCallbacksFlags::FLAG_PFNINTERNALALLOCATION;
        self
    }

    pub unsafe fn pfn_internal_free<'m>(mut self, pfn_internal_free: PFN_vkInternalFreeNotification) -> AllocationCallbacksBuilder<'b> {
        self.raw.pfnInternalFree = pfn_internal_free.into();
        self.set_mask |= AllocationCallbacksFlags::FLAG_PFNINTERNALFREE;
        self
    }

    pub fn get_user_data<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PUSERDATA != AllocationCallbacksFlags::FLAG_PUSERDATA { return None }
        Some( self.raw.pUserData )
    }

    pub fn get_pfn_allocation<'a>(&'a self) -> Option<PFN_vkAllocationFunction> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PFNALLOCATION != AllocationCallbacksFlags::FLAG_PFNALLOCATION { return None }
        Some( self.raw.pfnAllocation.into() )
    }

    pub fn get_pfn_reallocation<'a>(&'a self) -> Option<PFN_vkReallocationFunction> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PFNREALLOCATION != AllocationCallbacksFlags::FLAG_PFNREALLOCATION { return None }
        Some( self.raw.pfnReallocation.into() )
    }

    pub fn get_pfn_free<'a>(&'a self) -> Option<PFN_vkFreeFunction> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PFNFREE != AllocationCallbacksFlags::FLAG_PFNFREE { return None }
        Some( self.raw.pfnFree.into() )
    }

    pub fn get_pfn_internal_allocation<'a>(&'a self) -> Option<PFN_vkInternalAllocationNotification> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PFNINTERNALALLOCATION != AllocationCallbacksFlags::FLAG_PFNINTERNALALLOCATION { return None }
        Some( self.raw.pfnInternalAllocation.into() )
    }

    pub fn get_pfn_internal_free<'a>(&'a self) -> Option<PFN_vkInternalFreeNotification> {
        if self.set_mask & AllocationCallbacksFlags::FLAG_PFNINTERNALFREE != AllocationCallbacksFlags::FLAG_PFNINTERNALFREE { return None }
        Some( self.raw.pfnInternalFree.into() )
    }

    pub fn build(self) -> AllocationCallbacks<'b> {
        AllocationCallbacks {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceQueueCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceQueueCreateInfo<'s> {
    raw: vks::VkDeviceQueueCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceQueueCreateInfo<'s> {
    pub fn builder<'b>() -> DeviceQueueCreateInfoBuilder<'b> {
        DeviceQueueCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceQueueCreateInfo) -> DeviceQueueCreateInfo<'s> {
        DeviceQueueCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DeviceQueueCreateFlags {
        DeviceQueueCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceQueueCreateInfo::flags: error converting flags")
    }

    pub fn queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub fn queue_priorities<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pQueuePriorities as *const _, self.raw.queueCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DeviceQueueCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_family_index<'m>(&mut self, queue_family_index: u32) {
        self.raw.queueFamilyIndex = queue_family_index.into();
    }

    pub fn set_queue_priorities<'m, 'a>(&mut self, queue_priorities: &'a [f32])
            where 'a: 's {
        assert!(self.raw.queueCount == 0 || self.raw.queueCount == queue_priorities.len() as _, 
            "count inconsistency found when specifying `DeviceQueueCreateInfo::queue_priorities`.");
        self.raw.queueCount = queue_priorities.len() as _;
        self.raw.pQueuePriorities = queue_priorities.as_ptr() as *const f32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceQueueCreateInfo {
        &self.raw
    }
}

impl<'s> From<DeviceQueueCreateInfo<'s>> for vks::VkDeviceQueueCreateInfo {
    fn from(f: DeviceQueueCreateInfo<'s>) -> vks::VkDeviceQueueCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkDeviceQueueCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceQueueCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_QUEUEFAMILYINDEX			 = 0b1000;
        const FLAG_QUEUECOUNT			 = 0b10000;
        const FLAG_PQUEUEPRIORITIES			 = 0b100000;
    }
}


/// A builder for `VkDeviceQueueCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceQueueCreateInfoBuilder<'b> {
    raw: vks::VkDeviceQueueCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceQueueCreateInfoFlags,
}

impl<'b> DeviceQueueCreateInfoBuilder<'b> {
    pub fn new() -> DeviceQueueCreateInfoBuilder<'b> {
        DeviceQueueCreateInfoBuilder {
            raw: vks::VkDeviceQueueCreateInfo::default(),
            _p: PhantomData,
            set_mask: DeviceQueueCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceQueueCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DeviceQueueCreateFlags) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DeviceQueueCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn queue_family_index<'m>(mut self, queue_family_index: u32) -> DeviceQueueCreateInfoBuilder<'b> {
        self.raw.queueFamilyIndex = queue_family_index.into();
        self.set_mask |= DeviceQueueCreateInfoFlags::FLAG_QUEUEFAMILYINDEX;
        self
    }

    pub fn queue_priorities<'m, 'a>(mut self, queue_priorities: &'a [f32]) -> DeviceQueueCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueCount == 0 || self.raw.queueCount == queue_priorities.len() as _, 
            "count inconsistency found when specifying `DeviceQueueCreateInfo::queue_priorities`.");
        self.raw.queueCount = queue_priorities.len() as _;
        self.set_mask |= DeviceQueueCreateInfoFlags::FLAG_QUEUECOUNT;
        self.raw.pQueuePriorities = queue_priorities.as_ptr() as *const f32 as *const _;
        self.set_mask |= DeviceQueueCreateInfoFlags::FLAG_PQUEUEPRIORITIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceQueueCreateInfoFlags::FLAG_PNEXT != DeviceQueueCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DeviceQueueCreateFlags> {
        if self.set_mask & DeviceQueueCreateInfoFlags::FLAG_FLAGS != DeviceQueueCreateInfoFlags::FLAG_FLAGS { return None }
        Some( DeviceQueueCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceQueueCreateInfo::flags: error converting flags") )
    }

    pub fn get_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceQueueCreateInfoFlags::FLAG_QUEUEFAMILYINDEX != DeviceQueueCreateInfoFlags::FLAG_QUEUEFAMILYINDEX { return None }
        Some( self.raw.queueFamilyIndex.into() )
    }

    pub fn get_queue_priorities<'a>(&'a self) -> Option<&'a [f32]> {
        if self.set_mask & DeviceQueueCreateInfoFlags::FLAG_PQUEUEPRIORITIES != DeviceQueueCreateInfoFlags::FLAG_PQUEUEPRIORITIES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pQueuePriorities as *const _, self.raw.queueCount as usize) } )
    }

    pub fn build(self) -> DeviceQueueCreateInfo<'b> {
        DeviceQueueCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceCreateInfo<'s> {
    raw: vks::VkDeviceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceCreateInfo<'s> {
    pub fn builder<'b>() -> DeviceCreateInfoBuilder<'b> {
        DeviceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceCreateInfo) -> DeviceCreateInfo<'s> {
        DeviceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DeviceCreateFlags {
        DeviceCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceCreateInfo::flags: error converting flags")
    }

    pub fn queue_create_infos<'a>(&'a self) -> &'a [DeviceQueueCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pQueueCreateInfos as *const _, self.raw.queueCreateInfoCount as usize) }
    }

    pub fn enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub fn enabled_features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
        unsafe { &*(self.raw.pEnabledFeatures as *const vks::VkPhysicalDeviceFeatures as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DeviceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_create_infos<'m, 'a>(&mut self, queue_create_infos: &'a [DeviceQueueCreateInfo])
            where 'a: 's {
        assert!(self.raw.queueCreateInfoCount == 0 || self.raw.queueCreateInfoCount == queue_create_infos.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::queue_create_infos`.");
        self.raw.queueCreateInfoCount = queue_create_infos.len() as _;
        self.raw.pQueueCreateInfos = queue_create_infos.as_ptr() as *const vks::VkDeviceQueueCreateInfo;
    }

    pub fn set_enabled_layer_names<'m, 'a>(&mut self, enabled_layer_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
    }

    pub fn set_enabled_extension_names<'m, 'a>(&mut self, enabled_extension_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
    }

    pub fn set_enabled_features<'m, 'a>(&mut self, enabled_features: &'a PhysicalDeviceFeatures)
            where 'a: 's {
        self.raw.pEnabledFeatures = enabled_features.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceCreateInfo {
        &self.raw
    }
}

impl<'s> From<DeviceCreateInfo<'s>> for vks::VkDeviceCreateInfo {
    fn from(f: DeviceCreateInfo<'s>) -> vks::VkDeviceCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkDeviceCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_QUEUECREATEINFOCOUNT			 = 0b1000;
        const FLAG_PQUEUECREATEINFOS			 = 0b10000;
        const FLAG_ENABLEDLAYERCOUNT			 = 0b100000;
        const FLAG_PPENABLEDLAYERNAMES			 = 0b1000000;
        const FLAG_ENABLEDEXTENSIONCOUNT			 = 0b10000000;
        const FLAG_PPENABLEDEXTENSIONNAMES			 = 0b100000000;
        const FLAG_PENABLEDFEATURES			 = 0b1000000000;
    }
}


/// A builder for `VkDeviceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceCreateInfoBuilder<'b> {
    raw: vks::VkDeviceCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceCreateInfoFlags,
}

impl<'b> DeviceCreateInfoBuilder<'b> {
    pub fn new() -> DeviceCreateInfoBuilder<'b> {
        DeviceCreateInfoBuilder {
            raw: vks::VkDeviceCreateInfo::default(),
            _p: PhantomData,
            set_mask: DeviceCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DeviceCreateFlags) -> DeviceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DeviceCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn queue_create_infos<'m, 'a>(mut self, queue_create_infos: &'a [DeviceQueueCreateInfo]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueCreateInfoCount == 0 || self.raw.queueCreateInfoCount == queue_create_infos.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::queue_create_infos`.");
        self.raw.queueCreateInfoCount = queue_create_infos.len() as _;
        self.set_mask |= DeviceCreateInfoFlags::FLAG_QUEUECREATEINFOCOUNT;
        self.raw.pQueueCreateInfos = queue_create_infos.as_ptr() as *const vks::VkDeviceQueueCreateInfo;
        self
    }

    pub fn enabled_layer_names<'m, 'a>(mut self, enabled_layer_names: &'a [*const c_char]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.set_mask |= DeviceCreateInfoFlags::FLAG_ENABLEDLAYERCOUNT;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
        self.set_mask |= DeviceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES;
        self
    }

    pub fn enabled_extension_names<'m, 'a>(mut self, enabled_extension_names: &'a [*const c_char]) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `DeviceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.set_mask |= DeviceCreateInfoFlags::FLAG_ENABLEDEXTENSIONCOUNT;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
        self.set_mask |= DeviceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES;
        self
    }

    pub fn enabled_features<'m, 'a>(mut self, enabled_features: &'a PhysicalDeviceFeatures) -> DeviceCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pEnabledFeatures = enabled_features.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceCreateInfoFlags::FLAG_PNEXT != DeviceCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DeviceCreateFlags> {
        if self.set_mask & DeviceCreateInfoFlags::FLAG_FLAGS != DeviceCreateInfoFlags::FLAG_FLAGS { return None }
        Some( DeviceCreateFlags::from_bits(self.raw.flags)
            .expect("DeviceCreateInfo::flags: error converting flags") )
    }

    pub fn get_queue_create_infos<'a>(&'a self) -> Option<&'a [DeviceQueueCreateInfo]> {
        if self.raw.pQueueCreateInfos.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pQueueCreateInfos as *const _, self.raw.queueCreateInfoCount as usize) } )
    }

    pub fn get_enabled_layer_names<'a>(&'a self) -> Option<&'a [*const c_char]> {
        if self.set_mask & DeviceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES != DeviceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) } )
    }

    pub fn get_enabled_extension_names<'a>(&'a self) -> Option<&'a [*const c_char]> {
        if self.set_mask & DeviceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES != DeviceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) } )
    }

    pub fn get_enabled_features<'a>(&'a self) -> Option<&'a PhysicalDeviceFeatures> {
        if self.raw.pEnabledFeatures.is_null() { return None }
        Some( unsafe { &*(self.raw.pEnabledFeatures as *const vks::VkPhysicalDeviceFeatures as *const _) } )
    }

    pub fn build(self) -> DeviceCreateInfo<'b> {
        DeviceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkInstanceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct InstanceCreateInfo<'s> {
    raw: vks::VkInstanceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> InstanceCreateInfo<'s> {
    pub fn builder<'b>() -> InstanceCreateInfoBuilder<'b> {
        InstanceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkInstanceCreateInfo) -> InstanceCreateInfo<'s> {
        InstanceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> InstanceCreateFlags {
        InstanceCreateFlags::from_bits(self.raw.flags)
            .expect("InstanceCreateInfo::flags: error converting flags")
    }

    pub fn application_info<'a>(&'a self) -> &'a ApplicationInfo {
        unsafe { &*(self.raw.pApplicationInfo as *const vks::VkApplicationInfo as *const _) }
    }

    pub fn enabled_layer_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) }
    }

    pub fn enabled_extension_names<'a>(&'a self) -> &'a [*const c_char] {
        unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: InstanceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_application_info<'m, 'a>(&mut self, application_info: &'a ApplicationInfo)
            where 'a: 's {
        self.raw.pApplicationInfo = application_info.as_raw();
    }

    pub fn set_enabled_layer_names<'m, 'a>(&mut self, enabled_layer_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
    }

    pub fn set_enabled_extension_names<'m, 'a>(&mut self, enabled_extension_names: &'a [*const c_char])
            where 'a: 's {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
    }

    pub fn as_raw(&self) -> &vks::VkInstanceCreateInfo {
        &self.raw
    }
}

impl<'s> From<InstanceCreateInfo<'s>> for vks::VkInstanceCreateInfo {
    fn from(f: InstanceCreateInfo<'s>) -> vks::VkInstanceCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkInstanceCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct InstanceCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PAPPLICATIONINFO			 = 0b1000;
        const FLAG_ENABLEDLAYERCOUNT			 = 0b10000;
        const FLAG_PPENABLEDLAYERNAMES			 = 0b100000;
        const FLAG_ENABLEDEXTENSIONCOUNT			 = 0b1000000;
        const FLAG_PPENABLEDEXTENSIONNAMES			 = 0b10000000;
    }
}


/// A builder for `VkInstanceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct InstanceCreateInfoBuilder<'b> {
    raw: vks::VkInstanceCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: InstanceCreateInfoFlags,
}

impl<'b> InstanceCreateInfoBuilder<'b> {
    pub fn new() -> InstanceCreateInfoBuilder<'b> {
        InstanceCreateInfoBuilder {
            raw: vks::VkInstanceCreateInfo::default(),
            _p: PhantomData,
            set_mask: InstanceCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> InstanceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= InstanceCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: InstanceCreateFlags) -> InstanceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= InstanceCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn application_info<'m, 'a>(mut self, application_info: &'a ApplicationInfo) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pApplicationInfo = application_info.as_raw();
        self
    }

    pub fn enabled_layer_names<'m, 'a>(mut self, enabled_layer_names: &'a [*const c_char]) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledLayerCount == 0 || self.raw.enabledLayerCount == enabled_layer_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_layer_names`.");
        self.raw.enabledLayerCount = enabled_layer_names.len() as _;
        self.set_mask |= InstanceCreateInfoFlags::FLAG_ENABLEDLAYERCOUNT;
        self.raw.ppEnabledLayerNames = enabled_layer_names.as_ptr();
        self.set_mask |= InstanceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES;
        self
    }

    pub fn enabled_extension_names<'m, 'a>(mut self, enabled_extension_names: &'a [*const c_char]) -> InstanceCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.enabledExtensionCount == 0 || self.raw.enabledExtensionCount == enabled_extension_names.len() as _, 
            "count inconsistency found when specifying `InstanceCreateInfo::enabled_extension_names`.");
        self.raw.enabledExtensionCount = enabled_extension_names.len() as _;
        self.set_mask |= InstanceCreateInfoFlags::FLAG_ENABLEDEXTENSIONCOUNT;
        self.raw.ppEnabledExtensionNames = enabled_extension_names.as_ptr();
        self.set_mask |= InstanceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & InstanceCreateInfoFlags::FLAG_PNEXT != InstanceCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<InstanceCreateFlags> {
        if self.set_mask & InstanceCreateInfoFlags::FLAG_FLAGS != InstanceCreateInfoFlags::FLAG_FLAGS { return None }
        Some( InstanceCreateFlags::from_bits(self.raw.flags)
            .expect("InstanceCreateInfo::flags: error converting flags") )
    }

    pub fn get_application_info<'a>(&'a self) -> Option<&'a ApplicationInfo> {
        if self.raw.pApplicationInfo.is_null() { return None }
        Some( unsafe { &*(self.raw.pApplicationInfo as *const vks::VkApplicationInfo as *const _) } )
    }

    pub fn get_enabled_layer_names<'a>(&'a self) -> Option<&'a [*const c_char]> {
        if self.set_mask & InstanceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES != InstanceCreateInfoFlags::FLAG_PPENABLEDLAYERNAMES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.ppEnabledLayerNames as *const _, self.raw.enabledLayerCount as usize) } )
    }

    pub fn get_enabled_extension_names<'a>(&'a self) -> Option<&'a [*const c_char]> {
        if self.set_mask & InstanceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES != InstanceCreateInfoFlags::FLAG_PPENABLEDEXTENSIONNAMES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.ppEnabledExtensionNames as *const _, self.raw.enabledExtensionCount as usize) } )
    }

    pub fn build(self) -> InstanceCreateInfo<'b> {
        InstanceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueueFamilyProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueueFamilyProperties {
    raw: vks::VkQueueFamilyProperties,
}

impl QueueFamilyProperties {
    pub fn builder() -> QueueFamilyPropertiesBuilder {
        QueueFamilyPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueueFamilyProperties) -> QueueFamilyProperties {
        QueueFamilyProperties { raw, }
    }

    pub fn queue_flags<'a>(&'a self) -> QueueFlags {
        QueueFlags::from_bits(self.raw.queueFlags)
            .expect("QueueFamilyProperties::queue_flags: error converting flags")
    }

    pub fn queue_count<'a>(&'a self) -> u32 {
        self.raw.queueCount.into()
    }

    pub fn timestamp_valid_bits<'a>(&'a self) -> u32 {
        self.raw.timestampValidBits.into()
    }

    pub fn min_image_transfer_granularity<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.minImageTransferGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn min_image_transfer_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.minImageTransferGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_queue_flags<'m>(&mut self, queue_flags: QueueFlags) {
        self.raw.queueFlags = queue_flags.bits();
    }

    pub fn set_queue_count<'m>(&mut self, queue_count: u32) {
        self.raw.queueCount = queue_count.into();
    }

    pub fn set_timestamp_valid_bits<'m>(&mut self, timestamp_valid_bits: u32) {
        self.raw.timestampValidBits = timestamp_valid_bits.into();
    }

    pub fn set_min_image_transfer_granularity<'m>(&mut self, min_image_transfer_granularity: Extent3d) {
        self.raw.minImageTransferGranularity = min_image_transfer_granularity.raw;
    }

    pub fn as_raw(&self) -> &vks::VkQueueFamilyProperties {
        &self.raw
    }
}

impl From<QueueFamilyProperties> for vks::VkQueueFamilyProperties {
    fn from(f: QueueFamilyProperties) -> vks::VkQueueFamilyProperties {
        f.raw
    }
}


/// Bitflags for `VkQueueFamilyProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct QueueFamilyPropertiesFlags: u32 {
        const FLAG_QUEUEFLAGS			 = 0b1;
        const FLAG_QUEUECOUNT			 = 0b10;
        const FLAG_TIMESTAMPVALIDBITS			 = 0b100;
        const FLAG_MINIMAGETRANSFERGRANULARITY			 = 0b1000;
    }
}


/// A builder for `VkQueueFamilyProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueueFamilyPropertiesBuilder {
    raw: vks::VkQueueFamilyProperties,
    set_mask: QueueFamilyPropertiesFlags,
}

impl QueueFamilyPropertiesBuilder {
    pub fn new() -> QueueFamilyPropertiesBuilder {
        QueueFamilyPropertiesBuilder {
            raw: vks::VkQueueFamilyProperties::default(),
            set_mask: QueueFamilyPropertiesFlags::default(),
        }
    }

    pub fn queue_flags<'m>(mut self, queue_flags: QueueFlags) -> QueueFamilyPropertiesBuilder {
        self.raw.queueFlags = queue_flags.bits();
        self.set_mask |= QueueFamilyPropertiesFlags::FLAG_QUEUEFLAGS;
        self
    }

    pub fn queue_count<'m>(mut self, queue_count: u32) -> QueueFamilyPropertiesBuilder {
        self.raw.queueCount = queue_count.into();
        self.set_mask |= QueueFamilyPropertiesFlags::FLAG_QUEUECOUNT;
        self
    }

    pub fn timestamp_valid_bits<'m>(mut self, timestamp_valid_bits: u32) -> QueueFamilyPropertiesBuilder {
        self.raw.timestampValidBits = timestamp_valid_bits.into();
        self.set_mask |= QueueFamilyPropertiesFlags::FLAG_TIMESTAMPVALIDBITS;
        self
    }

    pub fn min_image_transfer_granularity<'m>(mut self, min_image_transfer_granularity: Extent3d) -> QueueFamilyPropertiesBuilder {
        self.raw.minImageTransferGranularity = min_image_transfer_granularity.raw;
        self.set_mask |= QueueFamilyPropertiesFlags::FLAG_MINIMAGETRANSFERGRANULARITY;
        self
    }

    pub fn get_queue_flags<'a>(&'a self) -> Option<QueueFlags> {
        if self.set_mask & QueueFamilyPropertiesFlags::FLAG_QUEUEFLAGS != QueueFamilyPropertiesFlags::FLAG_QUEUEFLAGS { return None }
        Some( QueueFlags::from_bits(self.raw.queueFlags)
            .expect("QueueFamilyProperties::queue_flags: error converting flags") )
    }

    pub fn get_queue_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & QueueFamilyPropertiesFlags::FLAG_QUEUECOUNT != QueueFamilyPropertiesFlags::FLAG_QUEUECOUNT { return None }
        Some( self.raw.queueCount.into() )
    }

    pub fn get_timestamp_valid_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & QueueFamilyPropertiesFlags::FLAG_TIMESTAMPVALIDBITS != QueueFamilyPropertiesFlags::FLAG_TIMESTAMPVALIDBITS { return None }
        Some( self.raw.timestampValidBits.into() )
    }

    pub fn get_min_image_transfer_granularity<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & QueueFamilyPropertiesFlags::FLAG_MINIMAGETRANSFERGRANULARITY != QueueFamilyPropertiesFlags::FLAG_MINIMAGETRANSFERGRANULARITY { return None }
        Some(  unsafe { &*(&self.raw.minImageTransferGranularity as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_min_image_transfer_granularity_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & QueueFamilyPropertiesFlags::FLAG_MINIMAGETRANSFERGRANULARITY != QueueFamilyPropertiesFlags::FLAG_MINIMAGETRANSFERGRANULARITY { return None }
        Some( unsafe { &mut *(&mut self.raw.minImageTransferGranularity as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn build(self) -> QueueFamilyProperties {
        QueueFamilyProperties {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceMemoryProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties {
    raw: vks::VkPhysicalDeviceMemoryProperties,
}

impl PhysicalDeviceMemoryProperties {
    pub fn builder() -> PhysicalDeviceMemoryPropertiesBuilder {
        PhysicalDeviceMemoryPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMemoryProperties) -> PhysicalDeviceMemoryProperties {
        PhysicalDeviceMemoryProperties { raw, }
    }

    pub fn memory_type_count<'a>(&'a self) -> u32 {
        self.raw.memoryTypeCount.into()
    }

    pub fn memory_types<'a>(&'a self) -> &[MemoryType] {
         unsafe { slice::from_raw_parts(&self.raw.memoryTypes as *const vks::VkMemoryType as *const _, vks::VK_MAX_MEMORY_TYPES as usize) }
    }

    pub fn memory_heap_count<'a>(&'a self) -> u32 {
        self.raw.memoryHeapCount.into()
    }

    pub fn memory_heaps<'a>(&'a self) -> &[MemoryHeap] {
         unsafe { slice::from_raw_parts(&self.raw.memoryHeaps as *const vks::VkMemoryHeap as *const _, vks::VK_MAX_MEMORY_HEAPS as usize) }
    }

    pub fn set_memory_type_count<'m>(&mut self, memory_type_count: u32) {
        self.raw.memoryTypeCount = memory_type_count.into();
    }

    pub fn set_memory_types<'m>(&mut self, memory_types: [MemoryType; vks::VK_MAX_MEMORY_TYPES]) {
        self.raw.memoryTypes = unsafe { *(&memory_types as *const [MemoryType; vks::VK_MAX_MEMORY_TYPES] as *const _) };
    }

    pub fn set_memory_heap_count<'m>(&mut self, memory_heap_count: u32) {
        self.raw.memoryHeapCount = memory_heap_count.into();
    }

    pub fn set_memory_heaps<'m>(&mut self, memory_heaps: [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS]) {
        self.raw.memoryHeaps = unsafe { *(&memory_heaps as *const [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS] as *const _) };
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMemoryProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceMemoryProperties> for vks::VkPhysicalDeviceMemoryProperties {
    fn from(f: PhysicalDeviceMemoryProperties) -> vks::VkPhysicalDeviceMemoryProperties {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceMemoryProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceMemoryPropertiesFlags: u32 {
        const FLAG_MEMORYTYPECOUNT			 = 0b1;
        const FLAG_MEMORYTYPES			 = 0b10;
        const FLAG_MEMORYHEAPCOUNT			 = 0b100;
        const FLAG_MEMORYHEAPS			 = 0b1000;
    }
}


/// A builder for `VkPhysicalDeviceMemoryProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMemoryPropertiesBuilder {
    raw: vks::VkPhysicalDeviceMemoryProperties,
    set_mask: PhysicalDeviceMemoryPropertiesFlags,
}

impl PhysicalDeviceMemoryPropertiesBuilder {
    pub fn new() -> PhysicalDeviceMemoryPropertiesBuilder {
        PhysicalDeviceMemoryPropertiesBuilder {
            raw: vks::VkPhysicalDeviceMemoryProperties::default(),
            set_mask: PhysicalDeviceMemoryPropertiesFlags::default(),
        }
    }

    pub fn memory_type_count<'m>(mut self, memory_type_count: u32) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryTypeCount = memory_type_count.into();
        self.set_mask |= PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPECOUNT;
        self
    }

    pub fn memory_types<'m>(mut self, memory_types: [MemoryType; vks::VK_MAX_MEMORY_TYPES]) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryTypes = unsafe { *(&memory_types as *const [MemoryType; vks::VK_MAX_MEMORY_TYPES] as *const _) };
        self.set_mask |= PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPES;
        self
    }

    pub fn memory_heap_count<'m>(mut self, memory_heap_count: u32) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryHeapCount = memory_heap_count.into();
        self.set_mask |= PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPCOUNT;
        self
    }

    pub fn memory_heaps<'m>(mut self, memory_heaps: [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS]) -> PhysicalDeviceMemoryPropertiesBuilder {
        self.raw.memoryHeaps = unsafe { *(&memory_heaps as *const [MemoryHeap; vks::VK_MAX_MEMORY_HEAPS] as *const _) };
        self.set_mask |= PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPS;
        self
    }

    pub fn get_memory_type_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPECOUNT != PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPECOUNT { return None }
        Some( self.raw.memoryTypeCount.into() )
    }

    pub fn get_memory_types<'a>(&'a self) -> Option<&[MemoryType]> {
        if self.set_mask & PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPES != PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYTYPES { return None }
        Some(  unsafe { slice::from_raw_parts(&self.raw.memoryTypes as *const vks::VkMemoryType as *const _, vks::VK_MAX_MEMORY_TYPES as usize) } )
    }

    pub fn get_memory_heap_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPCOUNT != PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPCOUNT { return None }
        Some( self.raw.memoryHeapCount.into() )
    }

    pub fn get_memory_heaps<'a>(&'a self) -> Option<&[MemoryHeap]> {
        if self.set_mask & PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPS != PhysicalDeviceMemoryPropertiesFlags::FLAG_MEMORYHEAPS { return None }
        Some(  unsafe { slice::from_raw_parts(&self.raw.memoryHeaps as *const vks::VkMemoryHeap as *const _, vks::VK_MAX_MEMORY_HEAPS as usize) } )
    }

    pub fn build(self) -> PhysicalDeviceMemoryProperties {
        PhysicalDeviceMemoryProperties {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryAllocateInfo<'s> {
    raw: vks::VkMemoryAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryAllocateInfo<'s> {
    pub fn builder<'b>() -> MemoryAllocateInfoBuilder<'b> {
        MemoryAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryAllocateInfo) -> MemoryAllocateInfo<'s> {
        MemoryAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn allocation_size<'a>(&'a self) -> u64 {
        self.raw.allocationSize.into()
    }

    pub fn memory_type_index<'a>(&'a self) -> u32 {
        self.raw.memoryTypeIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_allocation_size<'m>(&mut self, allocation_size: u64) {
        self.raw.allocationSize = allocation_size.into();
    }

    pub fn set_memory_type_index<'m>(&mut self, memory_type_index: u32) {
        self.raw.memoryTypeIndex = memory_type_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryAllocateInfo {
        &self.raw
    }
}

impl<'s> From<MemoryAllocateInfo<'s>> for vks::VkMemoryAllocateInfo {
    fn from(f: MemoryAllocateInfo<'s>) -> vks::VkMemoryAllocateInfo {
        f.raw
    }
}


/// Bitflags for `VkMemoryAllocateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryAllocateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_ALLOCATIONSIZE			 = 0b100;
        const FLAG_MEMORYTYPEINDEX			 = 0b1000;
    }
}


/// A builder for `VkMemoryAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryAllocateInfoBuilder<'b> {
    raw: vks::VkMemoryAllocateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryAllocateInfoFlags,
}

impl<'b> MemoryAllocateInfoBuilder<'b> {
    pub fn new() -> MemoryAllocateInfoBuilder<'b> {
        MemoryAllocateInfoBuilder {
            raw: vks::VkMemoryAllocateInfo::default(),
            _p: PhantomData,
            set_mask: MemoryAllocateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryAllocateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn allocation_size<'m>(mut self, allocation_size: u64) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.allocationSize = allocation_size.into();
        self.set_mask |= MemoryAllocateInfoFlags::FLAG_ALLOCATIONSIZE;
        self
    }

    pub fn memory_type_index<'m>(mut self, memory_type_index: u32) -> MemoryAllocateInfoBuilder<'b> {
        self.raw.memoryTypeIndex = memory_type_index.into();
        self.set_mask |= MemoryAllocateInfoFlags::FLAG_MEMORYTYPEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryAllocateInfoFlags::FLAG_PNEXT != MemoryAllocateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_allocation_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MemoryAllocateInfoFlags::FLAG_ALLOCATIONSIZE != MemoryAllocateInfoFlags::FLAG_ALLOCATIONSIZE { return None }
        Some( self.raw.allocationSize.into() )
    }

    pub fn get_memory_type_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryAllocateInfoFlags::FLAG_MEMORYTYPEINDEX != MemoryAllocateInfoFlags::FLAG_MEMORYTYPEINDEX { return None }
        Some( self.raw.memoryTypeIndex.into() )
    }

    pub fn build(self) -> MemoryAllocateInfo<'b> {
        MemoryAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryRequirements {
    raw: vks::VkMemoryRequirements,
}

impl MemoryRequirements {
    pub fn builder() -> MemoryRequirementsBuilder {
        MemoryRequirementsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryRequirements) -> MemoryRequirements {
        MemoryRequirements { raw, }
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn alignment<'a>(&'a self) -> u64 {
        self.raw.alignment.into()
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_alignment<'m>(&mut self, alignment: u64) {
        self.raw.alignment = alignment.into();
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryRequirements {
        &self.raw
    }
}

impl From<MemoryRequirements> for vks::VkMemoryRequirements {
    fn from(f: MemoryRequirements) -> vks::VkMemoryRequirements {
        f.raw
    }
}


/// Bitflags for `VkMemoryRequirements`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryRequirementsFlags: u32 {
        const FLAG_SIZE			 = 0b1;
        const FLAG_ALIGNMENT			 = 0b10;
        const FLAG_MEMORYTYPEBITS			 = 0b100;
    }
}


/// A builder for `VkMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryRequirementsBuilder {
    raw: vks::VkMemoryRequirements,
    set_mask: MemoryRequirementsFlags,
}

impl MemoryRequirementsBuilder {
    pub fn new() -> MemoryRequirementsBuilder {
        MemoryRequirementsBuilder {
            raw: vks::VkMemoryRequirements::default(),
            set_mask: MemoryRequirementsFlags::default(),
        }
    }

    pub fn size<'m>(mut self, size: u64) -> MemoryRequirementsBuilder {
        self.raw.size = size.into();
        self.set_mask |= MemoryRequirementsFlags::FLAG_SIZE;
        self
    }

    pub fn alignment<'m>(mut self, alignment: u64) -> MemoryRequirementsBuilder {
        self.raw.alignment = alignment.into();
        self.set_mask |= MemoryRequirementsFlags::FLAG_ALIGNMENT;
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryRequirementsBuilder {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self.set_mask |= MemoryRequirementsFlags::FLAG_MEMORYTYPEBITS;
        self
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MemoryRequirementsFlags::FLAG_SIZE != MemoryRequirementsFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn get_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MemoryRequirementsFlags::FLAG_ALIGNMENT != MemoryRequirementsFlags::FLAG_ALIGNMENT { return None }
        Some( self.raw.alignment.into() )
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryRequirementsFlags::FLAG_MEMORYTYPEBITS != MemoryRequirementsFlags::FLAG_MEMORYTYPEBITS { return None }
        Some( self.raw.memoryTypeBits.into() )
    }

    pub fn build(self) -> MemoryRequirements {
        MemoryRequirements {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageFormatProperties {
    raw: vks::VkSparseImageFormatProperties,
}

impl SparseImageFormatProperties {
    pub fn builder() -> SparseImageFormatPropertiesBuilder {
        SparseImageFormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageFormatProperties) -> SparseImageFormatProperties {
        SparseImageFormatProperties { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("SparseImageFormatProperties::aspect_mask: error converting flags")
    }

    pub fn image_granularity<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.imageGranularity as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn image_granularity_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageGranularity as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn flags<'a>(&'a self) -> SparseImageFormatFlags {
        SparseImageFormatFlags::from_bits(self.raw.flags)
            .expect("SparseImageFormatProperties::flags: error converting flags")
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_image_granularity<'m>(&mut self, image_granularity: Extent3d) {
        self.raw.imageGranularity = image_granularity.raw;
    }

    pub fn set_flags<'m>(&mut self, flags: SparseImageFormatFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageFormatProperties {
        &self.raw
    }
}

impl From<SparseImageFormatProperties> for vks::VkSparseImageFormatProperties {
    fn from(f: SparseImageFormatProperties) -> vks::VkSparseImageFormatProperties {
        f.raw
    }
}


/// Bitflags for `VkSparseImageFormatProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageFormatPropertiesFlags: u32 {
        const FLAG_ASPECTMASK			 = 0b1;
        const FLAG_IMAGEGRANULARITY			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
    }
}


/// A builder for `VkSparseImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageFormatPropertiesBuilder {
    raw: vks::VkSparseImageFormatProperties,
    set_mask: SparseImageFormatPropertiesFlags,
}

impl SparseImageFormatPropertiesBuilder {
    pub fn new() -> SparseImageFormatPropertiesBuilder {
        SparseImageFormatPropertiesBuilder {
            raw: vks::VkSparseImageFormatProperties::default(),
            set_mask: SparseImageFormatPropertiesFlags::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> SparseImageFormatPropertiesBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self.set_mask |= SparseImageFormatPropertiesFlags::FLAG_ASPECTMASK;
        self
    }

    pub fn image_granularity<'m>(mut self, image_granularity: Extent3d) -> SparseImageFormatPropertiesBuilder {
        self.raw.imageGranularity = image_granularity.raw;
        self.set_mask |= SparseImageFormatPropertiesFlags::FLAG_IMAGEGRANULARITY;
        self
    }

    pub fn flags<'m>(mut self, flags: SparseImageFormatFlags) -> SparseImageFormatPropertiesBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= SparseImageFormatPropertiesFlags::FLAG_FLAGS;
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> Option<ImageAspectFlags> {
        if self.set_mask & SparseImageFormatPropertiesFlags::FLAG_ASPECTMASK != SparseImageFormatPropertiesFlags::FLAG_ASPECTMASK { return None }
        Some( ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("SparseImageFormatProperties::aspect_mask: error converting flags") )
    }

    pub fn get_image_granularity<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & SparseImageFormatPropertiesFlags::FLAG_IMAGEGRANULARITY != SparseImageFormatPropertiesFlags::FLAG_IMAGEGRANULARITY { return None }
        Some(  unsafe { &*(&self.raw.imageGranularity as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_image_granularity_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & SparseImageFormatPropertiesFlags::FLAG_IMAGEGRANULARITY != SparseImageFormatPropertiesFlags::FLAG_IMAGEGRANULARITY { return None }
        Some( unsafe { &mut *(&mut self.raw.imageGranularity as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SparseImageFormatFlags> {
        if self.set_mask & SparseImageFormatPropertiesFlags::FLAG_FLAGS != SparseImageFormatPropertiesFlags::FLAG_FLAGS { return None }
        Some( SparseImageFormatFlags::from_bits(self.raw.flags)
            .expect("SparseImageFormatProperties::flags: error converting flags") )
    }

    pub fn build(self) -> SparseImageFormatProperties {
        SparseImageFormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryRequirements {
    raw: vks::VkSparseImageMemoryRequirements,
}

impl SparseImageMemoryRequirements {
    pub fn builder() -> SparseImageMemoryRequirementsBuilder {
        SparseImageMemoryRequirementsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryRequirements) -> SparseImageMemoryRequirements {
        SparseImageMemoryRequirements { raw, }
    }

    pub fn format_properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
         unsafe { &*(&self.raw.formatProperties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn format_properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub fn image_mip_tail_first_lod<'a>(&'a self) -> u32 {
        self.raw.imageMipTailFirstLod.into()
    }

    pub fn image_mip_tail_size<'a>(&'a self) -> u64 {
        self.raw.imageMipTailSize.into()
    }

    pub fn image_mip_tail_offset<'a>(&'a self) -> u64 {
        self.raw.imageMipTailOffset.into()
    }

    pub fn image_mip_tail_stride<'a>(&'a self) -> u64 {
        self.raw.imageMipTailStride.into()
    }

    pub fn set_format_properties<'m>(&mut self, format_properties: SparseImageFormatProperties) {
        self.raw.formatProperties = format_properties.raw;
    }

    pub fn set_image_mip_tail_first_lod<'m>(&mut self, image_mip_tail_first_lod: u32) {
        self.raw.imageMipTailFirstLod = image_mip_tail_first_lod.into();
    }

    pub fn set_image_mip_tail_size<'m>(&mut self, image_mip_tail_size: u64) {
        self.raw.imageMipTailSize = image_mip_tail_size.into();
    }

    pub fn set_image_mip_tail_offset<'m>(&mut self, image_mip_tail_offset: u64) {
        self.raw.imageMipTailOffset = image_mip_tail_offset.into();
    }

    pub fn set_image_mip_tail_stride<'m>(&mut self, image_mip_tail_stride: u64) {
        self.raw.imageMipTailStride = image_mip_tail_stride.into();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryRequirements {
        &self.raw
    }
}

impl From<SparseImageMemoryRequirements> for vks::VkSparseImageMemoryRequirements {
    fn from(f: SparseImageMemoryRequirements) -> vks::VkSparseImageMemoryRequirements {
        f.raw
    }
}


/// Bitflags for `VkSparseImageMemoryRequirements`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageMemoryRequirementsFlags: u32 {
        const FLAG_FORMATPROPERTIES			 = 0b1;
        const FLAG_IMAGEMIPTAILFIRSTLOD			 = 0b10;
        const FLAG_IMAGEMIPTAILSIZE			 = 0b100;
        const FLAG_IMAGEMIPTAILOFFSET			 = 0b1000;
        const FLAG_IMAGEMIPTAILSTRIDE			 = 0b10000;
    }
}


/// A builder for `VkSparseImageMemoryRequirements`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryRequirementsBuilder {
    raw: vks::VkSparseImageMemoryRequirements,
    set_mask: SparseImageMemoryRequirementsFlags,
}

impl SparseImageMemoryRequirementsBuilder {
    pub fn new() -> SparseImageMemoryRequirementsBuilder {
        SparseImageMemoryRequirementsBuilder {
            raw: vks::VkSparseImageMemoryRequirements::default(),
            set_mask: SparseImageMemoryRequirementsFlags::default(),
        }
    }

    pub fn format_properties<'m>(mut self, format_properties: SparseImageFormatProperties) -> SparseImageMemoryRequirementsBuilder {
        self.raw.formatProperties = format_properties.raw;
        self.set_mask |= SparseImageMemoryRequirementsFlags::FLAG_FORMATPROPERTIES;
        self
    }

    pub fn image_mip_tail_first_lod<'m>(mut self, image_mip_tail_first_lod: u32) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailFirstLod = image_mip_tail_first_lod.into();
        self.set_mask |= SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILFIRSTLOD;
        self
    }

    pub fn image_mip_tail_size<'m>(mut self, image_mip_tail_size: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailSize = image_mip_tail_size.into();
        self.set_mask |= SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSIZE;
        self
    }

    pub fn image_mip_tail_offset<'m>(mut self, image_mip_tail_offset: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailOffset = image_mip_tail_offset.into();
        self.set_mask |= SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILOFFSET;
        self
    }

    pub fn image_mip_tail_stride<'m>(mut self, image_mip_tail_stride: u64) -> SparseImageMemoryRequirementsBuilder {
        self.raw.imageMipTailStride = image_mip_tail_stride.into();
        self.set_mask |= SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSTRIDE;
        self
    }

    pub fn get_format_properties<'a>(&'a self) -> Option<&'a SparseImageFormatProperties> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_FORMATPROPERTIES != SparseImageMemoryRequirementsFlags::FLAG_FORMATPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.formatProperties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) } )
    }

    pub fn get_format_properties_mut<'a>(&'a mut self) -> Option<&'a mut SparseImageFormatProperties> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_FORMATPROPERTIES != SparseImageMemoryRequirementsFlags::FLAG_FORMATPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) } )
    }

    pub fn get_image_mip_tail_first_lod<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILFIRSTLOD != SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILFIRSTLOD { return None }
        Some( self.raw.imageMipTailFirstLod.into() )
    }

    pub fn get_image_mip_tail_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSIZE != SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSIZE { return None }
        Some( self.raw.imageMipTailSize.into() )
    }

    pub fn get_image_mip_tail_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILOFFSET != SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILOFFSET { return None }
        Some( self.raw.imageMipTailOffset.into() )
    }

    pub fn get_image_mip_tail_stride<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSTRIDE != SparseImageMemoryRequirementsFlags::FLAG_IMAGEMIPTAILSTRIDE { return None }
        Some( self.raw.imageMipTailStride.into() )
    }

    pub fn build(self) -> SparseImageMemoryRequirements {
        SparseImageMemoryRequirements {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryType`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryType {
    raw: vks::VkMemoryType,
}

impl MemoryType {
    pub fn builder() -> MemoryTypeBuilder {
        MemoryTypeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryType) -> MemoryType {
        MemoryType { raw, }
    }

    pub fn property_flags<'a>(&'a self) -> MemoryPropertyFlags {
        MemoryPropertyFlags::from_bits(self.raw.propertyFlags)
            .expect("MemoryType::property_flags: error converting flags")
    }

    pub fn heap_index<'a>(&'a self) -> u32 {
        self.raw.heapIndex.into()
    }

    pub fn set_property_flags<'m>(&mut self, property_flags: MemoryPropertyFlags) {
        self.raw.propertyFlags = property_flags.bits();
    }

    pub fn set_heap_index<'m>(&mut self, heap_index: u32) {
        self.raw.heapIndex = heap_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryType {
        &self.raw
    }
}

impl From<MemoryType> for vks::VkMemoryType {
    fn from(f: MemoryType) -> vks::VkMemoryType {
        f.raw
    }
}


/// Bitflags for `VkMemoryType`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryTypeFlags: u32 {
        const FLAG_PROPERTYFLAGS			 = 0b1;
        const FLAG_HEAPINDEX			 = 0b10;
    }
}


/// A builder for `VkMemoryType`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryTypeBuilder {
    raw: vks::VkMemoryType,
    set_mask: MemoryTypeFlags,
}

impl MemoryTypeBuilder {
    pub fn new() -> MemoryTypeBuilder {
        MemoryTypeBuilder {
            raw: vks::VkMemoryType::default(),
            set_mask: MemoryTypeFlags::default(),
        }
    }

    pub fn property_flags<'m>(mut self, property_flags: MemoryPropertyFlags) -> MemoryTypeBuilder {
        self.raw.propertyFlags = property_flags.bits();
        self.set_mask |= MemoryTypeFlags::FLAG_PROPERTYFLAGS;
        self
    }

    pub fn heap_index<'m>(mut self, heap_index: u32) -> MemoryTypeBuilder {
        self.raw.heapIndex = heap_index.into();
        self.set_mask |= MemoryTypeFlags::FLAG_HEAPINDEX;
        self
    }

    pub fn get_property_flags<'a>(&'a self) -> Option<MemoryPropertyFlags> {
        if self.set_mask & MemoryTypeFlags::FLAG_PROPERTYFLAGS != MemoryTypeFlags::FLAG_PROPERTYFLAGS { return None }
        Some( MemoryPropertyFlags::from_bits(self.raw.propertyFlags)
            .expect("MemoryType::property_flags: error converting flags") )
    }

    pub fn get_heap_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryTypeFlags::FLAG_HEAPINDEX != MemoryTypeFlags::FLAG_HEAPINDEX { return None }
        Some( self.raw.heapIndex.into() )
    }

    pub fn build(self) -> MemoryType {
        MemoryType {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryHeap`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryHeap {
    raw: vks::VkMemoryHeap,
}

impl MemoryHeap {
    pub fn builder() -> MemoryHeapBuilder {
        MemoryHeapBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryHeap) -> MemoryHeap {
        MemoryHeap { raw, }
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn flags<'a>(&'a self) -> MemoryHeapFlags {
        MemoryHeapFlags::from_bits(self.raw.flags)
            .expect("MemoryHeap::flags: error converting flags")
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_flags<'m>(&mut self, flags: MemoryHeapFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryHeap {
        &self.raw
    }
}

impl From<MemoryHeap> for vks::VkMemoryHeap {
    fn from(f: MemoryHeap) -> vks::VkMemoryHeap {
        f.raw
    }
}


/// Bitflags for `VkMemoryHeap`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryHeapFlags: u32 {
        const FLAG_SIZE			 = 0b1;
        const FLAG_FLAGS			 = 0b10;
    }
}


/// A builder for `VkMemoryHeap`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryHeapBuilder {
    raw: vks::VkMemoryHeap,
    set_mask: MemoryHeapFlags,
}

impl MemoryHeapBuilder {
    pub fn new() -> MemoryHeapBuilder {
        MemoryHeapBuilder {
            raw: vks::VkMemoryHeap::default(),
            set_mask: MemoryHeapFlags::default(),
        }
    }

    pub fn size<'m>(mut self, size: u64) -> MemoryHeapBuilder {
        self.raw.size = size.into();
        self.set_mask |= MemoryHeapFlags::FLAG_SIZE;
        self
    }

    pub fn flags<'m>(mut self, flags: MemoryHeapFlags) -> MemoryHeapBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= MemoryHeapFlags::FLAG_FLAGS;
        self
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MemoryHeapFlags::FLAG_SIZE != MemoryHeapFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<MemoryHeapFlags> {
        if self.set_mask & MemoryHeapFlags::FLAG_FLAGS != MemoryHeapFlags::FLAG_FLAGS { return None }
        Some( MemoryHeapFlags::from_bits(self.raw.flags)
            .expect("MemoryHeap::flags: error converting flags") )
    }

    pub fn build(self) -> MemoryHeap {
        MemoryHeap {
            raw: self.raw,
        }
    }
}


/// A `VkMappedMemoryRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MappedMemoryRange<'s> {
    raw: vks::VkMappedMemoryRange,
    _p: PhantomData<&'s ()>,
}

impl<'s> MappedMemoryRange<'s> {
    pub fn builder<'b>() -> MappedMemoryRangeBuilder<'b> {
        MappedMemoryRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMappedMemoryRange) -> MappedMemoryRange<'s> {
        MappedMemoryRange { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkMappedMemoryRange {
        &self.raw
    }
}

impl<'s> From<MappedMemoryRange<'s>> for vks::VkMappedMemoryRange {
    fn from(f: MappedMemoryRange<'s>) -> vks::VkMappedMemoryRange {
        f.raw
    }
}


/// Bitflags for `VkMappedMemoryRange`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MappedMemoryRangeFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORY			 = 0b100;
        const FLAG_OFFSET			 = 0b1000;
        const FLAG_SIZE			 = 0b10000;
    }
}


/// A builder for `VkMappedMemoryRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MappedMemoryRangeBuilder<'b> {
    raw: vks::VkMappedMemoryRange,
    _p: PhantomData<&'b ()>, 
    set_mask: MappedMemoryRangeFlags,
}

impl<'b> MappedMemoryRangeBuilder<'b> {
    pub fn new() -> MappedMemoryRangeBuilder<'b> {
        MappedMemoryRangeBuilder {
            raw: vks::VkMappedMemoryRange::default(),
            _p: PhantomData,
            set_mask: MappedMemoryRangeFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MappedMemoryRangeBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MappedMemoryRangeFlags::FLAG_PNEXT;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MappedMemoryRangeBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self.set_mask |= MappedMemoryRangeFlags::FLAG_MEMORY;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> MappedMemoryRangeBuilder<'b> {
        self.raw.offset = offset.into();
        self.set_mask |= MappedMemoryRangeFlags::FLAG_OFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> MappedMemoryRangeBuilder<'b> {
        self.raw.size = size.into();
        self.set_mask |= MappedMemoryRangeFlags::FLAG_SIZE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MappedMemoryRangeFlags::FLAG_PNEXT != MappedMemoryRangeFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory<'a>(&'a self) -> Option<vks::VkDeviceMemory> {
        if self.set_mask & MappedMemoryRangeFlags::FLAG_MEMORY != MappedMemoryRangeFlags::FLAG_MEMORY { return None }
        Some( self.raw.memory )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MappedMemoryRangeFlags::FLAG_OFFSET != MappedMemoryRangeFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & MappedMemoryRangeFlags::FLAG_SIZE != MappedMemoryRangeFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn build(self) -> MappedMemoryRange<'b> {
        MappedMemoryRange {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FormatProperties {
    raw: vks::VkFormatProperties,
}

impl FormatProperties {
    pub fn builder() -> FormatPropertiesBuilder {
        FormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFormatProperties) -> FormatProperties {
        FormatProperties { raw, }
    }

    pub fn linear_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.linearTilingFeatures)
            .expect("FormatProperties::linear_tiling_features: error converting flags")
    }

    pub fn optimal_tiling_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.optimalTilingFeatures)
            .expect("FormatProperties::optimal_tiling_features: error converting flags")
    }

    pub fn buffer_features<'a>(&'a self) -> FormatFeatureFlags {
        FormatFeatureFlags::from_bits(self.raw.bufferFeatures)
            .expect("FormatProperties::buffer_features: error converting flags")
    }

    pub fn set_linear_tiling_features<'m>(&mut self, linear_tiling_features: FormatFeatureFlags) {
        self.raw.linearTilingFeatures = linear_tiling_features.bits();
    }

    pub fn set_optimal_tiling_features<'m>(&mut self, optimal_tiling_features: FormatFeatureFlags) {
        self.raw.optimalTilingFeatures = optimal_tiling_features.bits();
    }

    pub fn set_buffer_features<'m>(&mut self, buffer_features: FormatFeatureFlags) {
        self.raw.bufferFeatures = buffer_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFormatProperties {
        &self.raw
    }
}

impl From<FormatProperties> for vks::VkFormatProperties {
    fn from(f: FormatProperties) -> vks::VkFormatProperties {
        f.raw
    }
}


/// Bitflags for `VkFormatProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FormatPropertiesFlags: u32 {
        const FLAG_LINEARTILINGFEATURES			 = 0b1;
        const FLAG_OPTIMALTILINGFEATURES			 = 0b10;
        const FLAG_BUFFERFEATURES			 = 0b100;
    }
}


/// A builder for `VkFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FormatPropertiesBuilder {
    raw: vks::VkFormatProperties,
    set_mask: FormatPropertiesFlags,
}

impl FormatPropertiesBuilder {
    pub fn new() -> FormatPropertiesBuilder {
        FormatPropertiesBuilder {
            raw: vks::VkFormatProperties::default(),
            set_mask: FormatPropertiesFlags::default(),
        }
    }

    pub fn linear_tiling_features<'m>(mut self, linear_tiling_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.linearTilingFeatures = linear_tiling_features.bits();
        self.set_mask |= FormatPropertiesFlags::FLAG_LINEARTILINGFEATURES;
        self
    }

    pub fn optimal_tiling_features<'m>(mut self, optimal_tiling_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.optimalTilingFeatures = optimal_tiling_features.bits();
        self.set_mask |= FormatPropertiesFlags::FLAG_OPTIMALTILINGFEATURES;
        self
    }

    pub fn buffer_features<'m>(mut self, buffer_features: FormatFeatureFlags) -> FormatPropertiesBuilder {
        self.raw.bufferFeatures = buffer_features.bits();
        self.set_mask |= FormatPropertiesFlags::FLAG_BUFFERFEATURES;
        self
    }

    pub fn get_linear_tiling_features<'a>(&'a self) -> Option<FormatFeatureFlags> {
        if self.set_mask & FormatPropertiesFlags::FLAG_LINEARTILINGFEATURES != FormatPropertiesFlags::FLAG_LINEARTILINGFEATURES { return None }
        Some( FormatFeatureFlags::from_bits(self.raw.linearTilingFeatures)
            .expect("FormatProperties::linear_tiling_features: error converting flags") )
    }

    pub fn get_optimal_tiling_features<'a>(&'a self) -> Option<FormatFeatureFlags> {
        if self.set_mask & FormatPropertiesFlags::FLAG_OPTIMALTILINGFEATURES != FormatPropertiesFlags::FLAG_OPTIMALTILINGFEATURES { return None }
        Some( FormatFeatureFlags::from_bits(self.raw.optimalTilingFeatures)
            .expect("FormatProperties::optimal_tiling_features: error converting flags") )
    }

    pub fn get_buffer_features<'a>(&'a self) -> Option<FormatFeatureFlags> {
        if self.set_mask & FormatPropertiesFlags::FLAG_BUFFERFEATURES != FormatPropertiesFlags::FLAG_BUFFERFEATURES { return None }
        Some( FormatFeatureFlags::from_bits(self.raw.bufferFeatures)
            .expect("FormatProperties::buffer_features: error converting flags") )
    }

    pub fn build(self) -> FormatProperties {
        FormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageFormatProperties {
    raw: vks::VkImageFormatProperties,
}

impl ImageFormatProperties {
    pub fn builder() -> ImageFormatPropertiesBuilder {
        ImageFormatPropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageFormatProperties) -> ImageFormatProperties {
        ImageFormatProperties { raw, }
    }

    pub fn max_extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.maxExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn max_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.maxExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn max_mip_levels<'a>(&'a self) -> u32 {
        self.raw.maxMipLevels.into()
    }

    pub fn max_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxArrayLayers.into()
    }

    pub fn sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampleCounts)
            .expect("ImageFormatProperties::sample_counts: error converting flags")
    }

    pub fn max_resource_size<'a>(&'a self) -> u64 {
        self.raw.maxResourceSize.into()
    }

    pub fn set_max_extent<'m>(&mut self, max_extent: Extent3d) {
        self.raw.maxExtent = max_extent.raw;
    }

    pub fn set_max_mip_levels<'m>(&mut self, max_mip_levels: u32) {
        self.raw.maxMipLevels = max_mip_levels.into();
    }

    pub fn set_max_array_layers<'m>(&mut self, max_array_layers: u32) {
        self.raw.maxArrayLayers = max_array_layers.into();
    }

    pub fn set_sample_counts<'m>(&mut self, sample_counts: SampleCountFlags) {
        self.raw.sampleCounts = sample_counts.bits();
    }

    pub fn set_max_resource_size<'m>(&mut self, max_resource_size: u64) {
        self.raw.maxResourceSize = max_resource_size.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageFormatProperties {
        &self.raw
    }
}

impl From<ImageFormatProperties> for vks::VkImageFormatProperties {
    fn from(f: ImageFormatProperties) -> vks::VkImageFormatProperties {
        f.raw
    }
}


/// Bitflags for `VkImageFormatProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageFormatPropertiesFlags: u32 {
        const FLAG_MAXEXTENT			 = 0b1;
        const FLAG_MAXMIPLEVELS			 = 0b10;
        const FLAG_MAXARRAYLAYERS			 = 0b100;
        const FLAG_SAMPLECOUNTS			 = 0b1000;
        const FLAG_MAXRESOURCESIZE			 = 0b10000;
    }
}


/// A builder for `VkImageFormatProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageFormatPropertiesBuilder {
    raw: vks::VkImageFormatProperties,
    set_mask: ImageFormatPropertiesFlags,
}

impl ImageFormatPropertiesBuilder {
    pub fn new() -> ImageFormatPropertiesBuilder {
        ImageFormatPropertiesBuilder {
            raw: vks::VkImageFormatProperties::default(),
            set_mask: ImageFormatPropertiesFlags::default(),
        }
    }

    pub fn max_extent<'m>(mut self, max_extent: Extent3d) -> ImageFormatPropertiesBuilder {
        self.raw.maxExtent = max_extent.raw;
        self.set_mask |= ImageFormatPropertiesFlags::FLAG_MAXEXTENT;
        self
    }

    pub fn max_mip_levels<'m>(mut self, max_mip_levels: u32) -> ImageFormatPropertiesBuilder {
        self.raw.maxMipLevels = max_mip_levels.into();
        self.set_mask |= ImageFormatPropertiesFlags::FLAG_MAXMIPLEVELS;
        self
    }

    pub fn max_array_layers<'m>(mut self, max_array_layers: u32) -> ImageFormatPropertiesBuilder {
        self.raw.maxArrayLayers = max_array_layers.into();
        self.set_mask |= ImageFormatPropertiesFlags::FLAG_MAXARRAYLAYERS;
        self
    }

    pub fn sample_counts<'m>(mut self, sample_counts: SampleCountFlags) -> ImageFormatPropertiesBuilder {
        self.raw.sampleCounts = sample_counts.bits();
        self.set_mask |= ImageFormatPropertiesFlags::FLAG_SAMPLECOUNTS;
        self
    }

    pub fn max_resource_size<'m>(mut self, max_resource_size: u64) -> ImageFormatPropertiesBuilder {
        self.raw.maxResourceSize = max_resource_size.into();
        self.set_mask |= ImageFormatPropertiesFlags::FLAG_MAXRESOURCESIZE;
        self
    }

    pub fn get_max_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_MAXEXTENT != ImageFormatPropertiesFlags::FLAG_MAXEXTENT { return None }
        Some(  unsafe { &*(&self.raw.maxExtent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_max_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_MAXEXTENT != ImageFormatPropertiesFlags::FLAG_MAXEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.maxExtent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn get_max_mip_levels<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_MAXMIPLEVELS != ImageFormatPropertiesFlags::FLAG_MAXMIPLEVELS { return None }
        Some( self.raw.maxMipLevels.into() )
    }

    pub fn get_max_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_MAXARRAYLAYERS != ImageFormatPropertiesFlags::FLAG_MAXARRAYLAYERS { return None }
        Some( self.raw.maxArrayLayers.into() )
    }

    pub fn get_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_SAMPLECOUNTS != ImageFormatPropertiesFlags::FLAG_SAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.sampleCounts)
            .expect("ImageFormatProperties::sample_counts: error converting flags") )
    }

    pub fn get_max_resource_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & ImageFormatPropertiesFlags::FLAG_MAXRESOURCESIZE != ImageFormatPropertiesFlags::FLAG_MAXRESOURCESIZE { return None }
        Some( self.raw.maxResourceSize.into() )
    }

    pub fn build(self) -> ImageFormatProperties {
        ImageFormatProperties {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorBufferInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorBufferInfo {
    raw: vks::VkDescriptorBufferInfo,
}

impl DescriptorBufferInfo {
    pub fn builder() -> DescriptorBufferInfoBuilder {
        DescriptorBufferInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorBufferInfo) -> DescriptorBufferInfo {
        DescriptorBufferInfo { raw, }
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_range<'m>(&mut self, range: u64) {
        self.raw.range = range.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorBufferInfo {
        &self.raw
    }
}

impl From<DescriptorBufferInfo> for vks::VkDescriptorBufferInfo {
    fn from(f: DescriptorBufferInfo) -> vks::VkDescriptorBufferInfo {
        f.raw
    }
}


/// Bitflags for `VkDescriptorBufferInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorBufferInfoFlags: u32 {
        const FLAG_BUFFER			 = 0b1;
        const FLAG_OFFSET			 = 0b10;
        const FLAG_RANGE			 = 0b100;
    }
}


/// A builder for `VkDescriptorBufferInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorBufferInfoBuilder {
    raw: vks::VkDescriptorBufferInfo,
    set_mask: DescriptorBufferInfoFlags,
}

impl DescriptorBufferInfoBuilder {
    pub fn new() -> DescriptorBufferInfoBuilder {
        DescriptorBufferInfoBuilder {
            raw: vks::VkDescriptorBufferInfo::default(),
            set_mask: DescriptorBufferInfoFlags::default(),
        }
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> DescriptorBufferInfoBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= DescriptorBufferInfoFlags::FLAG_BUFFER;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> DescriptorBufferInfoBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= DescriptorBufferInfoFlags::FLAG_OFFSET;
        self
    }

    pub fn range<'m>(mut self, range: u64) -> DescriptorBufferInfoBuilder {
        self.raw.range = range.into();
        self.set_mask |= DescriptorBufferInfoFlags::FLAG_RANGE;
        self
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & DescriptorBufferInfoFlags::FLAG_BUFFER != DescriptorBufferInfoFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & DescriptorBufferInfoFlags::FLAG_OFFSET != DescriptorBufferInfoFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_range<'a>(&'a self) -> Option<u64> {
        if self.set_mask & DescriptorBufferInfoFlags::FLAG_RANGE != DescriptorBufferInfoFlags::FLAG_RANGE { return None }
        Some( self.raw.range.into() )
    }

    pub fn build(self) -> DescriptorBufferInfo {
        DescriptorBufferInfo {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorImageInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorImageInfo {
    raw: vks::VkDescriptorImageInfo,
}

impl DescriptorImageInfo {
    pub fn builder() -> DescriptorImageInfoBuilder {
        DescriptorImageInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorImageInfo) -> DescriptorImageInfo {
        DescriptorImageInfo { raw, }
    }

    pub fn sampler<'a>(&'a self) -> vks::VkSampler {
        self.raw.sampler
    }

    pub fn image_view<'a>(&'a self) -> vks::VkImageView {
        self.raw.imageView
    }

    pub fn image_layout<'a>(&'a self) -> ImageLayout {
        self.raw.imageLayout.into()
    }

    pub fn set_sampler<'m, H>(&mut self, sampler: H)
            where H: Handle<Target=SamplerHandle> {
        self.raw.sampler = sampler.handle().0;
    }

    pub fn set_image_view<'m, H>(&mut self, image_view: H)
            where H: Handle<Target=ImageViewHandle> {
        self.raw.imageView = image_view.handle().0;
    }

    pub fn set_image_layout<'m>(&mut self, image_layout: ImageLayout) {
        self.raw.imageLayout = image_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorImageInfo {
        &self.raw
    }
}

impl From<DescriptorImageInfo> for vks::VkDescriptorImageInfo {
    fn from(f: DescriptorImageInfo) -> vks::VkDescriptorImageInfo {
        f.raw
    }
}


/// Bitflags for `VkDescriptorImageInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorImageInfoFlags: u32 {
        const FLAG_SAMPLER			 = 0b1;
        const FLAG_IMAGEVIEW			 = 0b10;
        const FLAG_IMAGELAYOUT			 = 0b100;
    }
}


/// A builder for `VkDescriptorImageInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorImageInfoBuilder {
    raw: vks::VkDescriptorImageInfo,
    set_mask: DescriptorImageInfoFlags,
}

impl DescriptorImageInfoBuilder {
    pub fn new() -> DescriptorImageInfoBuilder {
        DescriptorImageInfoBuilder {
            raw: vks::VkDescriptorImageInfo::default(),
            set_mask: DescriptorImageInfoFlags::default(),
        }
    }

    pub fn sampler<'m, H>(mut self, sampler: H) -> DescriptorImageInfoBuilder
            where H: Handle<Target=SamplerHandle> {
        self.raw.sampler = sampler.handle().0;
        self.set_mask |= DescriptorImageInfoFlags::FLAG_SAMPLER;
        self
    }

    pub fn image_view<'m, H>(mut self, image_view: H) -> DescriptorImageInfoBuilder
            where H: Handle<Target=ImageViewHandle> {
        self.raw.imageView = image_view.handle().0;
        self.set_mask |= DescriptorImageInfoFlags::FLAG_IMAGEVIEW;
        self
    }

    pub fn image_layout<'m>(mut self, image_layout: ImageLayout) -> DescriptorImageInfoBuilder {
        self.raw.imageLayout = image_layout.into();
        self.set_mask |= DescriptorImageInfoFlags::FLAG_IMAGELAYOUT;
        self
    }

    pub fn get_sampler<'a>(&'a self) -> Option<vks::VkSampler> {
        if self.set_mask & DescriptorImageInfoFlags::FLAG_SAMPLER != DescriptorImageInfoFlags::FLAG_SAMPLER { return None }
        Some( self.raw.sampler )
    }

    pub fn get_image_view<'a>(&'a self) -> Option<vks::VkImageView> {
        if self.set_mask & DescriptorImageInfoFlags::FLAG_IMAGEVIEW != DescriptorImageInfoFlags::FLAG_IMAGEVIEW { return None }
        Some( self.raw.imageView )
    }

    pub fn get_image_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & DescriptorImageInfoFlags::FLAG_IMAGELAYOUT != DescriptorImageInfoFlags::FLAG_IMAGELAYOUT { return None }
        Some( self.raw.imageLayout.into() )
    }

    pub fn build(self) -> DescriptorImageInfo {
        DescriptorImageInfo {
            raw: self.raw,
        }
    }
}


/// A `VkWriteDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct WriteDescriptorSet<'s> {
    raw: vks::VkWriteDescriptorSet,
    _p: PhantomData<&'s ()>,
}

impl<'s> WriteDescriptorSet<'s> {
    pub fn builder<'b>() -> WriteDescriptorSetBuilder<'b> {
        WriteDescriptorSetBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWriteDescriptorSet) -> WriteDescriptorSet<'s> {
        WriteDescriptorSet { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn image_info<'a>(&'a self) -> &'a DescriptorImageInfo {
        unsafe { &*(self.raw.pImageInfo as *const vks::VkDescriptorImageInfo as *const _) }
    }

    pub fn buffer_info<'a>(&'a self) -> &'a DescriptorBufferInfo {
        unsafe { &*(self.raw.pBufferInfo as *const vks::VkDescriptorBufferInfo as *const _) }
    }

    pub fn texel_buffer_view<'a>(&'a self) -> &'a vks::VkBufferView {
        unsafe { &*(self.raw.pTexelBufferView as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dst_set<'m, H>(&mut self, dst_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_image_info<'m, 'a>(&mut self, image_info: &'a DescriptorImageInfo)
            where 'a: 's {
        self.raw.pImageInfo = image_info.as_raw();
    }

    pub fn set_buffer_info<'m, 'a>(&mut self, buffer_info: &'a DescriptorBufferInfo)
            where 'a: 's {
        self.raw.pBufferInfo = buffer_info.as_raw();
    }

    pub fn set_texel_buffer_view<'m, 'a, H>(&mut self, texel_buffer_view: &'a H)
            where H: Handle<Target=BufferViewHandle> {
        self.raw.pTexelBufferView = &texel_buffer_view.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkWriteDescriptorSet {
        &self.raw
    }
}

impl<'s> From<WriteDescriptorSet<'s>> for vks::VkWriteDescriptorSet {
    fn from(f: WriteDescriptorSet<'s>) -> vks::VkWriteDescriptorSet {
        f.raw
    }
}


/// Bitflags for `VkWriteDescriptorSet`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct WriteDescriptorSetFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DSTSET			 = 0b100;
        const FLAG_DSTBINDING			 = 0b1000;
        const FLAG_DSTARRAYELEMENT			 = 0b10000;
        const FLAG_DESCRIPTORCOUNT			 = 0b100000;
        const FLAG_DESCRIPTORTYPE			 = 0b1000000;
        const FLAG_PIMAGEINFO			 = 0b10000000;
        const FLAG_PBUFFERINFO			 = 0b100000000;
        const FLAG_PTEXELBUFFERVIEW			 = 0b1000000000;
    }
}


/// A builder for `VkWriteDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct WriteDescriptorSetBuilder<'b> {
    raw: vks::VkWriteDescriptorSet,
    _p: PhantomData<&'b ()>, 
    set_mask: WriteDescriptorSetFlags,
}

impl<'b> WriteDescriptorSetBuilder<'b> {
    pub fn new() -> WriteDescriptorSetBuilder<'b> {
        WriteDescriptorSetBuilder {
            raw: vks::VkWriteDescriptorSet::default(),
            _p: PhantomData,
            set_mask: WriteDescriptorSetFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> WriteDescriptorSetBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= WriteDescriptorSetFlags::FLAG_PNEXT;
        self
    }

    pub fn dst_set<'m, H>(mut self, dst_set: H) -> WriteDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
        self.set_mask |= WriteDescriptorSetFlags::FLAG_DSTSET;
        self
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.dstBinding = dst_binding.into();
        self.set_mask |= WriteDescriptorSetFlags::FLAG_DSTBINDING;
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.dstArrayElement = dst_array_element.into();
        self.set_mask |= WriteDescriptorSetFlags::FLAG_DSTARRAYELEMENT;
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> WriteDescriptorSetBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self.set_mask |= WriteDescriptorSetFlags::FLAG_DESCRIPTORCOUNT;
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> WriteDescriptorSetBuilder<'b> {
        self.raw.descriptorType = descriptor_type.into();
        self.set_mask |= WriteDescriptorSetFlags::FLAG_DESCRIPTORTYPE;
        self
    }

    pub fn image_info<'m, 'a>(mut self, image_info: &'a DescriptorImageInfo) -> WriteDescriptorSetBuilder<'b>
            where 'a: 'b {
        self.raw.pImageInfo = image_info.as_raw();
        self
    }

    pub fn buffer_info<'m, 'a>(mut self, buffer_info: &'a DescriptorBufferInfo) -> WriteDescriptorSetBuilder<'b>
            where 'a: 'b {
        self.raw.pBufferInfo = buffer_info.as_raw();
        self
    }

    pub fn texel_buffer_view<'m, 'a, H>(mut self, texel_buffer_view: &'a H) -> WriteDescriptorSetBuilder<'b>
            where H: Handle<Target=BufferViewHandle> {
        self.raw.pTexelBufferView = &texel_buffer_view.handle().0;
        self.set_mask |= WriteDescriptorSetFlags::FLAG_PTEXELBUFFERVIEW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_PNEXT != WriteDescriptorSetFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_dst_set<'a>(&'a self) -> Option<vks::VkDescriptorSet> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_DSTSET != WriteDescriptorSetFlags::FLAG_DSTSET { return None }
        Some( self.raw.dstSet )
    }

    pub fn get_dst_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_DSTBINDING != WriteDescriptorSetFlags::FLAG_DSTBINDING { return None }
        Some( self.raw.dstBinding.into() )
    }

    pub fn get_dst_array_element<'a>(&'a self) -> Option<u32> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_DSTARRAYELEMENT != WriteDescriptorSetFlags::FLAG_DSTARRAYELEMENT { return None }
        Some( self.raw.dstArrayElement.into() )
    }

    pub fn get_descriptor_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_DESCRIPTORCOUNT != WriteDescriptorSetFlags::FLAG_DESCRIPTORCOUNT { return None }
        Some( self.raw.descriptorCount.into() )
    }

    pub fn get_descriptor_type<'a>(&'a self) -> Option<DescriptorType> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_DESCRIPTORTYPE != WriteDescriptorSetFlags::FLAG_DESCRIPTORTYPE { return None }
        Some( self.raw.descriptorType.into() )
    }

    pub fn get_image_info<'a>(&'a self) -> Option<&'a DescriptorImageInfo> {
        if self.raw.pImageInfo.is_null() { return None }
        Some( unsafe { &*(self.raw.pImageInfo as *const vks::VkDescriptorImageInfo as *const _) } )
    }

    pub fn get_buffer_info<'a>(&'a self) -> Option<&'a DescriptorBufferInfo> {
        if self.raw.pBufferInfo.is_null() { return None }
        Some( unsafe { &*(self.raw.pBufferInfo as *const vks::VkDescriptorBufferInfo as *const _) } )
    }

    pub fn get_texel_buffer_view<'a>(&'a self) -> Option<&'a vks::VkBufferView> {
        if self.set_mask & WriteDescriptorSetFlags::FLAG_PTEXELBUFFERVIEW != WriteDescriptorSetFlags::FLAG_PTEXELBUFFERVIEW { return None }
        Some( unsafe { &*(self.raw.pTexelBufferView as *const _) } )
    }

    pub fn build(self) -> WriteDescriptorSet<'b> {
        WriteDescriptorSet {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCopyDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CopyDescriptorSet<'s> {
    raw: vks::VkCopyDescriptorSet,
    _p: PhantomData<&'s ()>,
}

impl<'s> CopyDescriptorSet<'s> {
    pub fn builder<'b>() -> CopyDescriptorSetBuilder<'b> {
        CopyDescriptorSetBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCopyDescriptorSet) -> CopyDescriptorSet<'s> {
        CopyDescriptorSet { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.srcSet
    }

    pub fn src_binding<'a>(&'a self) -> u32 {
        self.raw.srcBinding.into()
    }

    pub fn src_array_element<'a>(&'a self) -> u32 {
        self.raw.srcArrayElement.into()
    }

    pub fn dst_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.dstSet
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_set<'m, H>(&mut self, src_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.srcSet = src_set.handle().0;
    }

    pub fn set_src_binding<'m>(&mut self, src_binding: u32) {
        self.raw.srcBinding = src_binding.into();
    }

    pub fn set_src_array_element<'m>(&mut self, src_array_element: u32) {
        self.raw.srcArrayElement = src_array_element.into();
    }

    pub fn set_dst_set<'m, H>(&mut self, dst_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCopyDescriptorSet {
        &self.raw
    }
}

impl<'s> From<CopyDescriptorSet<'s>> for vks::VkCopyDescriptorSet {
    fn from(f: CopyDescriptorSet<'s>) -> vks::VkCopyDescriptorSet {
        f.raw
    }
}


/// Bitflags for `VkCopyDescriptorSet`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CopyDescriptorSetFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCSET			 = 0b100;
        const FLAG_SRCBINDING			 = 0b1000;
        const FLAG_SRCARRAYELEMENT			 = 0b10000;
        const FLAG_DSTSET			 = 0b100000;
        const FLAG_DSTBINDING			 = 0b1000000;
        const FLAG_DSTARRAYELEMENT			 = 0b10000000;
        const FLAG_DESCRIPTORCOUNT			 = 0b100000000;
    }
}


/// A builder for `VkCopyDescriptorSet`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CopyDescriptorSetBuilder<'b> {
    raw: vks::VkCopyDescriptorSet,
    _p: PhantomData<&'b ()>, 
    set_mask: CopyDescriptorSetFlags,
}

impl<'b> CopyDescriptorSetBuilder<'b> {
    pub fn new() -> CopyDescriptorSetBuilder<'b> {
        CopyDescriptorSetBuilder {
            raw: vks::VkCopyDescriptorSet::default(),
            _p: PhantomData,
            set_mask: CopyDescriptorSetFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CopyDescriptorSetBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CopyDescriptorSetFlags::FLAG_PNEXT;
        self
    }

    pub fn src_set<'m, H>(mut self, src_set: H) -> CopyDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.srcSet = src_set.handle().0;
        self.set_mask |= CopyDescriptorSetFlags::FLAG_SRCSET;
        self
    }

    pub fn src_binding<'m>(mut self, src_binding: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.srcBinding = src_binding.into();
        self.set_mask |= CopyDescriptorSetFlags::FLAG_SRCBINDING;
        self
    }

    pub fn src_array_element<'m>(mut self, src_array_element: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.srcArrayElement = src_array_element.into();
        self.set_mask |= CopyDescriptorSetFlags::FLAG_SRCARRAYELEMENT;
        self
    }

    pub fn dst_set<'m, H>(mut self, dst_set: H) -> CopyDescriptorSetBuilder<'b>
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.dstSet = dst_set.handle().0;
        self.set_mask |= CopyDescriptorSetFlags::FLAG_DSTSET;
        self
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.dstBinding = dst_binding.into();
        self.set_mask |= CopyDescriptorSetFlags::FLAG_DSTBINDING;
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.dstArrayElement = dst_array_element.into();
        self.set_mask |= CopyDescriptorSetFlags::FLAG_DSTARRAYELEMENT;
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> CopyDescriptorSetBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self.set_mask |= CopyDescriptorSetFlags::FLAG_DESCRIPTORCOUNT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_PNEXT != CopyDescriptorSetFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_set<'a>(&'a self) -> Option<vks::VkDescriptorSet> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_SRCSET != CopyDescriptorSetFlags::FLAG_SRCSET { return None }
        Some( self.raw.srcSet )
    }

    pub fn get_src_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_SRCBINDING != CopyDescriptorSetFlags::FLAG_SRCBINDING { return None }
        Some( self.raw.srcBinding.into() )
    }

    pub fn get_src_array_element<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_SRCARRAYELEMENT != CopyDescriptorSetFlags::FLAG_SRCARRAYELEMENT { return None }
        Some( self.raw.srcArrayElement.into() )
    }

    pub fn get_dst_set<'a>(&'a self) -> Option<vks::VkDescriptorSet> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_DSTSET != CopyDescriptorSetFlags::FLAG_DSTSET { return None }
        Some( self.raw.dstSet )
    }

    pub fn get_dst_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_DSTBINDING != CopyDescriptorSetFlags::FLAG_DSTBINDING { return None }
        Some( self.raw.dstBinding.into() )
    }

    pub fn get_dst_array_element<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_DSTARRAYELEMENT != CopyDescriptorSetFlags::FLAG_DSTARRAYELEMENT { return None }
        Some( self.raw.dstArrayElement.into() )
    }

    pub fn get_descriptor_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CopyDescriptorSetFlags::FLAG_DESCRIPTORCOUNT != CopyDescriptorSetFlags::FLAG_DESCRIPTORCOUNT { return None }
        Some( self.raw.descriptorCount.into() )
    }

    pub fn build(self) -> CopyDescriptorSet<'b> {
        CopyDescriptorSet {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferCreateInfo<'s> {
    raw: vks::VkBufferCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferCreateInfo<'s> {
    pub fn builder<'b>() -> BufferCreateInfoBuilder<'b> {
        BufferCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferCreateInfo) -> BufferCreateInfo<'s> {
        BufferCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("BufferCreateInfo::flags: error converting flags")
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("BufferCreateInfo::usage: error converting flags")
    }

    pub fn sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_usage<'m>(&mut self, usage: BufferUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_sharing_mode<'m>(&mut self, sharing_mode: SharingMode) {
        self.raw.sharingMode = sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `BufferCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkBufferCreateInfo {
        &self.raw
    }
}

impl<'s> From<BufferCreateInfo<'s>> for vks::VkBufferCreateInfo {
    fn from(f: BufferCreateInfo<'s>) -> vks::VkBufferCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkBufferCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_SIZE			 = 0b1000;
        const FLAG_USAGE			 = 0b10000;
        const FLAG_SHARINGMODE			 = 0b100000;
        const FLAG_QUEUEFAMILYINDEXCOUNT			 = 0b1000000;
        const FLAG_PQUEUEFAMILYINDICES			 = 0b10000000;
    }
}


/// A builder for `VkBufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferCreateInfoBuilder<'b> {
    raw: vks::VkBufferCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: BufferCreateInfoFlags,
}

impl<'b> BufferCreateInfoBuilder<'b> {
    pub fn new() -> BufferCreateInfoBuilder<'b> {
        BufferCreateInfoBuilder {
            raw: vks::VkBufferCreateInfo::default(),
            _p: PhantomData,
            set_mask: BufferCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BufferCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferCreateFlags) -> BufferCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= BufferCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferCreateInfoBuilder<'b> {
        self.raw.size = size.into();
        self.set_mask |= BufferCreateInfoFlags::FLAG_SIZE;
        self
    }

    pub fn usage<'m>(mut self, usage: BufferUsageFlags) -> BufferCreateInfoBuilder<'b> {
        self.raw.usage = usage.bits();
        self.set_mask |= BufferCreateInfoFlags::FLAG_USAGE;
        self
    }

    pub fn sharing_mode<'m>(mut self, sharing_mode: SharingMode) -> BufferCreateInfoBuilder<'b> {
        self.raw.sharingMode = sharing_mode.into();
        self.set_mask |= BufferCreateInfoFlags::FLAG_SHARINGMODE;
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> BufferCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `BufferCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.set_mask |= BufferCreateInfoFlags::FLAG_QUEUEFAMILYINDEXCOUNT;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= BufferCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_PNEXT != BufferCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<BufferCreateFlags> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_FLAGS != BufferCreateInfoFlags::FLAG_FLAGS { return None }
        Some( BufferCreateFlags::from_bits(self.raw.flags)
            .expect("BufferCreateInfo::flags: error converting flags") )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_SIZE != BufferCreateInfoFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn get_usage<'a>(&'a self) -> Option<BufferUsageFlags> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_USAGE != BufferCreateInfoFlags::FLAG_USAGE { return None }
        Some( BufferUsageFlags::from_bits(self.raw.usage)
            .expect("BufferCreateInfo::usage: error converting flags") )
    }

    pub fn get_sharing_mode<'a>(&'a self) -> Option<SharingMode> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_SHARINGMODE != BufferCreateInfoFlags::FLAG_SHARINGMODE { return None }
        Some( self.raw.sharingMode.into() )
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & BufferCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES != BufferCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) } )
    }

    pub fn build(self) -> BufferCreateInfo<'b> {
        BufferCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferViewCreateInfo<'s> {
    raw: vks::VkBufferViewCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferViewCreateInfo<'s> {
    pub fn builder<'b>() -> BufferViewCreateInfoBuilder<'b> {
        BufferViewCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferViewCreateInfo) -> BufferViewCreateInfo<'s> {
        BufferViewCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferViewCreateFlags {
        BufferViewCreateFlags::from_bits(self.raw.flags)
            .expect("BufferViewCreateInfo::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn range<'a>(&'a self) -> u64 {
        self.raw.range.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferViewCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_range<'m>(&mut self, range: u64) {
        self.raw.range = range.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferViewCreateInfo {
        &self.raw
    }
}

impl<'s> From<BufferViewCreateInfo<'s>> for vks::VkBufferViewCreateInfo {
    fn from(f: BufferViewCreateInfo<'s>) -> vks::VkBufferViewCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkBufferViewCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferViewCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_BUFFER			 = 0b1000;
        const FLAG_FORMAT			 = 0b10000;
        const FLAG_OFFSET			 = 0b100000;
        const FLAG_RANGE			 = 0b1000000;
    }
}


/// A builder for `VkBufferViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferViewCreateInfoBuilder<'b> {
    raw: vks::VkBufferViewCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: BufferViewCreateInfoFlags,
}

impl<'b> BufferViewCreateInfoBuilder<'b> {
    pub fn new() -> BufferViewCreateInfoBuilder<'b> {
        BufferViewCreateInfoBuilder {
            raw: vks::VkBufferViewCreateInfo::default(),
            _p: PhantomData,
            set_mask: BufferViewCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferViewCreateFlags) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferViewCreateInfoBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_BUFFER;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_FORMAT;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.offset = offset.into();
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_OFFSET;
        self
    }

    pub fn range<'m>(mut self, range: u64) -> BufferViewCreateInfoBuilder<'b> {
        self.raw.range = range.into();
        self.set_mask |= BufferViewCreateInfoFlags::FLAG_RANGE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_PNEXT != BufferViewCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<BufferViewCreateFlags> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_FLAGS != BufferViewCreateInfoFlags::FLAG_FLAGS { return None }
        Some( BufferViewCreateFlags::from_bits(self.raw.flags)
            .expect("BufferViewCreateInfo::flags: error converting flags") )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_BUFFER != BufferViewCreateInfoFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_FORMAT != BufferViewCreateInfoFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_OFFSET != BufferViewCreateInfoFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_range<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferViewCreateInfoFlags::FLAG_RANGE != BufferViewCreateInfoFlags::FLAG_RANGE { return None }
        Some( self.raw.range.into() )
    }

    pub fn build(self) -> BufferViewCreateInfo<'b> {
        BufferViewCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSubresource`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresource {
    raw: vks::VkImageSubresource,
}

impl ImageSubresource {
    pub fn builder() -> ImageSubresourceBuilder {
        ImageSubresourceBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresource) -> ImageSubresource {
        ImageSubresource { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresource::aspect_mask: error converting flags")
    }

    pub fn mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn array_layer<'a>(&'a self) -> u32 {
        self.raw.arrayLayer.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_mip_level<'m>(&mut self, mip_level: u32) {
        self.raw.mipLevel = mip_level.into();
    }

    pub fn set_array_layer<'m>(&mut self, array_layer: u32) {
        self.raw.arrayLayer = array_layer.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresource {
        &self.raw
    }
}

impl From<ImageSubresource> for vks::VkImageSubresource {
    fn from(f: ImageSubresource) -> vks::VkImageSubresource {
        f.raw
    }
}


/// Bitflags for `VkImageSubresource`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageSubresourceFlags: u32 {
        const FLAG_ASPECTMASK			 = 0b1;
        const FLAG_MIPLEVEL			 = 0b10;
        const FLAG_ARRAYLAYER			 = 0b100;
    }
}


/// A builder for `VkImageSubresource`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceBuilder {
    raw: vks::VkImageSubresource,
    set_mask: ImageSubresourceFlags,
}

impl ImageSubresourceBuilder {
    pub fn new() -> ImageSubresourceBuilder {
        ImageSubresourceBuilder {
            raw: vks::VkImageSubresource::default(),
            set_mask: ImageSubresourceFlags::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self.set_mask |= ImageSubresourceFlags::FLAG_ASPECTMASK;
        self
    }

    pub fn mip_level<'m>(mut self, mip_level: u32) -> ImageSubresourceBuilder {
        self.raw.mipLevel = mip_level.into();
        self.set_mask |= ImageSubresourceFlags::FLAG_MIPLEVEL;
        self
    }

    pub fn array_layer<'m>(mut self, array_layer: u32) -> ImageSubresourceBuilder {
        self.raw.arrayLayer = array_layer.into();
        self.set_mask |= ImageSubresourceFlags::FLAG_ARRAYLAYER;
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> Option<ImageAspectFlags> {
        if self.set_mask & ImageSubresourceFlags::FLAG_ASPECTMASK != ImageSubresourceFlags::FLAG_ASPECTMASK { return None }
        Some( ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresource::aspect_mask: error converting flags") )
    }

    pub fn get_mip_level<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceFlags::FLAG_MIPLEVEL != ImageSubresourceFlags::FLAG_MIPLEVEL { return None }
        Some( self.raw.mipLevel.into() )
    }

    pub fn get_array_layer<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceFlags::FLAG_ARRAYLAYER != ImageSubresourceFlags::FLAG_ARRAYLAYER { return None }
        Some( self.raw.arrayLayer.into() )
    }

    pub fn build(self) -> ImageSubresource {
        ImageSubresource {
            raw: self.raw,
        }
    }
}


/// A `VkImageSubresourceLayers`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresourceLayers {
    raw: vks::VkImageSubresourceLayers,
}

impl ImageSubresourceLayers {
    pub fn builder() -> ImageSubresourceLayersBuilder {
        ImageSubresourceLayersBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresourceLayers) -> ImageSubresourceLayers {
        ImageSubresourceLayers { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceLayers::aspect_mask: error converting flags")
    }

    pub fn mip_level<'a>(&'a self) -> u32 {
        self.raw.mipLevel.into()
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_mip_level<'m>(&mut self, mip_level: u32) {
        self.raw.mipLevel = mip_level.into();
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresourceLayers {
        &self.raw
    }
}

impl From<ImageSubresourceLayers> for vks::VkImageSubresourceLayers {
    fn from(f: ImageSubresourceLayers) -> vks::VkImageSubresourceLayers {
        f.raw
    }
}


/// Bitflags for `VkImageSubresourceLayers`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageSubresourceLayersFlags: u32 {
        const FLAG_ASPECTMASK			 = 0b1;
        const FLAG_MIPLEVEL			 = 0b10;
        const FLAG_BASEARRAYLAYER			 = 0b100;
        const FLAG_LAYERCOUNT			 = 0b1000;
    }
}


/// A builder for `VkImageSubresourceLayers`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceLayersBuilder {
    raw: vks::VkImageSubresourceLayers,
    set_mask: ImageSubresourceLayersFlags,
}

impl ImageSubresourceLayersBuilder {
    pub fn new() -> ImageSubresourceLayersBuilder {
        ImageSubresourceLayersBuilder {
            raw: vks::VkImageSubresourceLayers::default(),
            set_mask: ImageSubresourceLayersFlags::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceLayersBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self.set_mask |= ImageSubresourceLayersFlags::FLAG_ASPECTMASK;
        self
    }

    pub fn mip_level<'m>(mut self, mip_level: u32) -> ImageSubresourceLayersBuilder {
        self.raw.mipLevel = mip_level.into();
        self.set_mask |= ImageSubresourceLayersFlags::FLAG_MIPLEVEL;
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ImageSubresourceLayersBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self.set_mask |= ImageSubresourceLayersFlags::FLAG_BASEARRAYLAYER;
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ImageSubresourceLayersBuilder {
        self.raw.layerCount = layer_count.into();
        self.set_mask |= ImageSubresourceLayersFlags::FLAG_LAYERCOUNT;
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> Option<ImageAspectFlags> {
        if self.set_mask & ImageSubresourceLayersFlags::FLAG_ASPECTMASK != ImageSubresourceLayersFlags::FLAG_ASPECTMASK { return None }
        Some( ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceLayers::aspect_mask: error converting flags") )
    }

    pub fn get_mip_level<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceLayersFlags::FLAG_MIPLEVEL != ImageSubresourceLayersFlags::FLAG_MIPLEVEL { return None }
        Some( self.raw.mipLevel.into() )
    }

    pub fn get_base_array_layer<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceLayersFlags::FLAG_BASEARRAYLAYER != ImageSubresourceLayersFlags::FLAG_BASEARRAYLAYER { return None }
        Some( self.raw.baseArrayLayer.into() )
    }

    pub fn get_layer_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceLayersFlags::FLAG_LAYERCOUNT != ImageSubresourceLayersFlags::FLAG_LAYERCOUNT { return None }
        Some( self.raw.layerCount.into() )
    }

    pub fn build(self) -> ImageSubresourceLayers {
        ImageSubresourceLayers {
            raw: self.raw,
        }
    }
}


/// A `VkImageSubresourceRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSubresourceRange {
    raw: vks::VkImageSubresourceRange,
}

impl ImageSubresourceRange {
    pub fn builder() -> ImageSubresourceRangeBuilder {
        ImageSubresourceRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSubresourceRange) -> ImageSubresourceRange {
        ImageSubresourceRange { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceRange::aspect_mask: error converting flags")
    }

    pub fn base_mip_level<'a>(&'a self) -> u32 {
        self.raw.baseMipLevel.into()
    }

    pub fn level_count<'a>(&'a self) -> u32 {
        self.raw.levelCount.into()
    }

    pub fn base_array_layer<'a>(&'a self) -> u32 {
        self.raw.baseArrayLayer.into()
    }

    pub fn layer_count<'a>(&'a self) -> u32 {
        self.raw.layerCount.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_base_mip_level<'m>(&mut self, base_mip_level: u32) {
        self.raw.baseMipLevel = base_mip_level.into();
    }

    pub fn set_level_count<'m>(&mut self, level_count: u32) {
        self.raw.levelCount = level_count.into();
    }

    pub fn set_base_array_layer<'m>(&mut self, base_array_layer: u32) {
        self.raw.baseArrayLayer = base_array_layer.into();
    }

    pub fn set_layer_count<'m>(&mut self, layer_count: u32) {
        self.raw.layerCount = layer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageSubresourceRange {
        &self.raw
    }
}

impl From<ImageSubresourceRange> for vks::VkImageSubresourceRange {
    fn from(f: ImageSubresourceRange) -> vks::VkImageSubresourceRange {
        f.raw
    }
}


/// Bitflags for `VkImageSubresourceRange`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageSubresourceRangeFlags: u32 {
        const FLAG_ASPECTMASK			 = 0b1;
        const FLAG_BASEMIPLEVEL			 = 0b10;
        const FLAG_LEVELCOUNT			 = 0b100;
        const FLAG_BASEARRAYLAYER			 = 0b1000;
        const FLAG_LAYERCOUNT			 = 0b10000;
    }
}


/// A builder for `VkImageSubresourceRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSubresourceRangeBuilder {
    raw: vks::VkImageSubresourceRange,
    set_mask: ImageSubresourceRangeFlags,
}

impl ImageSubresourceRangeBuilder {
    pub fn new() -> ImageSubresourceRangeBuilder {
        ImageSubresourceRangeBuilder {
            raw: vks::VkImageSubresourceRange::default(),
            set_mask: ImageSubresourceRangeFlags::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ImageSubresourceRangeBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self.set_mask |= ImageSubresourceRangeFlags::FLAG_ASPECTMASK;
        self
    }

    pub fn base_mip_level<'m>(mut self, base_mip_level: u32) -> ImageSubresourceRangeBuilder {
        self.raw.baseMipLevel = base_mip_level.into();
        self.set_mask |= ImageSubresourceRangeFlags::FLAG_BASEMIPLEVEL;
        self
    }

    pub fn level_count<'m>(mut self, level_count: u32) -> ImageSubresourceRangeBuilder {
        self.raw.levelCount = level_count.into();
        self.set_mask |= ImageSubresourceRangeFlags::FLAG_LEVELCOUNT;
        self
    }

    pub fn base_array_layer<'m>(mut self, base_array_layer: u32) -> ImageSubresourceRangeBuilder {
        self.raw.baseArrayLayer = base_array_layer.into();
        self.set_mask |= ImageSubresourceRangeFlags::FLAG_BASEARRAYLAYER;
        self
    }

    pub fn layer_count<'m>(mut self, layer_count: u32) -> ImageSubresourceRangeBuilder {
        self.raw.layerCount = layer_count.into();
        self.set_mask |= ImageSubresourceRangeFlags::FLAG_LAYERCOUNT;
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> Option<ImageAspectFlags> {
        if self.set_mask & ImageSubresourceRangeFlags::FLAG_ASPECTMASK != ImageSubresourceRangeFlags::FLAG_ASPECTMASK { return None }
        Some( ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ImageSubresourceRange::aspect_mask: error converting flags") )
    }

    pub fn get_base_mip_level<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceRangeFlags::FLAG_BASEMIPLEVEL != ImageSubresourceRangeFlags::FLAG_BASEMIPLEVEL { return None }
        Some( self.raw.baseMipLevel.into() )
    }

    pub fn get_level_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceRangeFlags::FLAG_LEVELCOUNT != ImageSubresourceRangeFlags::FLAG_LEVELCOUNT { return None }
        Some( self.raw.levelCount.into() )
    }

    pub fn get_base_array_layer<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceRangeFlags::FLAG_BASEARRAYLAYER != ImageSubresourceRangeFlags::FLAG_BASEARRAYLAYER { return None }
        Some( self.raw.baseArrayLayer.into() )
    }

    pub fn get_layer_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageSubresourceRangeFlags::FLAG_LAYERCOUNT != ImageSubresourceRangeFlags::FLAG_LAYERCOUNT { return None }
        Some( self.raw.layerCount.into() )
    }

    pub fn build(self) -> ImageSubresourceRange {
        ImageSubresourceRange {
            raw: self.raw,
        }
    }
}


/// A `VkMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryBarrier<'s> {
    raw: vks::VkMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryBarrier<'s> {
    pub fn builder<'b>() -> MemoryBarrierBuilder<'b> {
        MemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryBarrier) -> MemoryBarrier<'s> {
        MemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("MemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("MemoryBarrier::dst_access_mask: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<MemoryBarrier<'s>> for vks::VkMemoryBarrier {
    fn from(f: MemoryBarrier<'s>) -> vks::VkMemoryBarrier {
        f.raw
    }
}


/// Bitflags for `VkMemoryBarrier`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryBarrierFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCACCESSMASK			 = 0b100;
        const FLAG_DSTACCESSMASK			 = 0b1000;
    }
}


/// A builder for `VkMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryBarrierBuilder<'b> {
    raw: vks::VkMemoryBarrier,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryBarrierFlags,
}

impl<'b> MemoryBarrierBuilder<'b> {
    pub fn new() -> MemoryBarrierBuilder<'b> {
        MemoryBarrierBuilder {
            raw: vks::VkMemoryBarrier::default(),
            _p: PhantomData,
            set_mask: MemoryBarrierFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryBarrierFlags::FLAG_PNEXT;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> MemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self.set_mask |= MemoryBarrierFlags::FLAG_SRCACCESSMASK;
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> MemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self.set_mask |= MemoryBarrierFlags::FLAG_DSTACCESSMASK;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryBarrierFlags::FLAG_PNEXT != MemoryBarrierFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & MemoryBarrierFlags::FLAG_SRCACCESSMASK != MemoryBarrierFlags::FLAG_SRCACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("MemoryBarrier::src_access_mask: error converting flags") )
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & MemoryBarrierFlags::FLAG_DSTACCESSMASK != MemoryBarrierFlags::FLAG_DSTACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("MemoryBarrier::dst_access_mask: error converting flags") )
    }

    pub fn build(self) -> MemoryBarrier<'b> {
        MemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferMemoryBarrier<'s> {
    raw: vks::VkBufferMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferMemoryBarrier<'s> {
    pub fn builder<'b>() -> BufferMemoryBarrierBuilder<'b> {
        BufferMemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferMemoryBarrier) -> BufferMemoryBarrier<'s> {
        BufferMemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("BufferMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("BufferMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_src_queue_family_index<'m>(&mut self, src_queue_family_index: u32) {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
    }

    pub fn set_dst_queue_family_index<'m>(&mut self, dst_queue_family_index: u32) {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<BufferMemoryBarrier<'s>> for vks::VkBufferMemoryBarrier {
    fn from(f: BufferMemoryBarrier<'s>) -> vks::VkBufferMemoryBarrier {
        f.raw
    }
}


/// Bitflags for `VkBufferMemoryBarrier`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferMemoryBarrierFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCACCESSMASK			 = 0b100;
        const FLAG_DSTACCESSMASK			 = 0b1000;
        const FLAG_SRCQUEUEFAMILYINDEX			 = 0b10000;
        const FLAG_DSTQUEUEFAMILYINDEX			 = 0b100000;
        const FLAG_BUFFER			 = 0b1000000;
        const FLAG_OFFSET			 = 0b10000000;
        const FLAG_SIZE			 = 0b100000000;
    }
}


/// A builder for `VkBufferMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferMemoryBarrierBuilder<'b> {
    raw: vks::VkBufferMemoryBarrier,
    _p: PhantomData<&'b ()>, 
    set_mask: BufferMemoryBarrierFlags,
}

impl<'b> BufferMemoryBarrierBuilder<'b> {
    pub fn new() -> BufferMemoryBarrierBuilder<'b> {
        BufferMemoryBarrierBuilder {
            raw: vks::VkBufferMemoryBarrier::default(),
            _p: PhantomData,
            set_mask: BufferMemoryBarrierFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_PNEXT;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_SRCACCESSMASK;
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_DSTACCESSMASK;
        self
    }

    pub fn src_queue_family_index<'m>(mut self, src_queue_family_index: u32) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX;
        self
    }

    pub fn dst_queue_family_index<'m>(mut self, dst_queue_family_index: u32) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferMemoryBarrierBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_BUFFER;
        self
    }

    pub fn offset<'m>(mut self, offset: u64) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.offset = offset.into();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_OFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferMemoryBarrierBuilder<'b> {
        self.raw.size = size.into();
        self.set_mask |= BufferMemoryBarrierFlags::FLAG_SIZE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_PNEXT != BufferMemoryBarrierFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_SRCACCESSMASK != BufferMemoryBarrierFlags::FLAG_SRCACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("BufferMemoryBarrier::src_access_mask: error converting flags") )
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_DSTACCESSMASK != BufferMemoryBarrierFlags::FLAG_DSTACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("BufferMemoryBarrier::dst_access_mask: error converting flags") )
    }

    pub fn get_src_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX != BufferMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX { return None }
        Some( self.raw.srcQueueFamilyIndex.into() )
    }

    pub fn get_dst_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX != BufferMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX { return None }
        Some( self.raw.dstQueueFamilyIndex.into() )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_BUFFER != BufferMemoryBarrierFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_OFFSET != BufferMemoryBarrierFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferMemoryBarrierFlags::FLAG_SIZE != BufferMemoryBarrierFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn build(self) -> BufferMemoryBarrier<'b> {
        BufferMemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageMemoryBarrier<'s> {
    raw: vks::VkImageMemoryBarrier,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageMemoryBarrier<'s> {
    pub fn builder<'b>() -> ImageMemoryBarrierBuilder<'b> {
        ImageMemoryBarrierBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageMemoryBarrier) -> ImageMemoryBarrier<'s> {
        ImageMemoryBarrier { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("ImageMemoryBarrier::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("ImageMemoryBarrier::dst_access_mask: error converting flags")
    }

    pub fn old_layout<'a>(&'a self) -> ImageLayout {
        self.raw.oldLayout.into()
    }

    pub fn new_layout<'a>(&'a self) -> ImageLayout {
        self.raw.newLayout.into()
    }

    pub fn src_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.srcQueueFamilyIndex.into()
    }

    pub fn dst_queue_family_index<'a>(&'a self) -> u32 {
        self.raw.dstQueueFamilyIndex.into()
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
         unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_old_layout<'m>(&mut self, old_layout: ImageLayout) {
        self.raw.oldLayout = old_layout.into();
    }

    pub fn set_new_layout<'m>(&mut self, new_layout: ImageLayout) {
        self.raw.newLayout = new_layout.into();
    }

    pub fn set_src_queue_family_index<'m>(&mut self, src_queue_family_index: u32) {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
    }

    pub fn set_dst_queue_family_index<'m>(&mut self, dst_queue_family_index: u32) {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_subresource_range<'m>(&mut self, subresource_range: ImageSubresourceRange) {
        self.raw.subresourceRange = subresource_range.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageMemoryBarrier {
        &self.raw
    }
}

impl<'s> From<ImageMemoryBarrier<'s>> for vks::VkImageMemoryBarrier {
    fn from(f: ImageMemoryBarrier<'s>) -> vks::VkImageMemoryBarrier {
        f.raw
    }
}


/// Bitflags for `VkImageMemoryBarrier`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageMemoryBarrierFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCACCESSMASK			 = 0b100;
        const FLAG_DSTACCESSMASK			 = 0b1000;
        const FLAG_OLDLAYOUT			 = 0b10000;
        const FLAG_NEWLAYOUT			 = 0b100000;
        const FLAG_SRCQUEUEFAMILYINDEX			 = 0b1000000;
        const FLAG_DSTQUEUEFAMILYINDEX			 = 0b10000000;
        const FLAG_IMAGE			 = 0b100000000;
        const FLAG_SUBRESOURCERANGE			 = 0b1000000000;
    }
}


/// A builder for `VkImageMemoryBarrier`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageMemoryBarrierBuilder<'b> {
    raw: vks::VkImageMemoryBarrier,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageMemoryBarrierFlags,
}

impl<'b> ImageMemoryBarrierBuilder<'b> {
    pub fn new() -> ImageMemoryBarrierBuilder<'b> {
        ImageMemoryBarrierBuilder {
            raw: vks::VkImageMemoryBarrier::default(),
            _p: PhantomData,
            set_mask: ImageMemoryBarrierFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_PNEXT;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.srcAccessMask = src_access_mask.bits();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_SRCACCESSMASK;
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_DSTACCESSMASK;
        self
    }

    pub fn old_layout<'m>(mut self, old_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.oldLayout = old_layout.into();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_OLDLAYOUT;
        self
    }

    pub fn new_layout<'m>(mut self, new_layout: ImageLayout) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.newLayout = new_layout.into();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_NEWLAYOUT;
        self
    }

    pub fn src_queue_family_index<'m>(mut self, src_queue_family_index: u32) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.srcQueueFamilyIndex = src_queue_family_index.into();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX;
        self
    }

    pub fn dst_queue_family_index<'m>(mut self, dst_queue_family_index: u32) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.dstQueueFamilyIndex = dst_queue_family_index.into();
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageMemoryBarrierBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_IMAGE;
        self
    }

    pub fn subresource_range<'m>(mut self, subresource_range: ImageSubresourceRange) -> ImageMemoryBarrierBuilder<'b> {
        self.raw.subresourceRange = subresource_range.raw;
        self.set_mask |= ImageMemoryBarrierFlags::FLAG_SUBRESOURCERANGE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_PNEXT != ImageMemoryBarrierFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_SRCACCESSMASK != ImageMemoryBarrierFlags::FLAG_SRCACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("ImageMemoryBarrier::src_access_mask: error converting flags") )
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_DSTACCESSMASK != ImageMemoryBarrierFlags::FLAG_DSTACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("ImageMemoryBarrier::dst_access_mask: error converting flags") )
    }

    pub fn get_old_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_OLDLAYOUT != ImageMemoryBarrierFlags::FLAG_OLDLAYOUT { return None }
        Some( self.raw.oldLayout.into() )
    }

    pub fn get_new_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_NEWLAYOUT != ImageMemoryBarrierFlags::FLAG_NEWLAYOUT { return None }
        Some( self.raw.newLayout.into() )
    }

    pub fn get_src_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX != ImageMemoryBarrierFlags::FLAG_SRCQUEUEFAMILYINDEX { return None }
        Some( self.raw.srcQueueFamilyIndex.into() )
    }

    pub fn get_dst_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX != ImageMemoryBarrierFlags::FLAG_DSTQUEUEFAMILYINDEX { return None }
        Some( self.raw.dstQueueFamilyIndex.into() )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_IMAGE != ImageMemoryBarrierFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_subresource_range<'a>(&'a self) -> Option<&'a ImageSubresourceRange> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_SUBRESOURCERANGE != ImageMemoryBarrierFlags::FLAG_SUBRESOURCERANGE { return None }
        Some(  unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) } )
    }

    pub fn get_subresource_range_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceRange> {
        if self.set_mask & ImageMemoryBarrierFlags::FLAG_SUBRESOURCERANGE != ImageMemoryBarrierFlags::FLAG_SUBRESOURCERANGE { return None }
        Some( unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) } )
    }

    pub fn build(self) -> ImageMemoryBarrier<'b> {
        ImageMemoryBarrier {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageCreateInfo<'s> {
    raw: vks::VkImageCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageCreateInfo<'s> {
    pub fn builder<'b>() -> ImageCreateInfoBuilder<'b> {
        ImageCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageCreateInfo) -> ImageCreateInfo<'s> {
        ImageCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("ImageCreateInfo::flags: error converting flags")
    }

    pub fn image_type<'a>(&'a self) -> ImageType {
        self.raw.imageType.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn mip_levels<'a>(&'a self) -> u32 {
        self.raw.mipLevels.into()
    }

    pub fn array_layers<'a>(&'a self) -> u32 {
        self.raw.arrayLayers.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("ImageCreateInfo::samples: error converting flags")
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("ImageCreateInfo::usage: error converting flags")
    }

    pub fn sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.sharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ImageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_image_type<'m>(&mut self, image_type: ImageType) {
        self.raw.imageType = image_type.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_mip_levels<'m>(&mut self, mip_levels: u32) {
        self.raw.mipLevels = mip_levels.into();
    }

    pub fn set_array_layers<'m>(&mut self, array_layers: u32) {
        self.raw.arrayLayers = array_layers.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_sharing_mode<'m>(&mut self, sharing_mode: SharingMode) {
        self.raw.sharingMode = sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `ImageCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_initial_layout<'m>(&mut self, initial_layout: ImageLayout) {
        self.raw.initialLayout = initial_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkImageCreateInfo {
        &self.raw
    }
}

impl<'s> From<ImageCreateInfo<'s>> for vks::VkImageCreateInfo {
    fn from(f: ImageCreateInfo<'s>) -> vks::VkImageCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkImageCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_IMAGETYPE			 = 0b1000;
        const FLAG_FORMAT			 = 0b10000;
        const FLAG_EXTENT			 = 0b100000;
        const FLAG_MIPLEVELS			 = 0b1000000;
        const FLAG_ARRAYLAYERS			 = 0b10000000;
        const FLAG_SAMPLES			 = 0b100000000;
        const FLAG_TILING			 = 0b1000000000;
        const FLAG_USAGE			 = 0b10000000000;
        const FLAG_SHARINGMODE			 = 0b100000000000;
        const FLAG_QUEUEFAMILYINDEXCOUNT			 = 0b1000000000000;
        const FLAG_PQUEUEFAMILYINDICES			 = 0b10000000000000;
        const FLAG_INITIALLAYOUT			 = 0b100000000000000;
    }
}


/// A builder for `VkImageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageCreateInfoBuilder<'b> {
    raw: vks::VkImageCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageCreateInfoFlags,
}

impl<'b> ImageCreateInfoBuilder<'b> {
    pub fn new() -> ImageCreateInfoBuilder<'b> {
        ImageCreateInfoBuilder {
            raw: vks::VkImageCreateInfo::default(),
            _p: PhantomData,
            set_mask: ImageCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: ImageCreateFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImageCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn image_type<'m>(mut self, image_type: ImageType) -> ImageCreateInfoBuilder<'b> {
        self.raw.imageType = image_type.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_IMAGETYPE;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> ImageCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_FORMAT;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageCreateInfoBuilder<'b> {
        self.raw.extent = extent.raw;
        self.set_mask |= ImageCreateInfoFlags::FLAG_EXTENT;
        self
    }

    pub fn mip_levels<'m>(mut self, mip_levels: u32) -> ImageCreateInfoBuilder<'b> {
        self.raw.mipLevels = mip_levels.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_MIPLEVELS;
        self
    }

    pub fn array_layers<'m>(mut self, array_layers: u32) -> ImageCreateInfoBuilder<'b> {
        self.raw.arrayLayers = array_layers.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_ARRAYLAYERS;
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.samples = samples.bits();
        self.set_mask |= ImageCreateInfoFlags::FLAG_SAMPLES;
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> ImageCreateInfoBuilder<'b> {
        self.raw.tiling = tiling.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_TILING;
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> ImageCreateInfoBuilder<'b> {
        self.raw.usage = usage.bits();
        self.set_mask |= ImageCreateInfoFlags::FLAG_USAGE;
        self
    }

    pub fn sharing_mode<'m>(mut self, sharing_mode: SharingMode) -> ImageCreateInfoBuilder<'b> {
        self.raw.sharingMode = sharing_mode.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_SHARINGMODE;
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> ImageCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `ImageCreateInfo::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.set_mask |= ImageCreateInfoFlags::FLAG_QUEUEFAMILYINDEXCOUNT;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= ImageCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES;
        self
    }

    pub fn initial_layout<'m>(mut self, initial_layout: ImageLayout) -> ImageCreateInfoBuilder<'b> {
        self.raw.initialLayout = initial_layout.into();
        self.set_mask |= ImageCreateInfoFlags::FLAG_INITIALLAYOUT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_PNEXT != ImageCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ImageCreateFlags> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_FLAGS != ImageCreateInfoFlags::FLAG_FLAGS { return None }
        Some( ImageCreateFlags::from_bits(self.raw.flags)
            .expect("ImageCreateInfo::flags: error converting flags") )
    }

    pub fn get_image_type<'a>(&'a self) -> Option<ImageType> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_IMAGETYPE != ImageCreateInfoFlags::FLAG_IMAGETYPE { return None }
        Some( self.raw.imageType.into() )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_FORMAT != ImageCreateInfoFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_EXTENT != ImageCreateInfoFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_EXTENT != ImageCreateInfoFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn get_mip_levels<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_MIPLEVELS != ImageCreateInfoFlags::FLAG_MIPLEVELS { return None }
        Some( self.raw.mipLevels.into() )
    }

    pub fn get_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_ARRAYLAYERS != ImageCreateInfoFlags::FLAG_ARRAYLAYERS { return None }
        Some( self.raw.arrayLayers.into() )
    }

    pub fn get_samples<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_SAMPLES != ImageCreateInfoFlags::FLAG_SAMPLES { return None }
        Some( SampleCountFlags::from_bits(self.raw.samples)
            .expect("ImageCreateInfo::samples: error converting flags") )
    }

    pub fn get_tiling<'a>(&'a self) -> Option<ImageTiling> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_TILING != ImageCreateInfoFlags::FLAG_TILING { return None }
        Some( self.raw.tiling.into() )
    }

    pub fn get_usage<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_USAGE != ImageCreateInfoFlags::FLAG_USAGE { return None }
        Some( ImageUsageFlags::from_bits(self.raw.usage)
            .expect("ImageCreateInfo::usage: error converting flags") )
    }

    pub fn get_sharing_mode<'a>(&'a self) -> Option<SharingMode> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_SHARINGMODE != ImageCreateInfoFlags::FLAG_SHARINGMODE { return None }
        Some( self.raw.sharingMode.into() )
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES != ImageCreateInfoFlags::FLAG_PQUEUEFAMILYINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) } )
    }

    pub fn get_initial_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & ImageCreateInfoFlags::FLAG_INITIALLAYOUT != ImageCreateInfoFlags::FLAG_INITIALLAYOUT { return None }
        Some( self.raw.initialLayout.into() )
    }

    pub fn build(self) -> ImageCreateInfo<'b> {
        ImageCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSubresourceLayout`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubresourceLayout {
    raw: vks::VkSubresourceLayout,
}

impl SubresourceLayout {
    pub fn builder() -> SubresourceLayoutBuilder {
        SubresourceLayoutBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubresourceLayout) -> SubresourceLayout {
        SubresourceLayout { raw, }
    }

    pub fn offset<'a>(&'a self) -> u64 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn row_pitch<'a>(&'a self) -> u64 {
        self.raw.rowPitch.into()
    }

    pub fn array_pitch<'a>(&'a self) -> u64 {
        self.raw.arrayPitch.into()
    }

    pub fn depth_pitch<'a>(&'a self) -> u64 {
        self.raw.depthPitch.into()
    }

    pub fn set_offset<'m>(&mut self, offset: u64) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_row_pitch<'m>(&mut self, row_pitch: u64) {
        self.raw.rowPitch = row_pitch.into();
    }

    pub fn set_array_pitch<'m>(&mut self, array_pitch: u64) {
        self.raw.arrayPitch = array_pitch.into();
    }

    pub fn set_depth_pitch<'m>(&mut self, depth_pitch: u64) {
        self.raw.depthPitch = depth_pitch.into();
    }

    pub fn as_raw(&self) -> &vks::VkSubresourceLayout {
        &self.raw
    }
}

impl From<SubresourceLayout> for vks::VkSubresourceLayout {
    fn from(f: SubresourceLayout) -> vks::VkSubresourceLayout {
        f.raw
    }
}


/// Bitflags for `VkSubresourceLayout`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SubresourceLayoutFlags: u32 {
        const FLAG_OFFSET			 = 0b1;
        const FLAG_SIZE			 = 0b10;
        const FLAG_ROWPITCH			 = 0b100;
        const FLAG_ARRAYPITCH			 = 0b1000;
        const FLAG_DEPTHPITCH			 = 0b10000;
    }
}


/// A builder for `VkSubresourceLayout`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubresourceLayoutBuilder {
    raw: vks::VkSubresourceLayout,
    set_mask: SubresourceLayoutFlags,
}

impl SubresourceLayoutBuilder {
    pub fn new() -> SubresourceLayoutBuilder {
        SubresourceLayoutBuilder {
            raw: vks::VkSubresourceLayout::default(),
            set_mask: SubresourceLayoutFlags::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: u64) -> SubresourceLayoutBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= SubresourceLayoutFlags::FLAG_OFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> SubresourceLayoutBuilder {
        self.raw.size = size.into();
        self.set_mask |= SubresourceLayoutFlags::FLAG_SIZE;
        self
    }

    pub fn row_pitch<'m>(mut self, row_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.rowPitch = row_pitch.into();
        self.set_mask |= SubresourceLayoutFlags::FLAG_ROWPITCH;
        self
    }

    pub fn array_pitch<'m>(mut self, array_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.arrayPitch = array_pitch.into();
        self.set_mask |= SubresourceLayoutFlags::FLAG_ARRAYPITCH;
        self
    }

    pub fn depth_pitch<'m>(mut self, depth_pitch: u64) -> SubresourceLayoutBuilder {
        self.raw.depthPitch = depth_pitch.into();
        self.set_mask |= SubresourceLayoutFlags::FLAG_DEPTHPITCH;
        self
    }

    pub fn get_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SubresourceLayoutFlags::FLAG_OFFSET != SubresourceLayoutFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SubresourceLayoutFlags::FLAG_SIZE != SubresourceLayoutFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn get_row_pitch<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SubresourceLayoutFlags::FLAG_ROWPITCH != SubresourceLayoutFlags::FLAG_ROWPITCH { return None }
        Some( self.raw.rowPitch.into() )
    }

    pub fn get_array_pitch<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SubresourceLayoutFlags::FLAG_ARRAYPITCH != SubresourceLayoutFlags::FLAG_ARRAYPITCH { return None }
        Some( self.raw.arrayPitch.into() )
    }

    pub fn get_depth_pitch<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SubresourceLayoutFlags::FLAG_DEPTHPITCH != SubresourceLayoutFlags::FLAG_DEPTHPITCH { return None }
        Some( self.raw.depthPitch.into() )
    }

    pub fn build(self) -> SubresourceLayout {
        SubresourceLayout {
            raw: self.raw,
        }
    }
}


/// A `VkImageViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageViewCreateInfo<'s> {
    raw: vks::VkImageViewCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageViewCreateInfo<'s> {
    pub fn builder<'b>() -> ImageViewCreateInfoBuilder<'b> {
        ImageViewCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageViewCreateInfo) -> ImageViewCreateInfo<'s> {
        ImageViewCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ImageViewCreateFlags {
        ImageViewCreateFlags::from_bits(self.raw.flags)
            .expect("ImageViewCreateInfo::flags: error converting flags")
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn view_type<'a>(&'a self) -> ImageViewType {
        self.raw.viewType.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn components<'a>(&'a self) -> &'a ComponentMapping {
         unsafe { &*(&self.raw.components as *const vks::VkComponentMapping as *const ComponentMapping) }
    }

    pub fn components_mut<'a>(&'a mut self) -> &'a mut ComponentMapping {
        unsafe { &mut *(&mut self.raw.components as *mut  vks::VkComponentMapping as *mut ComponentMapping) }
    }

    pub fn subresource_range<'a>(&'a self) -> &'a ImageSubresourceRange {
         unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) }
    }

    pub fn subresource_range_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceRange {
        unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ImageViewCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_view_type<'m>(&mut self, view_type: ImageViewType) {
        self.raw.viewType = view_type.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_components<'m>(&mut self, components: ComponentMapping) {
        self.raw.components = components.raw;
    }

    pub fn set_subresource_range<'m>(&mut self, subresource_range: ImageSubresourceRange) {
        self.raw.subresourceRange = subresource_range.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageViewCreateInfo {
        &self.raw
    }
}

impl<'s> From<ImageViewCreateInfo<'s>> for vks::VkImageViewCreateInfo {
    fn from(f: ImageViewCreateInfo<'s>) -> vks::VkImageViewCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkImageViewCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageViewCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_IMAGE			 = 0b1000;
        const FLAG_VIEWTYPE			 = 0b10000;
        const FLAG_FORMAT			 = 0b100000;
        const FLAG_COMPONENTS			 = 0b1000000;
        const FLAG_SUBRESOURCERANGE			 = 0b10000000;
    }
}


/// A builder for `VkImageViewCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageViewCreateInfoBuilder<'b> {
    raw: vks::VkImageViewCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageViewCreateInfoFlags,
}

impl<'b> ImageViewCreateInfoBuilder<'b> {
    pub fn new() -> ImageViewCreateInfoBuilder<'b> {
        ImageViewCreateInfoBuilder {
            raw: vks::VkImageViewCreateInfo::default(),
            _p: PhantomData,
            set_mask: ImageViewCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: ImageViewCreateFlags) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageViewCreateInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_IMAGE;
        self
    }

    pub fn view_type<'m>(mut self, view_type: ImageViewType) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.viewType = view_type.into();
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_VIEWTYPE;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.format = format.into();
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_FORMAT;
        self
    }

    pub fn components<'m>(mut self, components: ComponentMapping) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.components = components.raw;
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_COMPONENTS;
        self
    }

    pub fn subresource_range<'m>(mut self, subresource_range: ImageSubresourceRange) -> ImageViewCreateInfoBuilder<'b> {
        self.raw.subresourceRange = subresource_range.raw;
        self.set_mask |= ImageViewCreateInfoFlags::FLAG_SUBRESOURCERANGE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_PNEXT != ImageViewCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ImageViewCreateFlags> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_FLAGS != ImageViewCreateInfoFlags::FLAG_FLAGS { return None }
        Some( ImageViewCreateFlags::from_bits(self.raw.flags)
            .expect("ImageViewCreateInfo::flags: error converting flags") )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_IMAGE != ImageViewCreateInfoFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_view_type<'a>(&'a self) -> Option<ImageViewType> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_VIEWTYPE != ImageViewCreateInfoFlags::FLAG_VIEWTYPE { return None }
        Some( self.raw.viewType.into() )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_FORMAT != ImageViewCreateInfoFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_components<'a>(&'a self) -> Option<&'a ComponentMapping> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_COMPONENTS != ImageViewCreateInfoFlags::FLAG_COMPONENTS { return None }
        Some(  unsafe { &*(&self.raw.components as *const vks::VkComponentMapping as *const ComponentMapping) } )
    }

    pub fn get_components_mut<'a>(&'a mut self) -> Option<&'a mut ComponentMapping> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_COMPONENTS != ImageViewCreateInfoFlags::FLAG_COMPONENTS { return None }
        Some( unsafe { &mut *(&mut self.raw.components as *mut  vks::VkComponentMapping as *mut ComponentMapping) } )
    }

    pub fn get_subresource_range<'a>(&'a self) -> Option<&'a ImageSubresourceRange> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_SUBRESOURCERANGE != ImageViewCreateInfoFlags::FLAG_SUBRESOURCERANGE { return None }
        Some(  unsafe { &*(&self.raw.subresourceRange as *const vks::VkImageSubresourceRange as *const ImageSubresourceRange) } )
    }

    pub fn get_subresource_range_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceRange> {
        if self.set_mask & ImageViewCreateInfoFlags::FLAG_SUBRESOURCERANGE != ImageViewCreateInfoFlags::FLAG_SUBRESOURCERANGE { return None }
        Some( unsafe { &mut *(&mut self.raw.subresourceRange as *mut  vks::VkImageSubresourceRange as *mut ImageSubresourceRange) } )
    }

    pub fn build(self) -> ImageViewCreateInfo<'b> {
        ImageViewCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferCopy {
    raw: vks::VkBufferCopy,
}

impl BufferCopy {
    pub fn builder() -> BufferCopyBuilder {
        BufferCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferCopy) -> BufferCopy {
        BufferCopy { raw, }
    }

    pub fn src_offset<'a>(&'a self) -> u64 {
        self.raw.srcOffset.into()
    }

    pub fn dst_offset<'a>(&'a self) -> u64 {
        self.raw.dstOffset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: u64) {
        self.raw.srcOffset = src_offset.into();
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: u64) {
        self.raw.dstOffset = dst_offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkBufferCopy {
        &self.raw
    }
}

impl From<BufferCopy> for vks::VkBufferCopy {
    fn from(f: BufferCopy) -> vks::VkBufferCopy {
        f.raw
    }
}


/// Bitflags for `VkBufferCopy`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferCopyFlags: u32 {
        const FLAG_SRCOFFSET			 = 0b1;
        const FLAG_DSTOFFSET			 = 0b10;
        const FLAG_SIZE			 = 0b100;
    }
}


/// A builder for `VkBufferCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferCopyBuilder {
    raw: vks::VkBufferCopy,
    set_mask: BufferCopyFlags,
}

impl BufferCopyBuilder {
    pub fn new() -> BufferCopyBuilder {
        BufferCopyBuilder {
            raw: vks::VkBufferCopy::default(),
            set_mask: BufferCopyFlags::default(),
        }
    }

    pub fn src_offset<'m>(mut self, src_offset: u64) -> BufferCopyBuilder {
        self.raw.srcOffset = src_offset.into();
        self.set_mask |= BufferCopyFlags::FLAG_SRCOFFSET;
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: u64) -> BufferCopyBuilder {
        self.raw.dstOffset = dst_offset.into();
        self.set_mask |= BufferCopyFlags::FLAG_DSTOFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> BufferCopyBuilder {
        self.raw.size = size.into();
        self.set_mask |= BufferCopyFlags::FLAG_SIZE;
        self
    }

    pub fn get_src_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferCopyFlags::FLAG_SRCOFFSET != BufferCopyFlags::FLAG_SRCOFFSET { return None }
        Some( self.raw.srcOffset.into() )
    }

    pub fn get_dst_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferCopyFlags::FLAG_DSTOFFSET != BufferCopyFlags::FLAG_DSTOFFSET { return None }
        Some( self.raw.dstOffset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferCopyFlags::FLAG_SIZE != BufferCopyFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn build(self) -> BufferCopy {
        BufferCopy {
            raw: self.raw,
        }
    }
}


/// A `VkSparseMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseMemoryBind {
    raw: vks::VkSparseMemoryBind,
}

impl SparseMemoryBind {
    pub fn builder() -> SparseMemoryBindBuilder {
        SparseMemoryBindBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseMemoryBind) -> SparseMemoryBind {
        SparseMemoryBind { raw, }
    }

    pub fn resource_offset<'a>(&'a self) -> u64 {
        self.raw.resourceOffset.into()
    }

    pub fn size<'a>(&'a self) -> u64 {
        self.raw.size.into()
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseMemoryBind::flags: error converting flags")
    }

    pub fn set_resource_offset<'m>(&mut self, resource_offset: u64) {
        self.raw.resourceOffset = resource_offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u64) {
        self.raw.size = size.into();
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_memory_offset<'m>(&mut self, memory_offset: u64) {
        self.raw.memoryOffset = memory_offset.into();
    }

    pub fn set_flags<'m>(&mut self, flags: SparseMemoryBindFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseMemoryBind {
        &self.raw
    }
}

impl From<SparseMemoryBind> for vks::VkSparseMemoryBind {
    fn from(f: SparseMemoryBind) -> vks::VkSparseMemoryBind {
        f.raw
    }
}


/// Bitflags for `VkSparseMemoryBind`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseMemoryBindFlags: u32 {
        const FLAG_RESOURCEOFFSET			 = 0b1;
        const FLAG_SIZE			 = 0b10;
        const FLAG_MEMORY			 = 0b100;
        const FLAG_MEMORYOFFSET			 = 0b1000;
        const FLAG_FLAGS			 = 0b10000;
    }
}


/// A builder for `VkSparseMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseMemoryBindBuilder {
    raw: vks::VkSparseMemoryBind,
    set_mask: SparseMemoryBindFlags,
}

impl SparseMemoryBindBuilder {
    pub fn new() -> SparseMemoryBindBuilder {
        SparseMemoryBindBuilder {
            raw: vks::VkSparseMemoryBind::default(),
            set_mask: SparseMemoryBindFlags::default(),
        }
    }

    pub fn resource_offset<'m>(mut self, resource_offset: u64) -> SparseMemoryBindBuilder {
        self.raw.resourceOffset = resource_offset.into();
        self.set_mask |= SparseMemoryBindFlags::FLAG_RESOURCEOFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u64) -> SparseMemoryBindBuilder {
        self.raw.size = size.into();
        self.set_mask |= SparseMemoryBindFlags::FLAG_SIZE;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> SparseMemoryBindBuilder
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self.set_mask |= SparseMemoryBindFlags::FLAG_MEMORY;
        self
    }

    pub fn memory_offset<'m>(mut self, memory_offset: u64) -> SparseMemoryBindBuilder {
        self.raw.memoryOffset = memory_offset.into();
        self.set_mask |= SparseMemoryBindFlags::FLAG_MEMORYOFFSET;
        self
    }

    pub fn flags<'m>(mut self, flags: SparseMemoryBindFlags) -> SparseMemoryBindBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= SparseMemoryBindFlags::FLAG_FLAGS;
        self
    }

    pub fn get_resource_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseMemoryBindFlags::FLAG_RESOURCEOFFSET != SparseMemoryBindFlags::FLAG_RESOURCEOFFSET { return None }
        Some( self.raw.resourceOffset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseMemoryBindFlags::FLAG_SIZE != SparseMemoryBindFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn get_memory<'a>(&'a self) -> Option<vks::VkDeviceMemory> {
        if self.set_mask & SparseMemoryBindFlags::FLAG_MEMORY != SparseMemoryBindFlags::FLAG_MEMORY { return None }
        Some( self.raw.memory )
    }

    pub fn get_memory_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseMemoryBindFlags::FLAG_MEMORYOFFSET != SparseMemoryBindFlags::FLAG_MEMORYOFFSET { return None }
        Some( self.raw.memoryOffset.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SparseMemoryBindFlags> {
        if self.set_mask & SparseMemoryBindFlags::FLAG_FLAGS != SparseMemoryBindFlags::FLAG_FLAGS { return None }
        Some( SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseMemoryBind::flags: error converting flags") )
    }

    pub fn build(self) -> SparseMemoryBind {
        SparseMemoryBind {
            raw: self.raw,
        }
    }
}


/// A `VkSparseImageMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryBind {
    raw: vks::VkSparseImageMemoryBind,
}

impl SparseImageMemoryBind {
    pub fn builder() -> SparseImageMemoryBindBuilder {
        SparseImageMemoryBindBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryBind) -> SparseImageMemoryBind {
        SparseImageMemoryBind { raw, }
    }

    pub fn subresource<'a>(&'a self) -> &'a ImageSubresource {
         unsafe { &*(&self.raw.subresource as *const vks::VkImageSubresource as *const ImageSubresource) }
    }

    pub fn subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresource {
        unsafe { &mut *(&mut self.raw.subresource as *mut  vks::VkImageSubresource as *mut ImageSubresource) }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.offset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn memory_offset<'a>(&'a self) -> u64 {
        self.raw.memoryOffset.into()
    }

    pub fn flags<'a>(&'a self) -> SparseMemoryBindFlags {
        SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseImageMemoryBind::flags: error converting flags")
    }

    pub fn set_subresource<'m>(&mut self, subresource: ImageSubresource) {
        self.raw.subresource = subresource.raw;
    }

    pub fn set_offset<'m>(&mut self, offset: Offset3d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_memory_offset<'m>(&mut self, memory_offset: u64) {
        self.raw.memoryOffset = memory_offset.into();
    }

    pub fn set_flags<'m>(&mut self, flags: SparseMemoryBindFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryBind {
        &self.raw
    }
}

impl From<SparseImageMemoryBind> for vks::VkSparseImageMemoryBind {
    fn from(f: SparseImageMemoryBind) -> vks::VkSparseImageMemoryBind {
        f.raw
    }
}


/// Bitflags for `VkSparseImageMemoryBind`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageMemoryBindFlags: u32 {
        const FLAG_SUBRESOURCE			 = 0b1;
        const FLAG_OFFSET			 = 0b10;
        const FLAG_EXTENT			 = 0b100;
        const FLAG_MEMORY			 = 0b1000;
        const FLAG_MEMORYOFFSET			 = 0b10000;
        const FLAG_FLAGS			 = 0b100000;
    }
}


/// A builder for `VkSparseImageMemoryBind`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryBindBuilder {
    raw: vks::VkSparseImageMemoryBind,
    set_mask: SparseImageMemoryBindFlags,
}

impl SparseImageMemoryBindBuilder {
    pub fn new() -> SparseImageMemoryBindBuilder {
        SparseImageMemoryBindBuilder {
            raw: vks::VkSparseImageMemoryBind::default(),
            set_mask: SparseImageMemoryBindFlags::default(),
        }
    }

    pub fn subresource<'m>(mut self, subresource: ImageSubresource) -> SparseImageMemoryBindBuilder {
        self.raw.subresource = subresource.raw;
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_SUBRESOURCE;
        self
    }

    pub fn offset<'m>(mut self, offset: Offset3d) -> SparseImageMemoryBindBuilder {
        self.raw.offset = offset.raw;
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_OFFSET;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> SparseImageMemoryBindBuilder {
        self.raw.extent = extent.raw;
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_EXTENT;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> SparseImageMemoryBindBuilder
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_MEMORY;
        self
    }

    pub fn memory_offset<'m>(mut self, memory_offset: u64) -> SparseImageMemoryBindBuilder {
        self.raw.memoryOffset = memory_offset.into();
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_MEMORYOFFSET;
        self
    }

    pub fn flags<'m>(mut self, flags: SparseMemoryBindFlags) -> SparseImageMemoryBindBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= SparseImageMemoryBindFlags::FLAG_FLAGS;
        self
    }

    pub fn get_subresource<'a>(&'a self) -> Option<&'a ImageSubresource> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_SUBRESOURCE != SparseImageMemoryBindFlags::FLAG_SUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.subresource as *const vks::VkImageSubresource as *const ImageSubresource) } )
    }

    pub fn get_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresource> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_SUBRESOURCE != SparseImageMemoryBindFlags::FLAG_SUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.subresource as *mut  vks::VkImageSubresource as *mut ImageSubresource) } )
    }

    pub fn get_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_OFFSET != SparseImageMemoryBindFlags::FLAG_OFFSET { return None }
        Some(  unsafe { &*(&self.raw.offset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_OFFSET != SparseImageMemoryBindFlags::FLAG_OFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_EXTENT != SparseImageMemoryBindFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_EXTENT != SparseImageMemoryBindFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn get_memory<'a>(&'a self) -> Option<vks::VkDeviceMemory> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_MEMORY != SparseImageMemoryBindFlags::FLAG_MEMORY { return None }
        Some( self.raw.memory )
    }

    pub fn get_memory_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_MEMORYOFFSET != SparseImageMemoryBindFlags::FLAG_MEMORYOFFSET { return None }
        Some( self.raw.memoryOffset.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SparseMemoryBindFlags> {
        if self.set_mask & SparseImageMemoryBindFlags::FLAG_FLAGS != SparseImageMemoryBindFlags::FLAG_FLAGS { return None }
        Some( SparseMemoryBindFlags::from_bits(self.raw.flags)
            .expect("SparseImageMemoryBind::flags: error converting flags") )
    }

    pub fn build(self) -> SparseImageMemoryBind {
        SparseImageMemoryBind {
            raw: self.raw,
        }
    }
}


/// A `VkSparseBufferMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseBufferMemoryBindInfo<'s> {
    raw: vks::VkSparseBufferMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseBufferMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseBufferMemoryBindInfoBuilder<'b> {
        SparseBufferMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseBufferMemoryBindInfo) -> SparseBufferMemoryBindInfo<'s> {
        SparseBufferMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseBufferMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseBufferMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseBufferMemoryBindInfo<'s>> for vks::VkSparseBufferMemoryBindInfo {
    fn from(f: SparseBufferMemoryBindInfo<'s>) -> vks::VkSparseBufferMemoryBindInfo {
        f.raw
    }
}


/// Bitflags for `VkSparseBufferMemoryBindInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseBufferMemoryBindInfoFlags: u32 {
        const FLAG_BUFFER			 = 0b1;
        const FLAG_BINDCOUNT			 = 0b10;
        const FLAG_PBINDS			 = 0b100;
    }
}


/// A builder for `VkSparseBufferMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseBufferMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseBufferMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SparseBufferMemoryBindInfoFlags,
}

impl<'b> SparseBufferMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseBufferMemoryBindInfoBuilder<'b> {
        SparseBufferMemoryBindInfoBuilder {
            raw: vks::VkSparseBufferMemoryBindInfo::default(),
            _p: PhantomData,
            set_mask: SparseBufferMemoryBindInfoFlags::default(),
        }
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> SparseBufferMemoryBindInfoBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= SparseBufferMemoryBindInfoFlags::FLAG_BUFFER;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseMemoryBind]) -> SparseBufferMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseBufferMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.set_mask |= SparseBufferMemoryBindInfoFlags::FLAG_BINDCOUNT;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
        self
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & SparseBufferMemoryBindInfoFlags::FLAG_BUFFER != SparseBufferMemoryBindInfoFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn get_binds<'a>(&'a self) -> Option<&'a [SparseMemoryBind]> {
        if self.raw.pBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) } )
    }

    pub fn build(self) -> SparseBufferMemoryBindInfo<'b> {
        SparseBufferMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageOpaqueMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageOpaqueMemoryBindInfo<'s> {
    raw: vks::VkSparseImageOpaqueMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageOpaqueMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
        SparseImageOpaqueMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageOpaqueMemoryBindInfo) -> SparseImageOpaqueMemoryBindInfo<'s> {
        SparseImageOpaqueMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageOpaqueMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageOpaqueMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseImageOpaqueMemoryBindInfo<'s>> for vks::VkSparseImageOpaqueMemoryBindInfo {
    fn from(f: SparseImageOpaqueMemoryBindInfo<'s>) -> vks::VkSparseImageOpaqueMemoryBindInfo {
        f.raw
    }
}


/// Bitflags for `VkSparseImageOpaqueMemoryBindInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageOpaqueMemoryBindInfoFlags: u32 {
        const FLAG_IMAGE			 = 0b1;
        const FLAG_BINDCOUNT			 = 0b10;
        const FLAG_PBINDS			 = 0b100;
    }
}


/// A builder for `VkSparseImageOpaqueMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageOpaqueMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseImageOpaqueMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SparseImageOpaqueMemoryBindInfoFlags,
}

impl<'b> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseImageOpaqueMemoryBindInfoBuilder<'b> {
        SparseImageOpaqueMemoryBindInfoBuilder {
            raw: vks::VkSparseImageOpaqueMemoryBindInfo::default(),
            _p: PhantomData,
            set_mask: SparseImageOpaqueMemoryBindInfoFlags::default(),
        }
    }

    pub fn image<'m, H>(mut self, image: H) -> SparseImageOpaqueMemoryBindInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= SparseImageOpaqueMemoryBindInfoFlags::FLAG_IMAGE;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseMemoryBind]) -> SparseImageOpaqueMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageOpaqueMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.set_mask |= SparseImageOpaqueMemoryBindInfoFlags::FLAG_BINDCOUNT;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseMemoryBind;
        self
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & SparseImageOpaqueMemoryBindInfoFlags::FLAG_IMAGE != SparseImageOpaqueMemoryBindInfoFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_binds<'a>(&'a self) -> Option<&'a [SparseMemoryBind]> {
        if self.raw.pBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) } )
    }

    pub fn build(self) -> SparseImageOpaqueMemoryBindInfo<'b> {
        SparseImageOpaqueMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryBindInfo<'s> {
    raw: vks::VkSparseImageMemoryBindInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageMemoryBindInfo<'s> {
    pub fn builder<'b>() -> SparseImageMemoryBindInfoBuilder<'b> {
        SparseImageMemoryBindInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryBindInfo) -> SparseImageMemoryBindInfo<'s> {
        SparseImageMemoryBindInfo { raw, _p: PhantomData }
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn binds<'a>(&'a self) -> &'a [SparseImageMemoryBind] {
        unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) }
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_binds<'m, 'a>(&mut self, binds: &'a [SparseImageMemoryBind])
            where 'a: 's {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseImageMemoryBind;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryBindInfo {
        &self.raw
    }
}

impl<'s> From<SparseImageMemoryBindInfo<'s>> for vks::VkSparseImageMemoryBindInfo {
    fn from(f: SparseImageMemoryBindInfo<'s>) -> vks::VkSparseImageMemoryBindInfo {
        f.raw
    }
}


/// Bitflags for `VkSparseImageMemoryBindInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageMemoryBindInfoFlags: u32 {
        const FLAG_IMAGE			 = 0b1;
        const FLAG_BINDCOUNT			 = 0b10;
        const FLAG_PBINDS			 = 0b100;
    }
}


/// A builder for `VkSparseImageMemoryBindInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryBindInfoBuilder<'b> {
    raw: vks::VkSparseImageMemoryBindInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SparseImageMemoryBindInfoFlags,
}

impl<'b> SparseImageMemoryBindInfoBuilder<'b> {
    pub fn new() -> SparseImageMemoryBindInfoBuilder<'b> {
        SparseImageMemoryBindInfoBuilder {
            raw: vks::VkSparseImageMemoryBindInfo::default(),
            _p: PhantomData,
            set_mask: SparseImageMemoryBindInfoFlags::default(),
        }
    }

    pub fn image<'m, H>(mut self, image: H) -> SparseImageMemoryBindInfoBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= SparseImageMemoryBindInfoFlags::FLAG_IMAGE;
        self
    }

    pub fn binds<'m, 'a>(mut self, binds: &'a [SparseImageMemoryBind]) -> SparseImageMemoryBindInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindCount == 0 || self.raw.bindCount == binds.len() as _, 
            "count inconsistency found when specifying `SparseImageMemoryBindInfo::binds`.");
        self.raw.bindCount = binds.len() as _;
        self.set_mask |= SparseImageMemoryBindInfoFlags::FLAG_BINDCOUNT;
        self.raw.pBinds = binds.as_ptr() as *const vks::VkSparseImageMemoryBind;
        self
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & SparseImageMemoryBindInfoFlags::FLAG_IMAGE != SparseImageMemoryBindInfoFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_binds<'a>(&'a self) -> Option<&'a [SparseImageMemoryBind]> {
        if self.raw.pBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pBinds as *const _, self.raw.bindCount as usize) } )
    }

    pub fn build(self) -> SparseImageMemoryBindInfo<'b> {
        SparseImageMemoryBindInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBindSparseInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BindSparseInfo<'s> {
    raw: vks::VkBindSparseInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> BindSparseInfo<'s> {
    pub fn builder<'b>() -> BindSparseInfoBuilder<'b> {
        BindSparseInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBindSparseInfo) -> BindSparseInfo<'s> {
        BindSparseInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn buffer_binds<'a>(&'a self) -> &'a [SparseBufferMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pBufferBinds as *const _, self.raw.bufferBindCount as usize) }
    }

    pub fn image_opaque_binds<'a>(&'a self) -> &'a [SparseImageOpaqueMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageOpaqueBinds as *const _, self.raw.imageOpaqueBindCount as usize) }
    }

    pub fn image_binds<'a>(&'a self) -> &'a [SparseImageMemoryBindInfo] {
        unsafe { slice::from_raw_parts(self.raw.pImageBinds as *const _, self.raw.imageBindCount as usize) }
    }

    pub fn signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_buffer_binds<'m, 'a>(&mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.bufferBindCount == 0 || self.raw.bufferBindCount == buffer_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::buffer_binds`.");
        self.raw.bufferBindCount = buffer_binds.len() as _;
        self.raw.pBufferBinds = buffer_binds.as_ptr() as *const vks::VkSparseBufferMemoryBindInfo;
    }

    pub fn set_image_opaque_binds<'m, 'a>(&mut self, image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.imageOpaqueBindCount == 0 || self.raw.imageOpaqueBindCount == image_opaque_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_opaque_binds`.");
        self.raw.imageOpaqueBindCount = image_opaque_binds.len() as _;
        self.raw.pImageOpaqueBinds = image_opaque_binds.as_ptr() as *const vks::VkSparseImageOpaqueMemoryBindInfo;
    }

    pub fn set_image_binds<'m, 'a>(&mut self, image_binds: &'a [SparseImageMemoryBindInfo])
            where 'a: 's {
        assert!(self.raw.imageBindCount == 0 || self.raw.imageBindCount == image_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_binds`.");
        self.raw.imageBindCount = image_binds.len() as _;
        self.raw.pImageBinds = image_binds.as_ptr() as *const vks::VkSparseImageMemoryBindInfo;
    }

    pub fn set_signal_semaphores<'m, 'a>(&mut self, signal_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn as_raw(&self) -> &vks::VkBindSparseInfo {
        &self.raw
    }
}

impl<'s> From<BindSparseInfo<'s>> for vks::VkBindSparseInfo {
    fn from(f: BindSparseInfo<'s>) -> vks::VkBindSparseInfo {
        f.raw
    }
}


/// Bitflags for `VkBindSparseInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BindSparseInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_WAITSEMAPHORECOUNT			 = 0b100;
        const FLAG_PWAITSEMAPHORES			 = 0b1000;
        const FLAG_BUFFERBINDCOUNT			 = 0b10000;
        const FLAG_PBUFFERBINDS			 = 0b100000;
        const FLAG_IMAGEOPAQUEBINDCOUNT			 = 0b1000000;
        const FLAG_PIMAGEOPAQUEBINDS			 = 0b10000000;
        const FLAG_IMAGEBINDCOUNT			 = 0b100000000;
        const FLAG_PIMAGEBINDS			 = 0b1000000000;
        const FLAG_SIGNALSEMAPHORECOUNT			 = 0b10000000000;
        const FLAG_PSIGNALSEMAPHORES			 = 0b100000000000;
    }
}


/// A builder for `VkBindSparseInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BindSparseInfoBuilder<'b> {
    raw: vks::VkBindSparseInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: BindSparseInfoFlags,
}

impl<'b> BindSparseInfoBuilder<'b> {
    pub fn new() -> BindSparseInfoBuilder<'b> {
        BindSparseInfoBuilder {
            raw: vks::VkBindSparseInfo::default(),
            _p: PhantomData,
            set_mask: BindSparseInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BindSparseInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BindSparseInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.set_mask |= BindSparseInfoFlags::FLAG_WAITSEMAPHORECOUNT;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self.set_mask |= BindSparseInfoFlags::FLAG_PWAITSEMAPHORES;
        self
    }

    pub fn buffer_binds<'m, 'a>(mut self, buffer_binds: &'a [SparseBufferMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bufferBindCount == 0 || self.raw.bufferBindCount == buffer_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::buffer_binds`.");
        self.raw.bufferBindCount = buffer_binds.len() as _;
        self.set_mask |= BindSparseInfoFlags::FLAG_BUFFERBINDCOUNT;
        self.raw.pBufferBinds = buffer_binds.as_ptr() as *const vks::VkSparseBufferMemoryBindInfo;
        self
    }

    pub fn image_opaque_binds<'m, 'a>(mut self, image_opaque_binds: &'a [SparseImageOpaqueMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.imageOpaqueBindCount == 0 || self.raw.imageOpaqueBindCount == image_opaque_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_opaque_binds`.");
        self.raw.imageOpaqueBindCount = image_opaque_binds.len() as _;
        self.set_mask |= BindSparseInfoFlags::FLAG_IMAGEOPAQUEBINDCOUNT;
        self.raw.pImageOpaqueBinds = image_opaque_binds.as_ptr() as *const vks::VkSparseImageOpaqueMemoryBindInfo;
        self
    }

    pub fn image_binds<'m, 'a>(mut self, image_binds: &'a [SparseImageMemoryBindInfo]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.imageBindCount == 0 || self.raw.imageBindCount == image_binds.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::image_binds`.");
        self.raw.imageBindCount = image_binds.len() as _;
        self.set_mask |= BindSparseInfoFlags::FLAG_IMAGEBINDCOUNT;
        self.raw.pImageBinds = image_binds.as_ptr() as *const vks::VkSparseImageMemoryBindInfo;
        self
    }

    pub fn signal_semaphores<'m, 'a>(mut self, signal_semaphores: &'a [SemaphoreHandle]) -> BindSparseInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `BindSparseInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.set_mask |= BindSparseInfoFlags::FLAG_SIGNALSEMAPHORECOUNT;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
        self.set_mask |= BindSparseInfoFlags::FLAG_PSIGNALSEMAPHORES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BindSparseInfoFlags::FLAG_PNEXT != BindSparseInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> Option<&'a [vks::VkSemaphore]> {
        if self.set_mask & BindSparseInfoFlags::FLAG_PWAITSEMAPHORES != BindSparseInfoFlags::FLAG_PWAITSEMAPHORES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) } )
    }

    pub fn get_buffer_binds<'a>(&'a self) -> Option<&'a [SparseBufferMemoryBindInfo]> {
        if self.raw.pBufferBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pBufferBinds as *const _, self.raw.bufferBindCount as usize) } )
    }

    pub fn get_image_opaque_binds<'a>(&'a self) -> Option<&'a [SparseImageOpaqueMemoryBindInfo]> {
        if self.raw.pImageOpaqueBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pImageOpaqueBinds as *const _, self.raw.imageOpaqueBindCount as usize) } )
    }

    pub fn get_image_binds<'a>(&'a self) -> Option<&'a [SparseImageMemoryBindInfo]> {
        if self.raw.pImageBinds.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pImageBinds as *const _, self.raw.imageBindCount as usize) } )
    }

    pub fn get_signal_semaphores<'a>(&'a self) -> Option<&'a [vks::VkSemaphore]> {
        if self.set_mask & BindSparseInfoFlags::FLAG_PSIGNALSEMAPHORES != BindSparseInfoFlags::FLAG_PSIGNALSEMAPHORES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) } )
    }

    pub fn build(self) -> BindSparseInfo<'b> {
        BindSparseInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageCopy {
    raw: vks::VkImageCopy,
}

impl ImageCopy {
    pub fn builder() -> ImageCopyBuilder {
        ImageCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageCopy) -> ImageCopy {
        ImageCopy { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: Offset3d) {
        self.raw.srcOffset = src_offset.raw;
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: Offset3d) {
        self.raw.dstOffset = dst_offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageCopy {
        &self.raw
    }
}

impl From<ImageCopy> for vks::VkImageCopy {
    fn from(f: ImageCopy) -> vks::VkImageCopy {
        f.raw
    }
}


/// Bitflags for `VkImageCopy`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageCopyFlags: u32 {
        const FLAG_SRCSUBRESOURCE			 = 0b1;
        const FLAG_SRCOFFSET			 = 0b10;
        const FLAG_DSTSUBRESOURCE			 = 0b100;
        const FLAG_DSTOFFSET			 = 0b1000;
        const FLAG_EXTENT			 = 0b10000;
    }
}


/// A builder for `VkImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageCopyBuilder {
    raw: vks::VkImageCopy,
    set_mask: ImageCopyFlags,
}

impl ImageCopyBuilder {
    pub fn new() -> ImageCopyBuilder {
        ImageCopyBuilder {
            raw: vks::VkImageCopy::default(),
            set_mask: ImageCopyFlags::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageCopyBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self.set_mask |= ImageCopyFlags::FLAG_SRCSUBRESOURCE;
        self
    }

    pub fn src_offset<'m>(mut self, src_offset: Offset3d) -> ImageCopyBuilder {
        self.raw.srcOffset = src_offset.raw;
        self.set_mask |= ImageCopyFlags::FLAG_SRCOFFSET;
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageCopyBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self.set_mask |= ImageCopyFlags::FLAG_DSTSUBRESOURCE;
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: Offset3d) -> ImageCopyBuilder {
        self.raw.dstOffset = dst_offset.raw;
        self.set_mask |= ImageCopyFlags::FLAG_DSTOFFSET;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageCopyBuilder {
        self.raw.extent = extent.raw;
        self.set_mask |= ImageCopyFlags::FLAG_EXTENT;
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageCopyFlags::FLAG_SRCSUBRESOURCE != ImageCopyFlags::FLAG_SRCSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageCopyFlags::FLAG_SRCSUBRESOURCE != ImageCopyFlags::FLAG_SRCSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_src_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & ImageCopyFlags::FLAG_SRCOFFSET != ImageCopyFlags::FLAG_SRCOFFSET { return None }
        Some(  unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_src_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & ImageCopyFlags::FLAG_SRCOFFSET != ImageCopyFlags::FLAG_SRCOFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_dst_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageCopyFlags::FLAG_DSTSUBRESOURCE != ImageCopyFlags::FLAG_DSTSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageCopyFlags::FLAG_DSTSUBRESOURCE != ImageCopyFlags::FLAG_DSTSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_dst_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & ImageCopyFlags::FLAG_DSTOFFSET != ImageCopyFlags::FLAG_DSTOFFSET { return None }
        Some(  unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_dst_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & ImageCopyFlags::FLAG_DSTOFFSET != ImageCopyFlags::FLAG_DSTOFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & ImageCopyFlags::FLAG_EXTENT != ImageCopyFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & ImageCopyFlags::FLAG_EXTENT != ImageCopyFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn build(self) -> ImageCopy {
        ImageCopy {
            raw: self.raw,
        }
    }
}


/// A `VkImageBlit`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageBlit {
    raw: vks::VkImageBlit,
}

impl ImageBlit {
    pub fn builder() -> ImageBlitBuilder {
        ImageBlitBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageBlit) -> ImageBlit {
        ImageBlit { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offsets<'a>(&'a self) -> &[Offset3d] {
         unsafe { slice::from_raw_parts(&self.raw.srcOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offsets<'a>(&'a self) -> &[Offset3d] {
         unsafe { slice::from_raw_parts(&self.raw.dstOffsets as *const vks::VkOffset3D as *const _, 2 as usize) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offsets<'m>(&mut self, src_offsets: [Offset3d; 2]) {
        self.raw.srcOffsets = [src_offsets[0].raw, src_offsets[1].raw, ];
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offsets<'m>(&mut self, dst_offsets: [Offset3d; 2]) {
        self.raw.dstOffsets = [dst_offsets[0].raw, dst_offsets[1].raw, ];
    }

    pub fn as_raw(&self) -> &vks::VkImageBlit {
        &self.raw
    }
}

impl From<ImageBlit> for vks::VkImageBlit {
    fn from(f: ImageBlit) -> vks::VkImageBlit {
        f.raw
    }
}


/// Bitflags for `VkImageBlit`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageBlitFlags: u32 {
        const FLAG_SRCSUBRESOURCE			 = 0b1;
        const FLAG_SRCOFFSETS			 = 0b10;
        const FLAG_DSTSUBRESOURCE			 = 0b100;
        const FLAG_DSTOFFSETS			 = 0b1000;
    }
}


/// A builder for `VkImageBlit`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageBlitBuilder {
    raw: vks::VkImageBlit,
    set_mask: ImageBlitFlags,
}

impl ImageBlitBuilder {
    pub fn new() -> ImageBlitBuilder {
        ImageBlitBuilder {
            raw: vks::VkImageBlit::default(),
            set_mask: ImageBlitFlags::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageBlitBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self.set_mask |= ImageBlitFlags::FLAG_SRCSUBRESOURCE;
        self
    }

    pub fn src_offsets<'m>(mut self, src_offsets: [Offset3d; 2]) -> ImageBlitBuilder {
        self.raw.srcOffsets = [src_offsets[0].raw, src_offsets[1].raw, ];
        self.set_mask |= ImageBlitFlags::FLAG_SRCOFFSETS;
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageBlitBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self.set_mask |= ImageBlitFlags::FLAG_DSTSUBRESOURCE;
        self
    }

    pub fn dst_offsets<'m>(mut self, dst_offsets: [Offset3d; 2]) -> ImageBlitBuilder {
        self.raw.dstOffsets = [dst_offsets[0].raw, dst_offsets[1].raw, ];
        self.set_mask |= ImageBlitFlags::FLAG_DSTOFFSETS;
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageBlitFlags::FLAG_SRCSUBRESOURCE != ImageBlitFlags::FLAG_SRCSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageBlitFlags::FLAG_SRCSUBRESOURCE != ImageBlitFlags::FLAG_SRCSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_src_offsets<'a>(&'a self) -> Option<&[Offset3d]> {
        if self.set_mask & ImageBlitFlags::FLAG_SRCOFFSETS != ImageBlitFlags::FLAG_SRCOFFSETS { return None }
        Some(  unsafe { slice::from_raw_parts(&self.raw.srcOffsets as *const vks::VkOffset3D as *const _, 2 as usize) } )
    }

    pub fn get_dst_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageBlitFlags::FLAG_DSTSUBRESOURCE != ImageBlitFlags::FLAG_DSTSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageBlitFlags::FLAG_DSTSUBRESOURCE != ImageBlitFlags::FLAG_DSTSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_dst_offsets<'a>(&'a self) -> Option<&[Offset3d]> {
        if self.set_mask & ImageBlitFlags::FLAG_DSTOFFSETS != ImageBlitFlags::FLAG_DSTOFFSETS { return None }
        Some(  unsafe { slice::from_raw_parts(&self.raw.dstOffsets as *const vks::VkOffset3D as *const _, 2 as usize) } )
    }

    pub fn build(self) -> ImageBlit {
        ImageBlit {
            raw: self.raw,
        }
    }
}


/// A `VkBufferImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferImageCopy {
    raw: vks::VkBufferImageCopy,
}

impl BufferImageCopy {
    pub fn builder() -> BufferImageCopyBuilder {
        BufferImageCopyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferImageCopy) -> BufferImageCopy {
        BufferImageCopy { raw, }
    }

    pub fn buffer_offset<'a>(&'a self) -> u64 {
        self.raw.bufferOffset.into()
    }

    pub fn buffer_row_length<'a>(&'a self) -> u32 {
        self.raw.bufferRowLength.into()
    }

    pub fn buffer_image_height<'a>(&'a self) -> u32 {
        self.raw.bufferImageHeight.into()
    }

    pub fn image_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.imageSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn image_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.imageSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn image_offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.imageOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn image_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.imageOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_buffer_offset<'m>(&mut self, buffer_offset: u64) {
        self.raw.bufferOffset = buffer_offset.into();
    }

    pub fn set_buffer_row_length<'m>(&mut self, buffer_row_length: u32) {
        self.raw.bufferRowLength = buffer_row_length.into();
    }

    pub fn set_buffer_image_height<'m>(&mut self, buffer_image_height: u32) {
        self.raw.bufferImageHeight = buffer_image_height.into();
    }

    pub fn set_image_subresource<'m>(&mut self, image_subresource: ImageSubresourceLayers) {
        self.raw.imageSubresource = image_subresource.raw;
    }

    pub fn set_image_offset<'m>(&mut self, image_offset: Offset3d) {
        self.raw.imageOffset = image_offset.raw;
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent3d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkBufferImageCopy {
        &self.raw
    }
}

impl From<BufferImageCopy> for vks::VkBufferImageCopy {
    fn from(f: BufferImageCopy) -> vks::VkBufferImageCopy {
        f.raw
    }
}


/// Bitflags for `VkBufferImageCopy`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferImageCopyFlags: u32 {
        const FLAG_BUFFEROFFSET			 = 0b1;
        const FLAG_BUFFERROWLENGTH			 = 0b10;
        const FLAG_BUFFERIMAGEHEIGHT			 = 0b100;
        const FLAG_IMAGESUBRESOURCE			 = 0b1000;
        const FLAG_IMAGEOFFSET			 = 0b10000;
        const FLAG_IMAGEEXTENT			 = 0b100000;
    }
}


/// A builder for `VkBufferImageCopy`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferImageCopyBuilder {
    raw: vks::VkBufferImageCopy,
    set_mask: BufferImageCopyFlags,
}

impl BufferImageCopyBuilder {
    pub fn new() -> BufferImageCopyBuilder {
        BufferImageCopyBuilder {
            raw: vks::VkBufferImageCopy::default(),
            set_mask: BufferImageCopyFlags::default(),
        }
    }

    pub fn buffer_offset<'m>(mut self, buffer_offset: u64) -> BufferImageCopyBuilder {
        self.raw.bufferOffset = buffer_offset.into();
        self.set_mask |= BufferImageCopyFlags::FLAG_BUFFEROFFSET;
        self
    }

    pub fn buffer_row_length<'m>(mut self, buffer_row_length: u32) -> BufferImageCopyBuilder {
        self.raw.bufferRowLength = buffer_row_length.into();
        self.set_mask |= BufferImageCopyFlags::FLAG_BUFFERROWLENGTH;
        self
    }

    pub fn buffer_image_height<'m>(mut self, buffer_image_height: u32) -> BufferImageCopyBuilder {
        self.raw.bufferImageHeight = buffer_image_height.into();
        self.set_mask |= BufferImageCopyFlags::FLAG_BUFFERIMAGEHEIGHT;
        self
    }

    pub fn image_subresource<'m>(mut self, image_subresource: ImageSubresourceLayers) -> BufferImageCopyBuilder {
        self.raw.imageSubresource = image_subresource.raw;
        self.set_mask |= BufferImageCopyFlags::FLAG_IMAGESUBRESOURCE;
        self
    }

    pub fn image_offset<'m>(mut self, image_offset: Offset3d) -> BufferImageCopyBuilder {
        self.raw.imageOffset = image_offset.raw;
        self.set_mask |= BufferImageCopyFlags::FLAG_IMAGEOFFSET;
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent3d) -> BufferImageCopyBuilder {
        self.raw.imageExtent = image_extent.raw;
        self.set_mask |= BufferImageCopyFlags::FLAG_IMAGEEXTENT;
        self
    }

    pub fn get_buffer_offset<'a>(&'a self) -> Option<u64> {
        if self.set_mask & BufferImageCopyFlags::FLAG_BUFFEROFFSET != BufferImageCopyFlags::FLAG_BUFFEROFFSET { return None }
        Some( self.raw.bufferOffset.into() )
    }

    pub fn get_buffer_row_length<'a>(&'a self) -> Option<u32> {
        if self.set_mask & BufferImageCopyFlags::FLAG_BUFFERROWLENGTH != BufferImageCopyFlags::FLAG_BUFFERROWLENGTH { return None }
        Some( self.raw.bufferRowLength.into() )
    }

    pub fn get_buffer_image_height<'a>(&'a self) -> Option<u32> {
        if self.set_mask & BufferImageCopyFlags::FLAG_BUFFERIMAGEHEIGHT != BufferImageCopyFlags::FLAG_BUFFERIMAGEHEIGHT { return None }
        Some( self.raw.bufferImageHeight.into() )
    }

    pub fn get_image_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGESUBRESOURCE != BufferImageCopyFlags::FLAG_IMAGESUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.imageSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_image_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGESUBRESOURCE != BufferImageCopyFlags::FLAG_IMAGESUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.imageSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_image_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGEOFFSET != BufferImageCopyFlags::FLAG_IMAGEOFFSET { return None }
        Some(  unsafe { &*(&self.raw.imageOffset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_image_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGEOFFSET != BufferImageCopyFlags::FLAG_IMAGEOFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.imageOffset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_image_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGEEXTENT != BufferImageCopyFlags::FLAG_IMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & BufferImageCopyFlags::FLAG_IMAGEEXTENT != BufferImageCopyFlags::FLAG_IMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn build(self) -> BufferImageCopy {
        BufferImageCopy {
            raw: self.raw,
        }
    }
}


/// A `VkImageResolve`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageResolve {
    raw: vks::VkImageResolve,
}

impl ImageResolve {
    pub fn builder() -> ImageResolveBuilder {
        ImageResolveBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageResolve) -> ImageResolve {
        ImageResolve { raw, }
    }

    pub fn src_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn src_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn src_offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn src_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn dst_subresource<'a>(&'a self) -> &'a ImageSubresourceLayers {
         unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) }
    }

    pub fn dst_subresource_mut<'a>(&'a mut self) -> &'a mut ImageSubresourceLayers {
        unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) }
    }

    pub fn dst_offset<'a>(&'a self) -> &'a Offset3d {
         unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) }
    }

    pub fn dst_offset_mut<'a>(&'a mut self) -> &'a mut Offset3d {
        unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent3d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent3d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) }
    }

    pub fn set_src_subresource<'m>(&mut self, src_subresource: ImageSubresourceLayers) {
        self.raw.srcSubresource = src_subresource.raw;
    }

    pub fn set_src_offset<'m>(&mut self, src_offset: Offset3d) {
        self.raw.srcOffset = src_offset.raw;
    }

    pub fn set_dst_subresource<'m>(&mut self, dst_subresource: ImageSubresourceLayers) {
        self.raw.dstSubresource = dst_subresource.raw;
    }

    pub fn set_dst_offset<'m>(&mut self, dst_offset: Offset3d) {
        self.raw.dstOffset = dst_offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent3d) {
        self.raw.extent = extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageResolve {
        &self.raw
    }
}

impl From<ImageResolve> for vks::VkImageResolve {
    fn from(f: ImageResolve) -> vks::VkImageResolve {
        f.raw
    }
}


/// Bitflags for `VkImageResolve`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageResolveFlags: u32 {
        const FLAG_SRCSUBRESOURCE			 = 0b1;
        const FLAG_SRCOFFSET			 = 0b10;
        const FLAG_DSTSUBRESOURCE			 = 0b100;
        const FLAG_DSTOFFSET			 = 0b1000;
        const FLAG_EXTENT			 = 0b10000;
    }
}


/// A builder for `VkImageResolve`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageResolveBuilder {
    raw: vks::VkImageResolve,
    set_mask: ImageResolveFlags,
}

impl ImageResolveBuilder {
    pub fn new() -> ImageResolveBuilder {
        ImageResolveBuilder {
            raw: vks::VkImageResolve::default(),
            set_mask: ImageResolveFlags::default(),
        }
    }

    pub fn src_subresource<'m>(mut self, src_subresource: ImageSubresourceLayers) -> ImageResolveBuilder {
        self.raw.srcSubresource = src_subresource.raw;
        self.set_mask |= ImageResolveFlags::FLAG_SRCSUBRESOURCE;
        self
    }

    pub fn src_offset<'m>(mut self, src_offset: Offset3d) -> ImageResolveBuilder {
        self.raw.srcOffset = src_offset.raw;
        self.set_mask |= ImageResolveFlags::FLAG_SRCOFFSET;
        self
    }

    pub fn dst_subresource<'m>(mut self, dst_subresource: ImageSubresourceLayers) -> ImageResolveBuilder {
        self.raw.dstSubresource = dst_subresource.raw;
        self.set_mask |= ImageResolveFlags::FLAG_DSTSUBRESOURCE;
        self
    }

    pub fn dst_offset<'m>(mut self, dst_offset: Offset3d) -> ImageResolveBuilder {
        self.raw.dstOffset = dst_offset.raw;
        self.set_mask |= ImageResolveFlags::FLAG_DSTOFFSET;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent3d) -> ImageResolveBuilder {
        self.raw.extent = extent.raw;
        self.set_mask |= ImageResolveFlags::FLAG_EXTENT;
        self
    }

    pub fn get_src_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageResolveFlags::FLAG_SRCSUBRESOURCE != ImageResolveFlags::FLAG_SRCSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.srcSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_src_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageResolveFlags::FLAG_SRCSUBRESOURCE != ImageResolveFlags::FLAG_SRCSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.srcSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_src_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & ImageResolveFlags::FLAG_SRCOFFSET != ImageResolveFlags::FLAG_SRCOFFSET { return None }
        Some(  unsafe { &*(&self.raw.srcOffset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_src_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & ImageResolveFlags::FLAG_SRCOFFSET != ImageResolveFlags::FLAG_SRCOFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.srcOffset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_dst_subresource<'a>(&'a self) -> Option<&'a ImageSubresourceLayers> {
        if self.set_mask & ImageResolveFlags::FLAG_DSTSUBRESOURCE != ImageResolveFlags::FLAG_DSTSUBRESOURCE { return None }
        Some(  unsafe { &*(&self.raw.dstSubresource as *const vks::VkImageSubresourceLayers as *const ImageSubresourceLayers) } )
    }

    pub fn get_dst_subresource_mut<'a>(&'a mut self) -> Option<&'a mut ImageSubresourceLayers> {
        if self.set_mask & ImageResolveFlags::FLAG_DSTSUBRESOURCE != ImageResolveFlags::FLAG_DSTSUBRESOURCE { return None }
        Some( unsafe { &mut *(&mut self.raw.dstSubresource as *mut  vks::VkImageSubresourceLayers as *mut ImageSubresourceLayers) } )
    }

    pub fn get_dst_offset<'a>(&'a self) -> Option<&'a Offset3d> {
        if self.set_mask & ImageResolveFlags::FLAG_DSTOFFSET != ImageResolveFlags::FLAG_DSTOFFSET { return None }
        Some(  unsafe { &*(&self.raw.dstOffset as *const vks::VkOffset3D as *const Offset3d) } )
    }

    pub fn get_dst_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset3d> {
        if self.set_mask & ImageResolveFlags::FLAG_DSTOFFSET != ImageResolveFlags::FLAG_DSTOFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.dstOffset as *mut  vks::VkOffset3D as *mut Offset3d) } )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent3d> {
        if self.set_mask & ImageResolveFlags::FLAG_EXTENT != ImageResolveFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent3D as *const Extent3d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent3d> {
        if self.set_mask & ImageResolveFlags::FLAG_EXTENT != ImageResolveFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent3D as *mut Extent3d) } )
    }

    pub fn build(self) -> ImageResolve {
        ImageResolve {
            raw: self.raw,
        }
    }
}


/// A `VkShaderModuleCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ShaderModuleCreateInfo<'s> {
    raw: vks::VkShaderModuleCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ShaderModuleCreateInfo<'s> {
    pub fn builder<'b>() -> ShaderModuleCreateInfoBuilder<'b> {
        ShaderModuleCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkShaderModuleCreateInfo) -> ShaderModuleCreateInfo<'s> {
        ShaderModuleCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ShaderModuleCreateFlags {
        ShaderModuleCreateFlags::from_bits(self.raw.flags)
            .expect("ShaderModuleCreateInfo::flags: error converting flags")
    }

    pub fn code<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCode as *const _, self.raw.codeSize as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ShaderModuleCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_code<'m, 'a>(&mut self, code: &'a [u32])
            where 'a: 's {
        self.raw.codeSize = code.len() * 4;
        self.raw.pCode = code.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkShaderModuleCreateInfo {
        &self.raw
    }
}

impl<'s> From<ShaderModuleCreateInfo<'s>> for vks::VkShaderModuleCreateInfo {
    fn from(f: ShaderModuleCreateInfo<'s>) -> vks::VkShaderModuleCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkShaderModuleCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ShaderModuleCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_CODESIZE			 = 0b1000;
        const FLAG_PCODE			 = 0b10000;
    }
}


/// A builder for `VkShaderModuleCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ShaderModuleCreateInfoBuilder<'b> {
    raw: vks::VkShaderModuleCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: ShaderModuleCreateInfoFlags,
}

impl<'b> ShaderModuleCreateInfoBuilder<'b> {
    pub fn new() -> ShaderModuleCreateInfoBuilder<'b> {
        ShaderModuleCreateInfoBuilder {
            raw: vks::VkShaderModuleCreateInfo::default(),
            _p: PhantomData,
            set_mask: ShaderModuleCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ShaderModuleCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ShaderModuleCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: ShaderModuleCreateFlags) -> ShaderModuleCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ShaderModuleCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn code<'m, 'a>(mut self, code: &'a [u32]) -> ShaderModuleCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.codeSize = code.len() * 4;
        self.set_mask |= ShaderModuleCreateInfoFlags::FLAG_CODESIZE;
        self.raw.pCode = code.as_ptr() as *const u32 as *const _;
        self.set_mask |= ShaderModuleCreateInfoFlags::FLAG_PCODE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ShaderModuleCreateInfoFlags::FLAG_PNEXT != ShaderModuleCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ShaderModuleCreateFlags> {
        if self.set_mask & ShaderModuleCreateInfoFlags::FLAG_FLAGS != ShaderModuleCreateInfoFlags::FLAG_FLAGS { return None }
        Some( ShaderModuleCreateFlags::from_bits(self.raw.flags)
            .expect("ShaderModuleCreateInfo::flags: error converting flags") )
    }

    pub fn get_code<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & ShaderModuleCreateInfoFlags::FLAG_PCODE != ShaderModuleCreateInfoFlags::FLAG_PCODE { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pCode as *const _, self.raw.codeSize as usize) } )
    }

    pub fn build(self) -> ShaderModuleCreateInfo<'b> {
        ShaderModuleCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetLayoutBinding`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetLayoutBinding<'s> {
    raw: vks::VkDescriptorSetLayoutBinding,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetLayoutBinding<'s> {
    pub fn builder<'b>() -> DescriptorSetLayoutBindingBuilder<'b> {
        DescriptorSetLayoutBindingBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetLayoutBinding) -> DescriptorSetLayoutBinding<'s> {
        DescriptorSetLayoutBinding { raw, _p: PhantomData }
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("DescriptorSetLayoutBinding::stage_flags: error converting flags")
    }

    pub fn immutable_samplers<'a>(&'a self) -> &'a vks::VkSampler {
        unsafe { &*(self.raw.pImmutableSamplers as *const _) }
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn set_immutable_samplers<'m, 'a>(&mut self, immutable_samplers: &'a [SamplerHandle])
            where 'a: 's {
        self.raw.pImmutableSamplers = immutable_samplers.as_ptr() as *const vks::VkSampler;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetLayoutBinding {
        &self.raw
    }
}

impl<'s> From<DescriptorSetLayoutBinding<'s>> for vks::VkDescriptorSetLayoutBinding {
    fn from(f: DescriptorSetLayoutBinding<'s>) -> vks::VkDescriptorSetLayoutBinding {
        f.raw
    }
}


/// Bitflags for `VkDescriptorSetLayoutBinding`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorSetLayoutBindingFlags: u32 {
        const FLAG_BINDING			 = 0b1;
        const FLAG_DESCRIPTORTYPE			 = 0b10;
        const FLAG_DESCRIPTORCOUNT			 = 0b100;
        const FLAG_STAGEFLAGS			 = 0b1000;
        const FLAG_PIMMUTABLESAMPLERS			 = 0b10000;
    }
}


/// A builder for `VkDescriptorSetLayoutBinding`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetLayoutBindingBuilder<'b> {
    raw: vks::VkDescriptorSetLayoutBinding,
    _p: PhantomData<&'b ()>, 
    set_mask: DescriptorSetLayoutBindingFlags,
}

impl<'b> DescriptorSetLayoutBindingBuilder<'b> {
    pub fn new() -> DescriptorSetLayoutBindingBuilder<'b> {
        DescriptorSetLayoutBindingBuilder {
            raw: vks::VkDescriptorSetLayoutBinding::default(),
            _p: PhantomData,
            set_mask: DescriptorSetLayoutBindingFlags::default(),
        }
    }

    pub fn binding<'m>(mut self, binding: u32) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.binding = binding.into();
        self.set_mask |= DescriptorSetLayoutBindingFlags::FLAG_BINDING;
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.descriptorType = descriptor_type.into();
        self.set_mask |= DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORTYPE;
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.descriptorCount = descriptor_count.into();
        self.set_mask |= DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORCOUNT;
        self
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> DescriptorSetLayoutBindingBuilder<'b> {
        self.raw.stageFlags = stage_flags.bits();
        self.set_mask |= DescriptorSetLayoutBindingFlags::FLAG_STAGEFLAGS;
        self
    }

    pub fn immutable_samplers<'m, 'a>(mut self, immutable_samplers: &'a [SamplerHandle]) -> DescriptorSetLayoutBindingBuilder<'b>
            where 'a: 'b {
        self.raw.pImmutableSamplers = immutable_samplers.as_ptr() as *const vks::VkSampler;
        self.set_mask |= DescriptorSetLayoutBindingFlags::FLAG_PIMMUTABLESAMPLERS;
        self
    }

    pub fn get_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorSetLayoutBindingFlags::FLAG_BINDING != DescriptorSetLayoutBindingFlags::FLAG_BINDING { return None }
        Some( self.raw.binding.into() )
    }

    pub fn get_descriptor_type<'a>(&'a self) -> Option<DescriptorType> {
        if self.set_mask & DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORTYPE != DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORTYPE { return None }
        Some( self.raw.descriptorType.into() )
    }

    pub fn get_descriptor_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORCOUNT != DescriptorSetLayoutBindingFlags::FLAG_DESCRIPTORCOUNT { return None }
        Some( self.raw.descriptorCount.into() )
    }

    pub fn get_stage_flags<'a>(&'a self) -> Option<ShaderStageFlags> {
        if self.set_mask & DescriptorSetLayoutBindingFlags::FLAG_STAGEFLAGS != DescriptorSetLayoutBindingFlags::FLAG_STAGEFLAGS { return None }
        Some( ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("DescriptorSetLayoutBinding::stage_flags: error converting flags") )
    }

    pub fn get_immutable_samplers<'a>(&'a self) -> Option<&'a vks::VkSampler> {
        if self.set_mask & DescriptorSetLayoutBindingFlags::FLAG_PIMMUTABLESAMPLERS != DescriptorSetLayoutBindingFlags::FLAG_PIMMUTABLESAMPLERS { return None }
        Some( unsafe { &*(self.raw.pImmutableSamplers as *const _) } )
    }

    pub fn build(self) -> DescriptorSetLayoutBinding<'b> {
        DescriptorSetLayoutBinding {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetLayoutCreateInfo<'s> {
    raw: vks::VkDescriptorSetLayoutCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetLayoutCreateInfo<'s> {
    pub fn builder<'b>() -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        DescriptorSetLayoutCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetLayoutCreateInfo) -> DescriptorSetLayoutCreateInfo<'s> {
        DescriptorSetLayoutCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorSetLayoutCreateFlags {
        DescriptorSetLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorSetLayoutCreateInfo::flags: error converting flags")
    }

    pub fn bindings<'a>(&'a self) -> &'a [DescriptorSetLayoutBinding] {
        unsafe { slice::from_raw_parts(self.raw.pBindings as *const _, self.raw.bindingCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorSetLayoutCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_bindings<'m, 'a>(&mut self, bindings: &'a [DescriptorSetLayoutBinding])
            where 'a: 's {
        assert!(self.raw.bindingCount == 0 || self.raw.bindingCount == bindings.len() as _, 
            "count inconsistency found when specifying `DescriptorSetLayoutCreateInfo::bindings`.");
        self.raw.bindingCount = bindings.len() as _;
        self.raw.pBindings = bindings.as_ptr() as *const vks::VkDescriptorSetLayoutBinding;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetLayoutCreateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorSetLayoutCreateInfo<'s>> for vks::VkDescriptorSetLayoutCreateInfo {
    fn from(f: DescriptorSetLayoutCreateInfo<'s>) -> vks::VkDescriptorSetLayoutCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkDescriptorSetLayoutCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorSetLayoutCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_BINDINGCOUNT			 = 0b1000;
        const FLAG_PBINDINGS			 = 0b10000;
    }
}


/// A builder for `VkDescriptorSetLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetLayoutCreateInfoBuilder<'b> {
    raw: vks::VkDescriptorSetLayoutCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: DescriptorSetLayoutCreateInfoFlags,
}

impl<'b> DescriptorSetLayoutCreateInfoBuilder<'b> {
    pub fn new() -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        DescriptorSetLayoutCreateInfoBuilder {
            raw: vks::VkDescriptorSetLayoutCreateInfo::default(),
            _p: PhantomData,
            set_mask: DescriptorSetLayoutCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DescriptorSetLayoutCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorSetLayoutCreateFlags) -> DescriptorSetLayoutCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DescriptorSetLayoutCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn bindings<'m, 'a>(mut self, bindings: &'a [DescriptorSetLayoutBinding]) -> DescriptorSetLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.bindingCount == 0 || self.raw.bindingCount == bindings.len() as _, 
            "count inconsistency found when specifying `DescriptorSetLayoutCreateInfo::bindings`.");
        self.raw.bindingCount = bindings.len() as _;
        self.set_mask |= DescriptorSetLayoutCreateInfoFlags::FLAG_BINDINGCOUNT;
        self.raw.pBindings = bindings.as_ptr() as *const vks::VkDescriptorSetLayoutBinding;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DescriptorSetLayoutCreateInfoFlags::FLAG_PNEXT != DescriptorSetLayoutCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DescriptorSetLayoutCreateFlags> {
        if self.set_mask & DescriptorSetLayoutCreateInfoFlags::FLAG_FLAGS != DescriptorSetLayoutCreateInfoFlags::FLAG_FLAGS { return None }
        Some( DescriptorSetLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorSetLayoutCreateInfo::flags: error converting flags") )
    }

    pub fn get_bindings<'a>(&'a self) -> Option<&'a [DescriptorSetLayoutBinding]> {
        if self.raw.pBindings.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pBindings as *const _, self.raw.bindingCount as usize) } )
    }

    pub fn build(self) -> DescriptorSetLayoutCreateInfo<'b> {
        DescriptorSetLayoutCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorPoolSize`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorPoolSize {
    raw: vks::VkDescriptorPoolSize,
}

impl DescriptorPoolSize {
    pub fn builder() -> DescriptorPoolSizeBuilder {
        DescriptorPoolSizeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorPoolSize) -> DescriptorPoolSize {
        DescriptorPoolSize { raw, }
    }

    pub fn type_of<'a>(&'a self) -> DescriptorType {
        self.raw.type_.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn set_type_of<'m>(&mut self, type_of: DescriptorType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorPoolSize {
        &self.raw
    }
}

impl From<DescriptorPoolSize> for vks::VkDescriptorPoolSize {
    fn from(f: DescriptorPoolSize) -> vks::VkDescriptorPoolSize {
        f.raw
    }
}


/// Bitflags for `VkDescriptorPoolSize`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorPoolSizeFlags: u32 {
        const FLAG_TYPE_			 = 0b1;
        const FLAG_DESCRIPTORCOUNT			 = 0b10;
    }
}


/// A builder for `VkDescriptorPoolSize`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorPoolSizeBuilder {
    raw: vks::VkDescriptorPoolSize,
    set_mask: DescriptorPoolSizeFlags,
}

impl DescriptorPoolSizeBuilder {
    pub fn new() -> DescriptorPoolSizeBuilder {
        DescriptorPoolSizeBuilder {
            raw: vks::VkDescriptorPoolSize::default(),
            set_mask: DescriptorPoolSizeFlags::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: DescriptorType) -> DescriptorPoolSizeBuilder {
        self.raw.type_ = type_of.into();
        self.set_mask |= DescriptorPoolSizeFlags::FLAG_TYPE_;
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorPoolSizeBuilder {
        self.raw.descriptorCount = descriptor_count.into();
        self.set_mask |= DescriptorPoolSizeFlags::FLAG_DESCRIPTORCOUNT;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> Option<DescriptorType> {
        if self.set_mask & DescriptorPoolSizeFlags::FLAG_TYPE_ != DescriptorPoolSizeFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_descriptor_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorPoolSizeFlags::FLAG_DESCRIPTORCOUNT != DescriptorPoolSizeFlags::FLAG_DESCRIPTORCOUNT { return None }
        Some( self.raw.descriptorCount.into() )
    }

    pub fn build(self) -> DescriptorPoolSize {
        DescriptorPoolSize {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorPoolCreateInfo<'s> {
    raw: vks::VkDescriptorPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorPoolCreateInfo<'s> {
    pub fn builder<'b>() -> DescriptorPoolCreateInfoBuilder<'b> {
        DescriptorPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorPoolCreateInfo) -> DescriptorPoolCreateInfo<'s> {
        DescriptorPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorPoolCreateFlags {
        DescriptorPoolCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorPoolCreateInfo::flags: error converting flags")
    }

    pub fn max_sets<'a>(&'a self) -> u32 {
        self.raw.maxSets.into()
    }

    pub fn pool_sizes<'a>(&'a self) -> &'a [DescriptorPoolSize] {
        unsafe { slice::from_raw_parts(self.raw.pPoolSizes as *const _, self.raw.poolSizeCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_max_sets<'m>(&mut self, max_sets: u32) {
        self.raw.maxSets = max_sets.into();
    }

    pub fn set_pool_sizes<'m, 'a>(&mut self, pool_sizes: &'a [DescriptorPoolSize])
            where 'a: 's {
        assert!(self.raw.poolSizeCount == 0 || self.raw.poolSizeCount == pool_sizes.len() as _, 
            "count inconsistency found when specifying `DescriptorPoolCreateInfo::pool_sizes`.");
        self.raw.poolSizeCount = pool_sizes.len() as _;
        self.raw.pPoolSizes = pool_sizes.as_ptr() as *const vks::VkDescriptorPoolSize;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorPoolCreateInfo<'s>> for vks::VkDescriptorPoolCreateInfo {
    fn from(f: DescriptorPoolCreateInfo<'s>) -> vks::VkDescriptorPoolCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkDescriptorPoolCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorPoolCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_MAXSETS			 = 0b1000;
        const FLAG_POOLSIZECOUNT			 = 0b10000;
        const FLAG_PPOOLSIZES			 = 0b100000;
    }
}


/// A builder for `VkDescriptorPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorPoolCreateInfoBuilder<'b> {
    raw: vks::VkDescriptorPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: DescriptorPoolCreateInfoFlags,
}

impl<'b> DescriptorPoolCreateInfoBuilder<'b> {
    pub fn new() -> DescriptorPoolCreateInfoBuilder<'b> {
        DescriptorPoolCreateInfoBuilder {
            raw: vks::VkDescriptorPoolCreateInfo::default(),
            _p: PhantomData,
            set_mask: DescriptorPoolCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DescriptorPoolCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorPoolCreateFlags) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DescriptorPoolCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn max_sets<'m>(mut self, max_sets: u32) -> DescriptorPoolCreateInfoBuilder<'b> {
        self.raw.maxSets = max_sets.into();
        self.set_mask |= DescriptorPoolCreateInfoFlags::FLAG_MAXSETS;
        self
    }

    pub fn pool_sizes<'m, 'a>(mut self, pool_sizes: &'a [DescriptorPoolSize]) -> DescriptorPoolCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.poolSizeCount == 0 || self.raw.poolSizeCount == pool_sizes.len() as _, 
            "count inconsistency found when specifying `DescriptorPoolCreateInfo::pool_sizes`.");
        self.raw.poolSizeCount = pool_sizes.len() as _;
        self.set_mask |= DescriptorPoolCreateInfoFlags::FLAG_POOLSIZECOUNT;
        self.raw.pPoolSizes = pool_sizes.as_ptr() as *const vks::VkDescriptorPoolSize;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DescriptorPoolCreateInfoFlags::FLAG_PNEXT != DescriptorPoolCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DescriptorPoolCreateFlags> {
        if self.set_mask & DescriptorPoolCreateInfoFlags::FLAG_FLAGS != DescriptorPoolCreateInfoFlags::FLAG_FLAGS { return None }
        Some( DescriptorPoolCreateFlags::from_bits(self.raw.flags)
            .expect("DescriptorPoolCreateInfo::flags: error converting flags") )
    }

    pub fn get_max_sets<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorPoolCreateInfoFlags::FLAG_MAXSETS != DescriptorPoolCreateInfoFlags::FLAG_MAXSETS { return None }
        Some( self.raw.maxSets.into() )
    }

    pub fn get_pool_sizes<'a>(&'a self) -> Option<&'a [DescriptorPoolSize]> {
        if self.raw.pPoolSizes.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pPoolSizes as *const _, self.raw.poolSizeCount as usize) } )
    }

    pub fn build(self) -> DescriptorPoolCreateInfo<'b> {
        DescriptorPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorSetAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorSetAllocateInfo<'s> {
    raw: vks::VkDescriptorSetAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorSetAllocateInfo<'s> {
    pub fn builder<'b>() -> DescriptorSetAllocateInfoBuilder<'b> {
        DescriptorSetAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorSetAllocateInfo) -> DescriptorSetAllocateInfo<'s> {
        DescriptorSetAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn descriptor_pool<'a>(&'a self) -> vks::VkDescriptorPool {
        self.raw.descriptorPool
    }

    pub fn set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.descriptorSetCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_descriptor_pool<'m, H>(&mut self, descriptor_pool: H)
            where H: Handle<Target=DescriptorPoolHandle> {
        self.raw.descriptorPool = descriptor_pool.handle().0;
    }

    pub fn set_set_layouts<'m, 'a>(&mut self, set_layouts: &'a [DescriptorSetLayoutHandle])
            where 'a: 's {
        assert!(self.raw.descriptorSetCount == 0 || self.raw.descriptorSetCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `DescriptorSetAllocateInfo::set_layouts`.");
        self.raw.descriptorSetCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorSetAllocateInfo {
        &self.raw
    }
}

impl<'s> From<DescriptorSetAllocateInfo<'s>> for vks::VkDescriptorSetAllocateInfo {
    fn from(f: DescriptorSetAllocateInfo<'s>) -> vks::VkDescriptorSetAllocateInfo {
        f.raw
    }
}


/// Bitflags for `VkDescriptorSetAllocateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorSetAllocateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DESCRIPTORPOOL			 = 0b100;
        const FLAG_DESCRIPTORSETCOUNT			 = 0b1000;
        const FLAG_PSETLAYOUTS			 = 0b10000;
    }
}


/// A builder for `VkDescriptorSetAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorSetAllocateInfoBuilder<'b> {
    raw: vks::VkDescriptorSetAllocateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: DescriptorSetAllocateInfoFlags,
}

impl<'b> DescriptorSetAllocateInfoBuilder<'b> {
    pub fn new() -> DescriptorSetAllocateInfoBuilder<'b> {
        DescriptorSetAllocateInfoBuilder {
            raw: vks::VkDescriptorSetAllocateInfo::default(),
            _p: PhantomData,
            set_mask: DescriptorSetAllocateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DescriptorSetAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DescriptorSetAllocateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn descriptor_pool<'m, H>(mut self, descriptor_pool: H) -> DescriptorSetAllocateInfoBuilder<'b>
            where H: Handle<Target=DescriptorPoolHandle> {
        self.raw.descriptorPool = descriptor_pool.handle().0;
        self.set_mask |= DescriptorSetAllocateInfoFlags::FLAG_DESCRIPTORPOOL;
        self
    }

    pub fn set_layouts<'m, 'a>(mut self, set_layouts: &'a [DescriptorSetLayoutHandle]) -> DescriptorSetAllocateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.descriptorSetCount == 0 || self.raw.descriptorSetCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `DescriptorSetAllocateInfo::set_layouts`.");
        self.raw.descriptorSetCount = set_layouts.len() as _;
        self.set_mask |= DescriptorSetAllocateInfoFlags::FLAG_DESCRIPTORSETCOUNT;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
        self.set_mask |= DescriptorSetAllocateInfoFlags::FLAG_PSETLAYOUTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DescriptorSetAllocateInfoFlags::FLAG_PNEXT != DescriptorSetAllocateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_descriptor_pool<'a>(&'a self) -> Option<vks::VkDescriptorPool> {
        if self.set_mask & DescriptorSetAllocateInfoFlags::FLAG_DESCRIPTORPOOL != DescriptorSetAllocateInfoFlags::FLAG_DESCRIPTORPOOL { return None }
        Some( self.raw.descriptorPool )
    }

    pub fn get_set_layouts<'a>(&'a self) -> Option<&'a [vks::VkDescriptorSetLayout]> {
        if self.set_mask & DescriptorSetAllocateInfoFlags::FLAG_PSETLAYOUTS != DescriptorSetAllocateInfoFlags::FLAG_PSETLAYOUTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.descriptorSetCount as usize) } )
    }

    pub fn build(self) -> DescriptorSetAllocateInfo<'b> {
        DescriptorSetAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSpecializationMapEntry`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SpecializationMapEntry {
    raw: vks::VkSpecializationMapEntry,
}

impl SpecializationMapEntry {
    pub fn builder() -> SpecializationMapEntryBuilder {
        SpecializationMapEntryBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSpecializationMapEntry) -> SpecializationMapEntry {
        SpecializationMapEntry { raw, }
    }

    pub fn constant_id<'a>(&'a self) -> u32 {
        self.raw.constantID.into()
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> usize {
        self.raw.size.into()
    }

    pub fn set_constant_id<'m>(&mut self, constant_id: u32) {
        self.raw.constantID = constant_id.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: usize) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkSpecializationMapEntry {
        &self.raw
    }
}

impl From<SpecializationMapEntry> for vks::VkSpecializationMapEntry {
    fn from(f: SpecializationMapEntry) -> vks::VkSpecializationMapEntry {
        f.raw
    }
}


/// Bitflags for `VkSpecializationMapEntry`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SpecializationMapEntryFlags: u32 {
        const FLAG_CONSTANTID			 = 0b1;
        const FLAG_OFFSET			 = 0b10;
        const FLAG_SIZE			 = 0b100;
    }
}


/// A builder for `VkSpecializationMapEntry`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SpecializationMapEntryBuilder {
    raw: vks::VkSpecializationMapEntry,
    set_mask: SpecializationMapEntryFlags,
}

impl SpecializationMapEntryBuilder {
    pub fn new() -> SpecializationMapEntryBuilder {
        SpecializationMapEntryBuilder {
            raw: vks::VkSpecializationMapEntry::default(),
            set_mask: SpecializationMapEntryFlags::default(),
        }
    }

    pub fn constant_id<'m>(mut self, constant_id: u32) -> SpecializationMapEntryBuilder {
        self.raw.constantID = constant_id.into();
        self.set_mask |= SpecializationMapEntryFlags::FLAG_CONSTANTID;
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> SpecializationMapEntryBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= SpecializationMapEntryFlags::FLAG_OFFSET;
        self
    }

    pub fn size<'m>(mut self, size: usize) -> SpecializationMapEntryBuilder {
        self.raw.size = size.into();
        self.set_mask |= SpecializationMapEntryFlags::FLAG_SIZE;
        self
    }

    pub fn get_constant_id<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SpecializationMapEntryFlags::FLAG_CONSTANTID != SpecializationMapEntryFlags::FLAG_CONSTANTID { return None }
        Some( self.raw.constantID.into() )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SpecializationMapEntryFlags::FLAG_OFFSET != SpecializationMapEntryFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<usize> {
        if self.set_mask & SpecializationMapEntryFlags::FLAG_SIZE != SpecializationMapEntryFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn build(self) -> SpecializationMapEntry {
        SpecializationMapEntry {
            raw: self.raw,
        }
    }
}


/// A `VkSpecializationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SpecializationInfo<'s> {
    raw: vks::VkSpecializationInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SpecializationInfo<'s> {
    pub fn builder<'b>() -> SpecializationInfoBuilder<'b> {
        SpecializationInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSpecializationInfo) -> SpecializationInfo<'s> {
        SpecializationInfo { raw, _p: PhantomData }
    }

    pub fn map_entries<'a>(&'a self) -> &'a [SpecializationMapEntry] {
        unsafe { slice::from_raw_parts(self.raw.pMapEntries as *const _, self.raw.mapEntryCount as usize) }
    }

    pub fn data_size<'a>(&'a self) -> usize {
        self.raw.dataSize.into()
    }

    pub fn data<'a>(&'a self) -> *const c_void {
        self.raw.pData
    }

    pub fn set_map_entries<'m, 'a>(&mut self, map_entries: &'a [SpecializationMapEntry])
            where 'a: 's {
        assert!(self.raw.mapEntryCount == 0 || self.raw.mapEntryCount == map_entries.len() as _, 
            "count inconsistency found when specifying `SpecializationInfo::map_entries`.");
        self.raw.mapEntryCount = map_entries.len() as _;
        self.raw.pMapEntries = map_entries.as_ptr() as *const vks::VkSpecializationMapEntry;
    }

    pub fn set_data_size<'m>(&mut self, data_size: usize) {
        self.raw.dataSize = data_size.into();
    }

    pub unsafe fn set_data<'m>(&mut self, data: *const c_void) {
        self.raw.pData = data;
    }

    pub fn as_raw(&self) -> &vks::VkSpecializationInfo {
        &self.raw
    }
}

impl<'s> From<SpecializationInfo<'s>> for vks::VkSpecializationInfo {
    fn from(f: SpecializationInfo<'s>) -> vks::VkSpecializationInfo {
        f.raw
    }
}


/// Bitflags for `VkSpecializationInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SpecializationInfoFlags: u32 {
        const FLAG_MAPENTRYCOUNT			 = 0b1;
        const FLAG_PMAPENTRIES			 = 0b10;
        const FLAG_DATASIZE			 = 0b100;
        const FLAG_PDATA			 = 0b1000;
    }
}


/// A builder for `VkSpecializationInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SpecializationInfoBuilder<'b> {
    raw: vks::VkSpecializationInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SpecializationInfoFlags,
}

impl<'b> SpecializationInfoBuilder<'b> {
    pub fn new() -> SpecializationInfoBuilder<'b> {
        SpecializationInfoBuilder {
            raw: vks::VkSpecializationInfo::default(),
            _p: PhantomData,
            set_mask: SpecializationInfoFlags::default(),
        }
    }

    pub fn map_entries<'m, 'a>(mut self, map_entries: &'a [SpecializationMapEntry]) -> SpecializationInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.mapEntryCount == 0 || self.raw.mapEntryCount == map_entries.len() as _, 
            "count inconsistency found when specifying `SpecializationInfo::map_entries`.");
        self.raw.mapEntryCount = map_entries.len() as _;
        self.set_mask |= SpecializationInfoFlags::FLAG_MAPENTRYCOUNT;
        self.raw.pMapEntries = map_entries.as_ptr() as *const vks::VkSpecializationMapEntry;
        self
    }

    pub fn data_size<'m>(mut self, data_size: usize) -> SpecializationInfoBuilder<'b> {
        self.raw.dataSize = data_size.into();
        self.set_mask |= SpecializationInfoFlags::FLAG_DATASIZE;
        self
    }

    pub unsafe fn data<'m>(mut self, data: *const c_void) -> SpecializationInfoBuilder<'b> {
        self.raw.pData = data;
        self.set_mask |= SpecializationInfoFlags::FLAG_PDATA;
        self
    }

    pub fn get_map_entries<'a>(&'a self) -> Option<&'a [SpecializationMapEntry]> {
        if self.raw.pMapEntries.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pMapEntries as *const _, self.raw.mapEntryCount as usize) } )
    }

    pub fn get_data_size<'a>(&'a self) -> Option<usize> {
        if self.set_mask & SpecializationInfoFlags::FLAG_DATASIZE != SpecializationInfoFlags::FLAG_DATASIZE { return None }
        Some( self.raw.dataSize.into() )
    }

    pub fn get_data<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SpecializationInfoFlags::FLAG_PDATA != SpecializationInfoFlags::FLAG_PDATA { return None }
        Some( self.raw.pData )
    }

    pub fn build(self) -> SpecializationInfo<'b> {
        SpecializationInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineShaderStageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineShaderStageCreateInfo<'s> {
    raw: vks::VkPipelineShaderStageCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineShaderStageCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineShaderStageCreateInfoBuilder<'b> {
        PipelineShaderStageCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineShaderStageCreateInfo) -> PipelineShaderStageCreateInfo<'s> {
        PipelineShaderStageCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineShaderStageCreateFlags {
        PipelineShaderStageCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineShaderStageCreateInfo::flags: error converting flags")
    }

    pub fn stage<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stage)
            .expect("PipelineShaderStageCreateInfo::stage: error converting flags")
    }

    pub fn module<'a>(&'a self) -> vks::VkShaderModule {
        self.raw.module
    }

    pub fn name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pName) }
    }

    pub fn specialization_info<'a>(&'a self) -> &'a SpecializationInfo {
        unsafe { &*(self.raw.pSpecializationInfo as *const vks::VkSpecializationInfo as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineShaderStageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stage<'m>(&mut self, stage: ShaderStageFlags) {
        self.raw.stage = stage.bits();
    }

    pub fn set_module<'m, H>(&mut self, module: H)
            where H: Handle<Target=ShaderModuleHandle> {
        self.raw.module = module.handle().0;
    }

    pub fn set_name<'m, 'a>(&mut self, name: &'a CStr)
            where 'a: 's {
        self.raw.pName = name.as_ptr();
    }

    pub fn set_specialization_info<'m, 'a>(&mut self, specialization_info: &'a SpecializationInfo)
            where 'a: 's {
        self.raw.pSpecializationInfo = specialization_info.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineShaderStageCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineShaderStageCreateInfo<'s>> for vks::VkPipelineShaderStageCreateInfo {
    fn from(f: PipelineShaderStageCreateInfo<'s>) -> vks::VkPipelineShaderStageCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineShaderStageCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineShaderStageCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_STAGE			 = 0b1000;
        const FLAG_MODULE			 = 0b10000;
        const FLAG_PNAME			 = 0b100000;
        const FLAG_PSPECIALIZATIONINFO			 = 0b1000000;
    }
}


/// A builder for `VkPipelineShaderStageCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineShaderStageCreateInfoBuilder<'b> {
    raw: vks::VkPipelineShaderStageCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineShaderStageCreateInfoFlags,
}

impl<'b> PipelineShaderStageCreateInfoBuilder<'b> {
    pub fn new() -> PipelineShaderStageCreateInfoBuilder<'b> {
        PipelineShaderStageCreateInfoBuilder {
            raw: vks::VkPipelineShaderStageCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineShaderStageCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineShaderStageCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineShaderStageCreateFlags) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineShaderStageCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn stage<'m>(mut self, stage: ShaderStageFlags) -> PipelineShaderStageCreateInfoBuilder<'b> {
        self.raw.stage = stage.bits();
        self.set_mask |= PipelineShaderStageCreateInfoFlags::FLAG_STAGE;
        self
    }

    pub fn module<'m, H>(mut self, module: H) -> PipelineShaderStageCreateInfoBuilder<'b>
            where H: Handle<Target=ShaderModuleHandle> {
        self.raw.module = module.handle().0;
        self.set_mask |= PipelineShaderStageCreateInfoFlags::FLAG_MODULE;
        self
    }

    pub fn name<'m, 'a>(mut self, name: &'a CStr) -> PipelineShaderStageCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pName = name.as_ptr();
        self.set_mask |= PipelineShaderStageCreateInfoFlags::FLAG_PNAME;
        self
    }

    pub fn specialization_info<'m, 'a>(mut self, specialization_info: &'a SpecializationInfo) -> PipelineShaderStageCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pSpecializationInfo = specialization_info.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineShaderStageCreateInfoFlags::FLAG_PNEXT != PipelineShaderStageCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineShaderStageCreateFlags> {
        if self.set_mask & PipelineShaderStageCreateInfoFlags::FLAG_FLAGS != PipelineShaderStageCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineShaderStageCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineShaderStageCreateInfo::flags: error converting flags") )
    }

    pub fn get_stage<'a>(&'a self) -> Option<ShaderStageFlags> {
        if self.set_mask & PipelineShaderStageCreateInfoFlags::FLAG_STAGE != PipelineShaderStageCreateInfoFlags::FLAG_STAGE { return None }
        Some( ShaderStageFlags::from_bits(self.raw.stage)
            .expect("PipelineShaderStageCreateInfo::stage: error converting flags") )
    }

    pub fn get_module<'a>(&'a self) -> Option<vks::VkShaderModule> {
        if self.set_mask & PipelineShaderStageCreateInfoFlags::FLAG_MODULE != PipelineShaderStageCreateInfoFlags::FLAG_MODULE { return None }
        Some( self.raw.module )
    }

    pub fn get_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & PipelineShaderStageCreateInfoFlags::FLAG_PNAME != PipelineShaderStageCreateInfoFlags::FLAG_PNAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.pName) } )
    }

    pub fn get_specialization_info<'a>(&'a self) -> Option<&'a SpecializationInfo> {
        if self.raw.pSpecializationInfo.is_null() { return None }
        Some( unsafe { &*(self.raw.pSpecializationInfo as *const vks::VkSpecializationInfo as *const _) } )
    }

    pub fn build(self) -> PipelineShaderStageCreateInfo<'b> {
        PipelineShaderStageCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkComputePipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ComputePipelineCreateInfo<'s> {
    raw: vks::VkComputePipelineCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> ComputePipelineCreateInfo<'s> {
    pub fn builder<'b>() -> ComputePipelineCreateInfoBuilder<'b> {
        ComputePipelineCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkComputePipelineCreateInfo) -> ComputePipelineCreateInfo<'s> {
        ComputePipelineCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("ComputePipelineCreateInfo::flags: error converting flags")
    }

    pub fn stage<'a>(&'a self) -> &'a PipelineShaderStageCreateInfo {
         unsafe { &*(&self.raw.stage as *const vks::VkPipelineShaderStageCreateInfo as *const PipelineShaderStageCreateInfo) }
    }

    pub fn stage_mut<'a>(&'a mut self) -> &'a mut PipelineShaderStageCreateInfo {
        unsafe { &mut *(&mut self.raw.stage as *mut  vks::VkPipelineShaderStageCreateInfo as *mut PipelineShaderStageCreateInfo) }
    }

    pub fn layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stage<'m>(&mut self, stage: PipelineShaderStageCreateInfo) {
        self.raw.stage = stage.raw;
    }

    pub fn set_layout<'m, H>(&mut self, layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
    }

    pub fn set_base_pipeline_handle<'m, H>(&mut self, base_pipeline_handle: H)
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
    }

    pub fn set_base_pipeline_index<'m>(&mut self, base_pipeline_index: i32) {
        self.raw.basePipelineIndex = base_pipeline_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkComputePipelineCreateInfo {
        &self.raw
    }
}

impl<'s> From<ComputePipelineCreateInfo<'s>> for vks::VkComputePipelineCreateInfo {
    fn from(f: ComputePipelineCreateInfo<'s>) -> vks::VkComputePipelineCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkComputePipelineCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ComputePipelineCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_STAGE			 = 0b1000;
        const FLAG_LAYOUT			 = 0b10000;
        const FLAG_BASEPIPELINEHANDLE			 = 0b100000;
        const FLAG_BASEPIPELINEINDEX			 = 0b1000000;
    }
}


/// A builder for `VkComputePipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ComputePipelineCreateInfoBuilder<'b> {
    raw: vks::VkComputePipelineCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: ComputePipelineCreateInfoFlags,
}

impl<'b> ComputePipelineCreateInfoBuilder<'b> {
    pub fn new() -> ComputePipelineCreateInfoBuilder<'b> {
        ComputePipelineCreateInfoBuilder {
            raw: vks::VkComputePipelineCreateInfo::default(),
            _p: PhantomData,
            set_mask: ComputePipelineCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCreateFlags) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn stage<'m>(mut self, stage: PipelineShaderStageCreateInfo) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.stage = stage.raw;
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_STAGE;
        self
    }

    pub fn layout<'m, H>(mut self, layout: H) -> ComputePipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_LAYOUT;
        self
    }

    pub fn base_pipeline_handle<'m, H>(mut self, base_pipeline_handle: H) -> ComputePipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE;
        self
    }

    pub fn base_pipeline_index<'m>(mut self, base_pipeline_index: i32) -> ComputePipelineCreateInfoBuilder<'b> {
        self.raw.basePipelineIndex = base_pipeline_index.into();
        self.set_mask |= ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_PNEXT != ComputePipelineCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineCreateFlags> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_FLAGS != ComputePipelineCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("ComputePipelineCreateInfo::flags: error converting flags") )
    }

    pub fn get_stage<'a>(&'a self) -> Option<&'a PipelineShaderStageCreateInfo> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_STAGE != ComputePipelineCreateInfoFlags::FLAG_STAGE { return None }
        Some(  unsafe { &*(&self.raw.stage as *const vks::VkPipelineShaderStageCreateInfo as *const PipelineShaderStageCreateInfo) } )
    }

    pub fn get_stage_mut<'a>(&'a mut self) -> Option<&'a mut PipelineShaderStageCreateInfo> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_STAGE != ComputePipelineCreateInfoFlags::FLAG_STAGE { return None }
        Some( unsafe { &mut *(&mut self.raw.stage as *mut  vks::VkPipelineShaderStageCreateInfo as *mut PipelineShaderStageCreateInfo) } )
    }

    pub fn get_layout<'a>(&'a self) -> Option<vks::VkPipelineLayout> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_LAYOUT != ComputePipelineCreateInfoFlags::FLAG_LAYOUT { return None }
        Some( self.raw.layout )
    }

    pub fn get_base_pipeline_handle<'a>(&'a self) -> Option<vks::VkPipeline> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE != ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE { return None }
        Some( self.raw.basePipelineHandle )
    }

    pub fn get_base_pipeline_index<'a>(&'a self) -> Option<i32> {
        if self.set_mask & ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX != ComputePipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX { return None }
        Some( self.raw.basePipelineIndex.into() )
    }

    pub fn build(self) -> ComputePipelineCreateInfo<'b> {
        ComputePipelineCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkVertexInputBindingDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct VertexInputBindingDescription {
    raw: vks::VkVertexInputBindingDescription,
}

impl VertexInputBindingDescription {
    pub fn builder() -> VertexInputBindingDescriptionBuilder {
        VertexInputBindingDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkVertexInputBindingDescription) -> VertexInputBindingDescription {
        VertexInputBindingDescription { raw, }
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn stride<'a>(&'a self) -> u32 {
        self.raw.stride.into()
    }

    pub fn input_rate<'a>(&'a self) -> VertexInputRate {
        self.raw.inputRate.into()
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_stride<'m>(&mut self, stride: u32) {
        self.raw.stride = stride.into();
    }

    pub fn set_input_rate<'m>(&mut self, input_rate: VertexInputRate) {
        self.raw.inputRate = input_rate.into();
    }

    pub fn as_raw(&self) -> &vks::VkVertexInputBindingDescription {
        &self.raw
    }
}

impl From<VertexInputBindingDescription> for vks::VkVertexInputBindingDescription {
    fn from(f: VertexInputBindingDescription) -> vks::VkVertexInputBindingDescription {
        f.raw
    }
}


/// Bitflags for `VkVertexInputBindingDescription`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct VertexInputBindingDescriptionFlags: u32 {
        const FLAG_BINDING			 = 0b1;
        const FLAG_STRIDE			 = 0b10;
        const FLAG_INPUTRATE			 = 0b100;
    }
}


/// A builder for `VkVertexInputBindingDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct VertexInputBindingDescriptionBuilder {
    raw: vks::VkVertexInputBindingDescription,
    set_mask: VertexInputBindingDescriptionFlags,
}

impl VertexInputBindingDescriptionBuilder {
    pub fn new() -> VertexInputBindingDescriptionBuilder {
        VertexInputBindingDescriptionBuilder {
            raw: vks::VkVertexInputBindingDescription::default(),
            set_mask: VertexInputBindingDescriptionFlags::default(),
        }
    }

    pub fn binding<'m>(mut self, binding: u32) -> VertexInputBindingDescriptionBuilder {
        self.raw.binding = binding.into();
        self.set_mask |= VertexInputBindingDescriptionFlags::FLAG_BINDING;
        self
    }

    pub fn stride<'m>(mut self, stride: u32) -> VertexInputBindingDescriptionBuilder {
        self.raw.stride = stride.into();
        self.set_mask |= VertexInputBindingDescriptionFlags::FLAG_STRIDE;
        self
    }

    pub fn input_rate<'m>(mut self, input_rate: VertexInputRate) -> VertexInputBindingDescriptionBuilder {
        self.raw.inputRate = input_rate.into();
        self.set_mask |= VertexInputBindingDescriptionFlags::FLAG_INPUTRATE;
        self
    }

    pub fn get_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & VertexInputBindingDescriptionFlags::FLAG_BINDING != VertexInputBindingDescriptionFlags::FLAG_BINDING { return None }
        Some( self.raw.binding.into() )
    }

    pub fn get_stride<'a>(&'a self) -> Option<u32> {
        if self.set_mask & VertexInputBindingDescriptionFlags::FLAG_STRIDE != VertexInputBindingDescriptionFlags::FLAG_STRIDE { return None }
        Some( self.raw.stride.into() )
    }

    pub fn get_input_rate<'a>(&'a self) -> Option<VertexInputRate> {
        if self.set_mask & VertexInputBindingDescriptionFlags::FLAG_INPUTRATE != VertexInputBindingDescriptionFlags::FLAG_INPUTRATE { return None }
        Some( self.raw.inputRate.into() )
    }

    pub fn build(self) -> VertexInputBindingDescription {
        VertexInputBindingDescription {
            raw: self.raw,
        }
    }
}


/// A `VkVertexInputAttributeDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct VertexInputAttributeDescription {
    raw: vks::VkVertexInputAttributeDescription,
}

impl VertexInputAttributeDescription {
    pub fn builder() -> VertexInputAttributeDescriptionBuilder {
        VertexInputAttributeDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkVertexInputAttributeDescription) -> VertexInputAttributeDescription {
        VertexInputAttributeDescription { raw, }
    }

    pub fn location<'a>(&'a self) -> u32 {
        self.raw.location.into()
    }

    pub fn binding<'a>(&'a self) -> u32 {
        self.raw.binding.into()
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn set_location<'m>(&mut self, location: u32) {
        self.raw.location = location.into();
    }

    pub fn set_binding<'m>(&mut self, binding: u32) {
        self.raw.binding = binding.into();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn as_raw(&self) -> &vks::VkVertexInputAttributeDescription {
        &self.raw
    }
}

impl From<VertexInputAttributeDescription> for vks::VkVertexInputAttributeDescription {
    fn from(f: VertexInputAttributeDescription) -> vks::VkVertexInputAttributeDescription {
        f.raw
    }
}


/// Bitflags for `VkVertexInputAttributeDescription`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct VertexInputAttributeDescriptionFlags: u32 {
        const FLAG_LOCATION			 = 0b1;
        const FLAG_BINDING			 = 0b10;
        const FLAG_FORMAT			 = 0b100;
        const FLAG_OFFSET			 = 0b1000;
    }
}


/// A builder for `VkVertexInputAttributeDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct VertexInputAttributeDescriptionBuilder {
    raw: vks::VkVertexInputAttributeDescription,
    set_mask: VertexInputAttributeDescriptionFlags,
}

impl VertexInputAttributeDescriptionBuilder {
    pub fn new() -> VertexInputAttributeDescriptionBuilder {
        VertexInputAttributeDescriptionBuilder {
            raw: vks::VkVertexInputAttributeDescription::default(),
            set_mask: VertexInputAttributeDescriptionFlags::default(),
        }
    }

    pub fn location<'m>(mut self, location: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.location = location.into();
        self.set_mask |= VertexInputAttributeDescriptionFlags::FLAG_LOCATION;
        self
    }

    pub fn binding<'m>(mut self, binding: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.binding = binding.into();
        self.set_mask |= VertexInputAttributeDescriptionFlags::FLAG_BINDING;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> VertexInputAttributeDescriptionBuilder {
        self.raw.format = format.into();
        self.set_mask |= VertexInputAttributeDescriptionFlags::FLAG_FORMAT;
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> VertexInputAttributeDescriptionBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= VertexInputAttributeDescriptionFlags::FLAG_OFFSET;
        self
    }

    pub fn get_location<'a>(&'a self) -> Option<u32> {
        if self.set_mask & VertexInputAttributeDescriptionFlags::FLAG_LOCATION != VertexInputAttributeDescriptionFlags::FLAG_LOCATION { return None }
        Some( self.raw.location.into() )
    }

    pub fn get_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & VertexInputAttributeDescriptionFlags::FLAG_BINDING != VertexInputAttributeDescriptionFlags::FLAG_BINDING { return None }
        Some( self.raw.binding.into() )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & VertexInputAttributeDescriptionFlags::FLAG_FORMAT != VertexInputAttributeDescriptionFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & VertexInputAttributeDescriptionFlags::FLAG_OFFSET != VertexInputAttributeDescriptionFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn build(self) -> VertexInputAttributeDescription {
        VertexInputAttributeDescription {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineVertexInputStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineVertexInputStateCreateInfo<'s> {
    raw: vks::VkPipelineVertexInputStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineVertexInputStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        PipelineVertexInputStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineVertexInputStateCreateInfo) -> PipelineVertexInputStateCreateInfo<'s> {
        PipelineVertexInputStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineVertexInputStateCreateFlags {
        PipelineVertexInputStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineVertexInputStateCreateInfo::flags: error converting flags")
    }

    pub fn vertex_binding_descriptions<'a>(&'a self) -> &'a [VertexInputBindingDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexBindingDescriptions as *const _, self.raw.vertexBindingDescriptionCount as usize) }
    }

    pub fn vertex_attribute_descriptions<'a>(&'a self) -> &'a [VertexInputAttributeDescription] {
        unsafe { slice::from_raw_parts(self.raw.pVertexAttributeDescriptions as *const _, self.raw.vertexAttributeDescriptionCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineVertexInputStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_vertex_binding_descriptions<'m, 'a>(&mut self, vertex_binding_descriptions: &'a [VertexInputBindingDescription])
            where 'a: 's {
        assert!(self.raw.vertexBindingDescriptionCount == 0 || self.raw.vertexBindingDescriptionCount == vertex_binding_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_binding_descriptions`.");
        self.raw.vertexBindingDescriptionCount = vertex_binding_descriptions.len() as _;
        self.raw.pVertexBindingDescriptions = vertex_binding_descriptions.as_ptr() as *const vks::VkVertexInputBindingDescription;
    }

    pub fn set_vertex_attribute_descriptions<'m, 'a>(&mut self, vertex_attribute_descriptions: &'a [VertexInputAttributeDescription])
            where 'a: 's {
        assert!(self.raw.vertexAttributeDescriptionCount == 0 || self.raw.vertexAttributeDescriptionCount == vertex_attribute_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_attribute_descriptions`.");
        self.raw.vertexAttributeDescriptionCount = vertex_attribute_descriptions.len() as _;
        self.raw.pVertexAttributeDescriptions = vertex_attribute_descriptions.as_ptr() as *const vks::VkVertexInputAttributeDescription;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineVertexInputStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineVertexInputStateCreateInfo<'s>> for vks::VkPipelineVertexInputStateCreateInfo {
    fn from(f: PipelineVertexInputStateCreateInfo<'s>) -> vks::VkPipelineVertexInputStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineVertexInputStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineVertexInputStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_VERTEXBINDINGDESCRIPTIONCOUNT			 = 0b1000;
        const FLAG_PVERTEXBINDINGDESCRIPTIONS			 = 0b10000;
        const FLAG_VERTEXATTRIBUTEDESCRIPTIONCOUNT			 = 0b100000;
        const FLAG_PVERTEXATTRIBUTEDESCRIPTIONS			 = 0b1000000;
    }
}


/// A builder for `VkPipelineVertexInputStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineVertexInputStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineVertexInputStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineVertexInputStateCreateInfoFlags,
}

impl<'b> PipelineVertexInputStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        PipelineVertexInputStateCreateInfoBuilder {
            raw: vks::VkPipelineVertexInputStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineVertexInputStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineVertexInputStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineVertexInputStateCreateFlags) -> PipelineVertexInputStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineVertexInputStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn vertex_binding_descriptions<'m, 'a>(mut self, vertex_binding_descriptions: &'a [VertexInputBindingDescription]) -> PipelineVertexInputStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.vertexBindingDescriptionCount == 0 || self.raw.vertexBindingDescriptionCount == vertex_binding_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_binding_descriptions`.");
        self.raw.vertexBindingDescriptionCount = vertex_binding_descriptions.len() as _;
        self.set_mask |= PipelineVertexInputStateCreateInfoFlags::FLAG_VERTEXBINDINGDESCRIPTIONCOUNT;
        self.raw.pVertexBindingDescriptions = vertex_binding_descriptions.as_ptr() as *const vks::VkVertexInputBindingDescription;
        self
    }

    pub fn vertex_attribute_descriptions<'m, 'a>(mut self, vertex_attribute_descriptions: &'a [VertexInputAttributeDescription]) -> PipelineVertexInputStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.vertexAttributeDescriptionCount == 0 || self.raw.vertexAttributeDescriptionCount == vertex_attribute_descriptions.len() as _, 
            "count inconsistency found when specifying `PipelineVertexInputStateCreateInfo::vertex_attribute_descriptions`.");
        self.raw.vertexAttributeDescriptionCount = vertex_attribute_descriptions.len() as _;
        self.set_mask |= PipelineVertexInputStateCreateInfoFlags::FLAG_VERTEXATTRIBUTEDESCRIPTIONCOUNT;
        self.raw.pVertexAttributeDescriptions = vertex_attribute_descriptions.as_ptr() as *const vks::VkVertexInputAttributeDescription;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineVertexInputStateCreateInfoFlags::FLAG_PNEXT != PipelineVertexInputStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineVertexInputStateCreateFlags> {
        if self.set_mask & PipelineVertexInputStateCreateInfoFlags::FLAG_FLAGS != PipelineVertexInputStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineVertexInputStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineVertexInputStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_vertex_binding_descriptions<'a>(&'a self) -> Option<&'a [VertexInputBindingDescription]> {
        if self.raw.pVertexBindingDescriptions.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pVertexBindingDescriptions as *const _, self.raw.vertexBindingDescriptionCount as usize) } )
    }

    pub fn get_vertex_attribute_descriptions<'a>(&'a self) -> Option<&'a [VertexInputAttributeDescription]> {
        if self.raw.pVertexAttributeDescriptions.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pVertexAttributeDescriptions as *const _, self.raw.vertexAttributeDescriptionCount as usize) } )
    }

    pub fn build(self) -> PipelineVertexInputStateCreateInfo<'b> {
        PipelineVertexInputStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineInputAssemblyStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineInputAssemblyStateCreateInfo<'s> {
    raw: vks::VkPipelineInputAssemblyStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineInputAssemblyStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        PipelineInputAssemblyStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineInputAssemblyStateCreateInfo) -> PipelineInputAssemblyStateCreateInfo<'s> {
        PipelineInputAssemblyStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineInputAssemblyStateCreateFlags {
        PipelineInputAssemblyStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineInputAssemblyStateCreateInfo::flags: error converting flags")
    }

    pub fn topology<'a>(&'a self) -> PrimitiveTopology {
        self.raw.topology.into()
    }

    pub fn primitive_restart_enable<'a>(&'a self) -> bool {
        self.raw.primitiveRestartEnable != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineInputAssemblyStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_topology<'m>(&mut self, topology: PrimitiveTopology) {
        self.raw.topology = topology.into();
    }

    pub fn set_primitive_restart_enable<'m>(&mut self, primitive_restart_enable: bool) {
        self.raw.primitiveRestartEnable = primitive_restart_enable as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineInputAssemblyStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineInputAssemblyStateCreateInfo<'s>> for vks::VkPipelineInputAssemblyStateCreateInfo {
    fn from(f: PipelineInputAssemblyStateCreateInfo<'s>) -> vks::VkPipelineInputAssemblyStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineInputAssemblyStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineInputAssemblyStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_TOPOLOGY			 = 0b1000;
        const FLAG_PRIMITIVERESTARTENABLE			 = 0b10000;
    }
}


/// A builder for `VkPipelineInputAssemblyStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineInputAssemblyStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineInputAssemblyStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineInputAssemblyStateCreateInfoFlags,
}

impl<'b> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        PipelineInputAssemblyStateCreateInfoBuilder {
            raw: vks::VkPipelineInputAssemblyStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineInputAssemblyStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineInputAssemblyStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineInputAssemblyStateCreateFlags) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineInputAssemblyStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn topology<'m>(mut self, topology: PrimitiveTopology) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.topology = topology.into();
        self.set_mask |= PipelineInputAssemblyStateCreateInfoFlags::FLAG_TOPOLOGY;
        self
    }

    pub fn primitive_restart_enable<'m>(mut self, primitive_restart_enable: bool) -> PipelineInputAssemblyStateCreateInfoBuilder<'b> {
        self.raw.primitiveRestartEnable = primitive_restart_enable as u32;
        self.set_mask |= PipelineInputAssemblyStateCreateInfoFlags::FLAG_PRIMITIVERESTARTENABLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineInputAssemblyStateCreateInfoFlags::FLAG_PNEXT != PipelineInputAssemblyStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineInputAssemblyStateCreateFlags> {
        if self.set_mask & PipelineInputAssemblyStateCreateInfoFlags::FLAG_FLAGS != PipelineInputAssemblyStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineInputAssemblyStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineInputAssemblyStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_topology<'a>(&'a self) -> Option<PrimitiveTopology> {
        if self.set_mask & PipelineInputAssemblyStateCreateInfoFlags::FLAG_TOPOLOGY != PipelineInputAssemblyStateCreateInfoFlags::FLAG_TOPOLOGY { return None }
        Some( self.raw.topology.into() )
    }

    pub fn get_primitive_restart_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineInputAssemblyStateCreateInfoFlags::FLAG_PRIMITIVERESTARTENABLE != PipelineInputAssemblyStateCreateInfoFlags::FLAG_PRIMITIVERESTARTENABLE { return None }
        Some( self.raw.primitiveRestartEnable != 0 )
    }

    pub fn build(self) -> PipelineInputAssemblyStateCreateInfo<'b> {
        PipelineInputAssemblyStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineTessellationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineTessellationStateCreateInfo<'s> {
    raw: vks::VkPipelineTessellationStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineTessellationStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineTessellationStateCreateInfoBuilder<'b> {
        PipelineTessellationStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineTessellationStateCreateInfo) -> PipelineTessellationStateCreateInfo<'s> {
        PipelineTessellationStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineTessellationStateCreateFlags {
        PipelineTessellationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineTessellationStateCreateInfo::flags: error converting flags")
    }

    pub fn patch_control_points<'a>(&'a self) -> u32 {
        self.raw.patchControlPoints.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineTessellationStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_patch_control_points<'m>(&mut self, patch_control_points: u32) {
        self.raw.patchControlPoints = patch_control_points.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineTessellationStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineTessellationStateCreateInfo<'s>> for vks::VkPipelineTessellationStateCreateInfo {
    fn from(f: PipelineTessellationStateCreateInfo<'s>) -> vks::VkPipelineTessellationStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineTessellationStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineTessellationStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PATCHCONTROLPOINTS			 = 0b1000;
    }
}


/// A builder for `VkPipelineTessellationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineTessellationStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineTessellationStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineTessellationStateCreateInfoFlags,
}

impl<'b> PipelineTessellationStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineTessellationStateCreateInfoBuilder<'b> {
        PipelineTessellationStateCreateInfoBuilder {
            raw: vks::VkPipelineTessellationStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineTessellationStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineTessellationStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineTessellationStateCreateFlags) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineTessellationStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn patch_control_points<'m>(mut self, patch_control_points: u32) -> PipelineTessellationStateCreateInfoBuilder<'b> {
        self.raw.patchControlPoints = patch_control_points.into();
        self.set_mask |= PipelineTessellationStateCreateInfoFlags::FLAG_PATCHCONTROLPOINTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineTessellationStateCreateInfoFlags::FLAG_PNEXT != PipelineTessellationStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineTessellationStateCreateFlags> {
        if self.set_mask & PipelineTessellationStateCreateInfoFlags::FLAG_FLAGS != PipelineTessellationStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineTessellationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineTessellationStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_patch_control_points<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PipelineTessellationStateCreateInfoFlags::FLAG_PATCHCONTROLPOINTS != PipelineTessellationStateCreateInfoFlags::FLAG_PATCHCONTROLPOINTS { return None }
        Some( self.raw.patchControlPoints.into() )
    }

    pub fn build(self) -> PipelineTessellationStateCreateInfo<'b> {
        PipelineTessellationStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineViewportStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportStateCreateInfo<'s> {
    raw: vks::VkPipelineViewportStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineViewportStateCreateInfoBuilder<'b> {
        PipelineViewportStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportStateCreateInfo) -> PipelineViewportStateCreateInfo<'s> {
        PipelineViewportStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineViewportStateCreateFlags {
        PipelineViewportStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineViewportStateCreateInfo::flags: error converting flags")
    }

    pub fn viewports<'a>(&'a self) -> &'a [Viewport] {
        unsafe { slice::from_raw_parts(self.raw.pViewports as *const _, self.raw.viewportCount as usize) }
    }

    pub fn scissors<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pScissors as *const _, self.raw.scissorCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineViewportStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_viewports<'m, 'a>(&mut self, viewports: &'a [Viewport])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewports.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::viewports`.");
        self.raw.viewportCount = viewports.len() as _;
        self.raw.pViewports = viewports.as_ptr() as *const vks::VkViewport;
    }

    pub fn set_scissors<'m, 'a>(&mut self, scissors: &'a [Rect2d])
            where 'a: 's {
        assert!(self.raw.scissorCount == 0 || self.raw.scissorCount == scissors.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::scissors`.");
        self.raw.scissorCount = scissors.len() as _;
        self.raw.pScissors = scissors.as_ptr() as *const vks::VkRect2D;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineViewportStateCreateInfo<'s>> for vks::VkPipelineViewportStateCreateInfo {
    fn from(f: PipelineViewportStateCreateInfo<'s>) -> vks::VkPipelineViewportStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineViewportStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineViewportStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_VIEWPORTCOUNT			 = 0b1000;
        const FLAG_PVIEWPORTS			 = 0b10000;
        const FLAG_SCISSORCOUNT			 = 0b100000;
        const FLAG_PSCISSORS			 = 0b1000000;
    }
}


/// A builder for `VkPipelineViewportStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineViewportStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineViewportStateCreateInfoFlags,
}

impl<'b> PipelineViewportStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineViewportStateCreateInfoBuilder<'b> {
        PipelineViewportStateCreateInfoBuilder {
            raw: vks::VkPipelineViewportStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineViewportStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineViewportStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineViewportStateCreateFlags) -> PipelineViewportStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineViewportStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn viewports<'m, 'a>(mut self, viewports: &'a [Viewport]) -> PipelineViewportStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewports.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::viewports`.");
        self.raw.viewportCount = viewports.len() as _;
        self.set_mask |= PipelineViewportStateCreateInfoFlags::FLAG_VIEWPORTCOUNT;
        self.raw.pViewports = viewports.as_ptr() as *const vks::VkViewport;
        self
    }

    pub fn scissors<'m, 'a>(mut self, scissors: &'a [Rect2d]) -> PipelineViewportStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.scissorCount == 0 || self.raw.scissorCount == scissors.len() as _, 
            "count inconsistency found when specifying `PipelineViewportStateCreateInfo::scissors`.");
        self.raw.scissorCount = scissors.len() as _;
        self.set_mask |= PipelineViewportStateCreateInfoFlags::FLAG_SCISSORCOUNT;
        self.raw.pScissors = scissors.as_ptr() as *const vks::VkRect2D;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineViewportStateCreateInfoFlags::FLAG_PNEXT != PipelineViewportStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineViewportStateCreateFlags> {
        if self.set_mask & PipelineViewportStateCreateInfoFlags::FLAG_FLAGS != PipelineViewportStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineViewportStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineViewportStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_viewports<'a>(&'a self) -> Option<&'a [Viewport]> {
        if self.raw.pViewports.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pViewports as *const _, self.raw.viewportCount as usize) } )
    }

    pub fn get_scissors<'a>(&'a self) -> Option<&'a [Rect2d]> {
        if self.raw.pScissors.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pScissors as *const _, self.raw.scissorCount as usize) } )
    }

    pub fn build(self) -> PipelineViewportStateCreateInfo<'b> {
        PipelineViewportStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineRasterizationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineRasterizationStateCreateInfo<'s> {
    raw: vks::VkPipelineRasterizationStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineRasterizationStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        PipelineRasterizationStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineRasterizationStateCreateInfo) -> PipelineRasterizationStateCreateInfo<'s> {
        PipelineRasterizationStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineRasterizationStateCreateFlags {
        PipelineRasterizationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineRasterizationStateCreateInfo::flags: error converting flags")
    }

    pub fn depth_clamp_enable<'a>(&'a self) -> bool {
        self.raw.depthClampEnable != 0
    }

    pub fn rasterizer_discard_enable<'a>(&'a self) -> bool {
        self.raw.rasterizerDiscardEnable != 0
    }

    pub fn polygon_mode<'a>(&'a self) -> PolygonMode {
        self.raw.polygonMode.into()
    }

    pub fn cull_mode<'a>(&'a self) -> CullModeFlags {
        CullModeFlags::from_bits(self.raw.cullMode)
            .expect("PipelineRasterizationStateCreateInfo::cull_mode: error converting flags")
    }

    pub fn front_face<'a>(&'a self) -> FrontFace {
        self.raw.frontFace.into()
    }

    pub fn depth_bias_enable<'a>(&'a self) -> bool {
        self.raw.depthBiasEnable != 0
    }

    pub fn depth_bias_constant_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasConstantFactor.into()
    }

    pub fn depth_bias_clamp<'a>(&'a self) -> f32 {
        self.raw.depthBiasClamp.into()
    }

    pub fn depth_bias_slope_factor<'a>(&'a self) -> f32 {
        self.raw.depthBiasSlopeFactor.into()
    }

    pub fn line_width<'a>(&'a self) -> f32 {
        self.raw.lineWidth.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineRasterizationStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_depth_clamp_enable<'m>(&mut self, depth_clamp_enable: bool) {
        self.raw.depthClampEnable = depth_clamp_enable as u32;
    }

    pub fn set_rasterizer_discard_enable<'m>(&mut self, rasterizer_discard_enable: bool) {
        self.raw.rasterizerDiscardEnable = rasterizer_discard_enable as u32;
    }

    pub fn set_polygon_mode<'m>(&mut self, polygon_mode: PolygonMode) {
        self.raw.polygonMode = polygon_mode.into();
    }

    pub fn set_cull_mode<'m>(&mut self, cull_mode: CullModeFlags) {
        self.raw.cullMode = cull_mode.bits();
    }

    pub fn set_front_face<'m>(&mut self, front_face: FrontFace) {
        self.raw.frontFace = front_face.into();
    }

    pub fn set_depth_bias_enable<'m>(&mut self, depth_bias_enable: bool) {
        self.raw.depthBiasEnable = depth_bias_enable as u32;
    }

    pub fn set_depth_bias_constant_factor<'m>(&mut self, depth_bias_constant_factor: f32) {
        self.raw.depthBiasConstantFactor = depth_bias_constant_factor.into();
    }

    pub fn set_depth_bias_clamp<'m>(&mut self, depth_bias_clamp: f32) {
        self.raw.depthBiasClamp = depth_bias_clamp.into();
    }

    pub fn set_depth_bias_slope_factor<'m>(&mut self, depth_bias_slope_factor: f32) {
        self.raw.depthBiasSlopeFactor = depth_bias_slope_factor.into();
    }

    pub fn set_line_width<'m>(&mut self, line_width: f32) {
        self.raw.lineWidth = line_width.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineRasterizationStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineRasterizationStateCreateInfo<'s>> for vks::VkPipelineRasterizationStateCreateInfo {
    fn from(f: PipelineRasterizationStateCreateInfo<'s>) -> vks::VkPipelineRasterizationStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineRasterizationStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineRasterizationStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DEPTHCLAMPENABLE			 = 0b1000;
        const FLAG_RASTERIZERDISCARDENABLE			 = 0b10000;
        const FLAG_POLYGONMODE			 = 0b100000;
        const FLAG_CULLMODE			 = 0b1000000;
        const FLAG_FRONTFACE			 = 0b10000000;
        const FLAG_DEPTHBIASENABLE			 = 0b100000000;
        const FLAG_DEPTHBIASCONSTANTFACTOR			 = 0b1000000000;
        const FLAG_DEPTHBIASCLAMP			 = 0b10000000000;
        const FLAG_DEPTHBIASSLOPEFACTOR			 = 0b100000000000;
        const FLAG_LINEWIDTH			 = 0b1000000000000;
    }
}


/// A builder for `VkPipelineRasterizationStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineRasterizationStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineRasterizationStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineRasterizationStateCreateInfoFlags,
}

impl<'b> PipelineRasterizationStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        PipelineRasterizationStateCreateInfoBuilder {
            raw: vks::VkPipelineRasterizationStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineRasterizationStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineRasterizationStateCreateFlags) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn depth_clamp_enable<'m>(mut self, depth_clamp_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthClampEnable = depth_clamp_enable as u32;
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHCLAMPENABLE;
        self
    }

    pub fn rasterizer_discard_enable<'m>(mut self, rasterizer_discard_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.rasterizerDiscardEnable = rasterizer_discard_enable as u32;
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_RASTERIZERDISCARDENABLE;
        self
    }

    pub fn polygon_mode<'m>(mut self, polygon_mode: PolygonMode) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.polygonMode = polygon_mode.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_POLYGONMODE;
        self
    }

    pub fn cull_mode<'m>(mut self, cull_mode: CullModeFlags) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.cullMode = cull_mode.bits();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_CULLMODE;
        self
    }

    pub fn front_face<'m>(mut self, front_face: FrontFace) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.frontFace = front_face.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_FRONTFACE;
        self
    }

    pub fn depth_bias_enable<'m>(mut self, depth_bias_enable: bool) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasEnable = depth_bias_enable as u32;
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASENABLE;
        self
    }

    pub fn depth_bias_constant_factor<'m>(mut self, depth_bias_constant_factor: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasConstantFactor = depth_bias_constant_factor.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCONSTANTFACTOR;
        self
    }

    pub fn depth_bias_clamp<'m>(mut self, depth_bias_clamp: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasClamp = depth_bias_clamp.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCLAMP;
        self
    }

    pub fn depth_bias_slope_factor<'m>(mut self, depth_bias_slope_factor: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.depthBiasSlopeFactor = depth_bias_slope_factor.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASSLOPEFACTOR;
        self
    }

    pub fn line_width<'m>(mut self, line_width: f32) -> PipelineRasterizationStateCreateInfoBuilder<'b> {
        self.raw.lineWidth = line_width.into();
        self.set_mask |= PipelineRasterizationStateCreateInfoFlags::FLAG_LINEWIDTH;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_PNEXT != PipelineRasterizationStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineRasterizationStateCreateFlags> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_FLAGS != PipelineRasterizationStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineRasterizationStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineRasterizationStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_depth_clamp_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHCLAMPENABLE != PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHCLAMPENABLE { return None }
        Some( self.raw.depthClampEnable != 0 )
    }

    pub fn get_rasterizer_discard_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_RASTERIZERDISCARDENABLE != PipelineRasterizationStateCreateInfoFlags::FLAG_RASTERIZERDISCARDENABLE { return None }
        Some( self.raw.rasterizerDiscardEnable != 0 )
    }

    pub fn get_polygon_mode<'a>(&'a self) -> Option<PolygonMode> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_POLYGONMODE != PipelineRasterizationStateCreateInfoFlags::FLAG_POLYGONMODE { return None }
        Some( self.raw.polygonMode.into() )
    }

    pub fn get_cull_mode<'a>(&'a self) -> Option<CullModeFlags> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_CULLMODE != PipelineRasterizationStateCreateInfoFlags::FLAG_CULLMODE { return None }
        Some( CullModeFlags::from_bits(self.raw.cullMode)
            .expect("PipelineRasterizationStateCreateInfo::cull_mode: error converting flags") )
    }

    pub fn get_front_face<'a>(&'a self) -> Option<FrontFace> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_FRONTFACE != PipelineRasterizationStateCreateInfoFlags::FLAG_FRONTFACE { return None }
        Some( self.raw.frontFace.into() )
    }

    pub fn get_depth_bias_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASENABLE != PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASENABLE { return None }
        Some( self.raw.depthBiasEnable != 0 )
    }

    pub fn get_depth_bias_constant_factor<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCONSTANTFACTOR != PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCONSTANTFACTOR { return None }
        Some( self.raw.depthBiasConstantFactor.into() )
    }

    pub fn get_depth_bias_clamp<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCLAMP != PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASCLAMP { return None }
        Some( self.raw.depthBiasClamp.into() )
    }

    pub fn get_depth_bias_slope_factor<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASSLOPEFACTOR != PipelineRasterizationStateCreateInfoFlags::FLAG_DEPTHBIASSLOPEFACTOR { return None }
        Some( self.raw.depthBiasSlopeFactor.into() )
    }

    pub fn get_line_width<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineRasterizationStateCreateInfoFlags::FLAG_LINEWIDTH != PipelineRasterizationStateCreateInfoFlags::FLAG_LINEWIDTH { return None }
        Some( self.raw.lineWidth.into() )
    }

    pub fn build(self) -> PipelineRasterizationStateCreateInfo<'b> {
        PipelineRasterizationStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineMultisampleStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineMultisampleStateCreateInfo<'s> {
    raw: vks::VkPipelineMultisampleStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineMultisampleStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        PipelineMultisampleStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineMultisampleStateCreateInfo) -> PipelineMultisampleStateCreateInfo<'s> {
        PipelineMultisampleStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineMultisampleStateCreateFlags {
        PipelineMultisampleStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineMultisampleStateCreateInfo::flags: error converting flags")
    }

    pub fn rasterization_samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.rasterizationSamples)
            .expect("PipelineMultisampleStateCreateInfo::rasterization_samples: error converting flags")
    }

    pub fn sample_shading_enable<'a>(&'a self) -> bool {
        self.raw.sampleShadingEnable != 0
    }

    pub fn min_sample_shading<'a>(&'a self) -> f32 {
        self.raw.minSampleShading.into()
    }

    pub fn sample_mask<'a>(&'a self) -> &'a u32 {
        unsafe { &*(self.raw.pSampleMask as *const _) }
    }

    pub fn alpha_to_coverage_enable<'a>(&'a self) -> bool {
        self.raw.alphaToCoverageEnable != 0
    }

    pub fn alpha_to_one_enable<'a>(&'a self) -> bool {
        self.raw.alphaToOneEnable != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineMultisampleStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_rasterization_samples<'m>(&mut self, rasterization_samples: SampleCountFlags) {
        self.raw.rasterizationSamples = rasterization_samples.bits();
    }

    pub fn set_sample_shading_enable<'m>(&mut self, sample_shading_enable: bool) {
        self.raw.sampleShadingEnable = sample_shading_enable as u32;
    }

    pub fn set_min_sample_shading<'m>(&mut self, min_sample_shading: f32) {
        self.raw.minSampleShading = min_sample_shading.into();
    }

    pub fn set_sample_mask<'m, 'a>(&mut self, sample_mask: &'a u32) {
        self.raw.pSampleMask = sample_mask;
    }

    pub fn set_alpha_to_coverage_enable<'m>(&mut self, alpha_to_coverage_enable: bool) {
        self.raw.alphaToCoverageEnable = alpha_to_coverage_enable as u32;
    }

    pub fn set_alpha_to_one_enable<'m>(&mut self, alpha_to_one_enable: bool) {
        self.raw.alphaToOneEnable = alpha_to_one_enable as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineMultisampleStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineMultisampleStateCreateInfo<'s>> for vks::VkPipelineMultisampleStateCreateInfo {
    fn from(f: PipelineMultisampleStateCreateInfo<'s>) -> vks::VkPipelineMultisampleStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineMultisampleStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineMultisampleStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_RASTERIZATIONSAMPLES			 = 0b1000;
        const FLAG_SAMPLESHADINGENABLE			 = 0b10000;
        const FLAG_MINSAMPLESHADING			 = 0b100000;
        const FLAG_PSAMPLEMASK			 = 0b1000000;
        const FLAG_ALPHATOCOVERAGEENABLE			 = 0b10000000;
        const FLAG_ALPHATOONEENABLE			 = 0b100000000;
    }
}


/// A builder for `VkPipelineMultisampleStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineMultisampleStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineMultisampleStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineMultisampleStateCreateInfoFlags,
}

impl<'b> PipelineMultisampleStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        PipelineMultisampleStateCreateInfoBuilder {
            raw: vks::VkPipelineMultisampleStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineMultisampleStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineMultisampleStateCreateFlags) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn rasterization_samples<'m>(mut self, rasterization_samples: SampleCountFlags) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.rasterizationSamples = rasterization_samples.bits();
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_RASTERIZATIONSAMPLES;
        self
    }

    pub fn sample_shading_enable<'m>(mut self, sample_shading_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.sampleShadingEnable = sample_shading_enable as u32;
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_SAMPLESHADINGENABLE;
        self
    }

    pub fn min_sample_shading<'m>(mut self, min_sample_shading: f32) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.minSampleShading = min_sample_shading.into();
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_MINSAMPLESHADING;
        self
    }

    pub fn sample_mask<'m, 'a>(mut self, sample_mask: &'a u32) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.pSampleMask = sample_mask;
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_PSAMPLEMASK;
        self
    }

    pub fn alpha_to_coverage_enable<'m>(mut self, alpha_to_coverage_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.alphaToCoverageEnable = alpha_to_coverage_enable as u32;
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOCOVERAGEENABLE;
        self
    }

    pub fn alpha_to_one_enable<'m>(mut self, alpha_to_one_enable: bool) -> PipelineMultisampleStateCreateInfoBuilder<'b> {
        self.raw.alphaToOneEnable = alpha_to_one_enable as u32;
        self.set_mask |= PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOONEENABLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_PNEXT != PipelineMultisampleStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineMultisampleStateCreateFlags> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_FLAGS != PipelineMultisampleStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineMultisampleStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineMultisampleStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_rasterization_samples<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_RASTERIZATIONSAMPLES != PipelineMultisampleStateCreateInfoFlags::FLAG_RASTERIZATIONSAMPLES { return None }
        Some( SampleCountFlags::from_bits(self.raw.rasterizationSamples)
            .expect("PipelineMultisampleStateCreateInfo::rasterization_samples: error converting flags") )
    }

    pub fn get_sample_shading_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_SAMPLESHADINGENABLE != PipelineMultisampleStateCreateInfoFlags::FLAG_SAMPLESHADINGENABLE { return None }
        Some( self.raw.sampleShadingEnable != 0 )
    }

    pub fn get_min_sample_shading<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_MINSAMPLESHADING != PipelineMultisampleStateCreateInfoFlags::FLAG_MINSAMPLESHADING { return None }
        Some( self.raw.minSampleShading.into() )
    }

    pub fn get_sample_mask<'a>(&'a self) -> Option<&'a u32> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_PSAMPLEMASK != PipelineMultisampleStateCreateInfoFlags::FLAG_PSAMPLEMASK { return None }
        Some( unsafe { &*(self.raw.pSampleMask as *const _) } )
    }

    pub fn get_alpha_to_coverage_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOCOVERAGEENABLE != PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOCOVERAGEENABLE { return None }
        Some( self.raw.alphaToCoverageEnable != 0 )
    }

    pub fn get_alpha_to_one_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOONEENABLE != PipelineMultisampleStateCreateInfoFlags::FLAG_ALPHATOONEENABLE { return None }
        Some( self.raw.alphaToOneEnable != 0 )
    }

    pub fn build(self) -> PipelineMultisampleStateCreateInfo<'b> {
        PipelineMultisampleStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineColorBlendAttachmentState`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendAttachmentState {
    raw: vks::VkPipelineColorBlendAttachmentState,
}

impl PipelineColorBlendAttachmentState {
    pub fn builder() -> PipelineColorBlendAttachmentStateBuilder {
        PipelineColorBlendAttachmentStateBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendAttachmentState) -> PipelineColorBlendAttachmentState {
        PipelineColorBlendAttachmentState { raw, }
    }

    pub fn blend_enable<'a>(&'a self) -> bool {
        self.raw.blendEnable != 0
    }

    pub fn src_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcColorBlendFactor.into()
    }

    pub fn dst_color_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstColorBlendFactor.into()
    }

    pub fn color_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.colorBlendOp.into()
    }

    pub fn src_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.srcAlphaBlendFactor.into()
    }

    pub fn dst_alpha_blend_factor<'a>(&'a self) -> BlendFactor {
        self.raw.dstAlphaBlendFactor.into()
    }

    pub fn alpha_blend_op<'a>(&'a self) -> BlendOp {
        self.raw.alphaBlendOp.into()
    }

    pub fn color_write_mask<'a>(&'a self) -> ColorComponentFlags {
        ColorComponentFlags::from_bits(self.raw.colorWriteMask)
            .expect("PipelineColorBlendAttachmentState::color_write_mask: error converting flags")
    }

    pub fn set_blend_enable<'m>(&mut self, blend_enable: bool) {
        self.raw.blendEnable = blend_enable as u32;
    }

    pub fn set_src_color_blend_factor<'m>(&mut self, src_color_blend_factor: BlendFactor) {
        self.raw.srcColorBlendFactor = src_color_blend_factor.into();
    }

    pub fn set_dst_color_blend_factor<'m>(&mut self, dst_color_blend_factor: BlendFactor) {
        self.raw.dstColorBlendFactor = dst_color_blend_factor.into();
    }

    pub fn set_color_blend_op<'m>(&mut self, color_blend_op: BlendOp) {
        self.raw.colorBlendOp = color_blend_op.into();
    }

    pub fn set_src_alpha_blend_factor<'m>(&mut self, src_alpha_blend_factor: BlendFactor) {
        self.raw.srcAlphaBlendFactor = src_alpha_blend_factor.into();
    }

    pub fn set_dst_alpha_blend_factor<'m>(&mut self, dst_alpha_blend_factor: BlendFactor) {
        self.raw.dstAlphaBlendFactor = dst_alpha_blend_factor.into();
    }

    pub fn set_alpha_blend_op<'m>(&mut self, alpha_blend_op: BlendOp) {
        self.raw.alphaBlendOp = alpha_blend_op.into();
    }

    pub fn set_color_write_mask<'m>(&mut self, color_write_mask: ColorComponentFlags) {
        self.raw.colorWriteMask = color_write_mask.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendAttachmentState {
        &self.raw
    }
}

impl From<PipelineColorBlendAttachmentState> for vks::VkPipelineColorBlendAttachmentState {
    fn from(f: PipelineColorBlendAttachmentState) -> vks::VkPipelineColorBlendAttachmentState {
        f.raw
    }
}


/// Bitflags for `VkPipelineColorBlendAttachmentState`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineColorBlendAttachmentStateFlags: u32 {
        const FLAG_BLENDENABLE			 = 0b1;
        const FLAG_SRCCOLORBLENDFACTOR			 = 0b10;
        const FLAG_DSTCOLORBLENDFACTOR			 = 0b100;
        const FLAG_COLORBLENDOP			 = 0b1000;
        const FLAG_SRCALPHABLENDFACTOR			 = 0b10000;
        const FLAG_DSTALPHABLENDFACTOR			 = 0b100000;
        const FLAG_ALPHABLENDOP			 = 0b1000000;
        const FLAG_COLORWRITEMASK			 = 0b10000000;
    }
}


/// A builder for `VkPipelineColorBlendAttachmentState`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendAttachmentStateBuilder {
    raw: vks::VkPipelineColorBlendAttachmentState,
    set_mask: PipelineColorBlendAttachmentStateFlags,
}

impl PipelineColorBlendAttachmentStateBuilder {
    pub fn new() -> PipelineColorBlendAttachmentStateBuilder {
        PipelineColorBlendAttachmentStateBuilder {
            raw: vks::VkPipelineColorBlendAttachmentState::default(),
            set_mask: PipelineColorBlendAttachmentStateFlags::default(),
        }
    }

    pub fn blend_enable<'m>(mut self, blend_enable: bool) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.blendEnable = blend_enable as u32;
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_BLENDENABLE;
        self
    }

    pub fn src_color_blend_factor<'m>(mut self, src_color_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.srcColorBlendFactor = src_color_blend_factor.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_SRCCOLORBLENDFACTOR;
        self
    }

    pub fn dst_color_blend_factor<'m>(mut self, dst_color_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.dstColorBlendFactor = dst_color_blend_factor.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_DSTCOLORBLENDFACTOR;
        self
    }

    pub fn color_blend_op<'m>(mut self, color_blend_op: BlendOp) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.colorBlendOp = color_blend_op.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_COLORBLENDOP;
        self
    }

    pub fn src_alpha_blend_factor<'m>(mut self, src_alpha_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.srcAlphaBlendFactor = src_alpha_blend_factor.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_SRCALPHABLENDFACTOR;
        self
    }

    pub fn dst_alpha_blend_factor<'m>(mut self, dst_alpha_blend_factor: BlendFactor) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.dstAlphaBlendFactor = dst_alpha_blend_factor.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_DSTALPHABLENDFACTOR;
        self
    }

    pub fn alpha_blend_op<'m>(mut self, alpha_blend_op: BlendOp) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.alphaBlendOp = alpha_blend_op.into();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_ALPHABLENDOP;
        self
    }

    pub fn color_write_mask<'m>(mut self, color_write_mask: ColorComponentFlags) -> PipelineColorBlendAttachmentStateBuilder {
        self.raw.colorWriteMask = color_write_mask.bits();
        self.set_mask |= PipelineColorBlendAttachmentStateFlags::FLAG_COLORWRITEMASK;
        self
    }

    pub fn get_blend_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_BLENDENABLE != PipelineColorBlendAttachmentStateFlags::FLAG_BLENDENABLE { return None }
        Some( self.raw.blendEnable != 0 )
    }

    pub fn get_src_color_blend_factor<'a>(&'a self) -> Option<BlendFactor> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_SRCCOLORBLENDFACTOR != PipelineColorBlendAttachmentStateFlags::FLAG_SRCCOLORBLENDFACTOR { return None }
        Some( self.raw.srcColorBlendFactor.into() )
    }

    pub fn get_dst_color_blend_factor<'a>(&'a self) -> Option<BlendFactor> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_DSTCOLORBLENDFACTOR != PipelineColorBlendAttachmentStateFlags::FLAG_DSTCOLORBLENDFACTOR { return None }
        Some( self.raw.dstColorBlendFactor.into() )
    }

    pub fn get_color_blend_op<'a>(&'a self) -> Option<BlendOp> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_COLORBLENDOP != PipelineColorBlendAttachmentStateFlags::FLAG_COLORBLENDOP { return None }
        Some( self.raw.colorBlendOp.into() )
    }

    pub fn get_src_alpha_blend_factor<'a>(&'a self) -> Option<BlendFactor> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_SRCALPHABLENDFACTOR != PipelineColorBlendAttachmentStateFlags::FLAG_SRCALPHABLENDFACTOR { return None }
        Some( self.raw.srcAlphaBlendFactor.into() )
    }

    pub fn get_dst_alpha_blend_factor<'a>(&'a self) -> Option<BlendFactor> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_DSTALPHABLENDFACTOR != PipelineColorBlendAttachmentStateFlags::FLAG_DSTALPHABLENDFACTOR { return None }
        Some( self.raw.dstAlphaBlendFactor.into() )
    }

    pub fn get_alpha_blend_op<'a>(&'a self) -> Option<BlendOp> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_ALPHABLENDOP != PipelineColorBlendAttachmentStateFlags::FLAG_ALPHABLENDOP { return None }
        Some( self.raw.alphaBlendOp.into() )
    }

    pub fn get_color_write_mask<'a>(&'a self) -> Option<ColorComponentFlags> {
        if self.set_mask & PipelineColorBlendAttachmentStateFlags::FLAG_COLORWRITEMASK != PipelineColorBlendAttachmentStateFlags::FLAG_COLORWRITEMASK { return None }
        Some( ColorComponentFlags::from_bits(self.raw.colorWriteMask)
            .expect("PipelineColorBlendAttachmentState::color_write_mask: error converting flags") )
    }

    pub fn build(self) -> PipelineColorBlendAttachmentState {
        PipelineColorBlendAttachmentState {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineColorBlendStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendStateCreateInfo<'s> {
    raw: vks::VkPipelineColorBlendStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineColorBlendStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        PipelineColorBlendStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendStateCreateInfo) -> PipelineColorBlendStateCreateInfo<'s> {
        PipelineColorBlendStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineColorBlendStateCreateFlags {
        PipelineColorBlendStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineColorBlendStateCreateInfo::flags: error converting flags")
    }

    pub fn logic_op_enable<'a>(&'a self) -> bool {
        self.raw.logicOpEnable != 0
    }

    pub fn logic_op<'a>(&'a self) -> LogicOp {
        self.raw.logicOp.into()
    }

    pub fn attachments<'a>(&'a self) -> &'a [PipelineColorBlendAttachmentState] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn blend_constants<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.blendConstants as *const _, 4 as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineColorBlendStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_logic_op_enable<'m>(&mut self, logic_op_enable: bool) {
        self.raw.logicOpEnable = logic_op_enable as u32;
    }

    pub fn set_logic_op<'m>(&mut self, logic_op: LogicOp) {
        self.raw.logicOp = logic_op.into();
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [PipelineColorBlendAttachmentState])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `PipelineColorBlendStateCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkPipelineColorBlendAttachmentState;
    }

    pub fn set_blend_constants<'m>(&mut self, blend_constants: [f32; 4]) {
        self.raw.blendConstants = blend_constants;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineColorBlendStateCreateInfo<'s>> for vks::VkPipelineColorBlendStateCreateInfo {
    fn from(f: PipelineColorBlendStateCreateInfo<'s>) -> vks::VkPipelineColorBlendStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineColorBlendStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineColorBlendStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_LOGICOPENABLE			 = 0b1000;
        const FLAG_LOGICOP			 = 0b10000;
        const FLAG_ATTACHMENTCOUNT			 = 0b100000;
        const FLAG_PATTACHMENTS			 = 0b1000000;
        const FLAG_BLENDCONSTANTS			 = 0b10000000;
    }
}


/// A builder for `VkPipelineColorBlendStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineColorBlendStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineColorBlendStateCreateInfoFlags,
}

impl<'b> PipelineColorBlendStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        PipelineColorBlendStateCreateInfoBuilder {
            raw: vks::VkPipelineColorBlendStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineColorBlendStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineColorBlendStateCreateFlags) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn logic_op_enable<'m>(mut self, logic_op_enable: bool) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.logicOpEnable = logic_op_enable as u32;
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOPENABLE;
        self
    }

    pub fn logic_op<'m>(mut self, logic_op: LogicOp) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.logicOp = logic_op.into();
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOP;
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [PipelineColorBlendAttachmentState]) -> PipelineColorBlendStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `PipelineColorBlendStateCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_ATTACHMENTCOUNT;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkPipelineColorBlendAttachmentState;
        self
    }

    pub fn blend_constants<'m>(mut self, blend_constants: [f32; 4]) -> PipelineColorBlendStateCreateInfoBuilder<'b> {
        self.raw.blendConstants = blend_constants;
        self.set_mask |= PipelineColorBlendStateCreateInfoFlags::FLAG_BLENDCONSTANTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineColorBlendStateCreateInfoFlags::FLAG_PNEXT != PipelineColorBlendStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineColorBlendStateCreateFlags> {
        if self.set_mask & PipelineColorBlendStateCreateInfoFlags::FLAG_FLAGS != PipelineColorBlendStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineColorBlendStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineColorBlendStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_logic_op_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOPENABLE != PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOPENABLE { return None }
        Some( self.raw.logicOpEnable != 0 )
    }

    pub fn get_logic_op<'a>(&'a self) -> Option<LogicOp> {
        if self.set_mask & PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOP != PipelineColorBlendStateCreateInfoFlags::FLAG_LOGICOP { return None }
        Some( self.raw.logicOp.into() )
    }

    pub fn get_attachments<'a>(&'a self) -> Option<&'a [PipelineColorBlendAttachmentState]> {
        if self.raw.pAttachments.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) } )
    }

    pub fn get_blend_constants<'a>(&'a self) -> Option<&[f32]> {
        if self.set_mask & PipelineColorBlendStateCreateInfoFlags::FLAG_BLENDCONSTANTS != PipelineColorBlendStateCreateInfoFlags::FLAG_BLENDCONSTANTS { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.blendConstants as *const _, 4 as usize) } )
    }

    pub fn build(self) -> PipelineColorBlendStateCreateInfo<'b> {
        PipelineColorBlendStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineDynamicStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDynamicStateCreateInfo<'s> {
    raw: vks::VkPipelineDynamicStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDynamicStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineDynamicStateCreateInfoBuilder<'b> {
        PipelineDynamicStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDynamicStateCreateInfo) -> PipelineDynamicStateCreateInfo<'s> {
        PipelineDynamicStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDynamicStateCreateFlags {
        PipelineDynamicStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDynamicStateCreateInfo::flags: error converting flags")
    }

    pub fn dynamic_states<'a>(&'a self) -> &'a [DynamicState] {
        unsafe { slice::from_raw_parts(self.raw.pDynamicStates as *const _, self.raw.dynamicStateCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDynamicStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_dynamic_states<'m, 'a>(&mut self, dynamic_states: &'a [DynamicState])
            where 'a: 's {
        assert!(self.raw.dynamicStateCount == 0 || self.raw.dynamicStateCount == dynamic_states.len() as _, 
            "count inconsistency found when specifying `PipelineDynamicStateCreateInfo::dynamic_states`.");
        self.raw.dynamicStateCount = dynamic_states.len() as _;
        self.raw.pDynamicStates = dynamic_states.as_ptr() as *const DynamicState as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDynamicStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineDynamicStateCreateInfo<'s>> for vks::VkPipelineDynamicStateCreateInfo {
    fn from(f: PipelineDynamicStateCreateInfo<'s>) -> vks::VkPipelineDynamicStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineDynamicStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineDynamicStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DYNAMICSTATECOUNT			 = 0b1000;
        const FLAG_PDYNAMICSTATES			 = 0b10000;
    }
}


/// A builder for `VkPipelineDynamicStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDynamicStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineDynamicStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineDynamicStateCreateInfoFlags,
}

impl<'b> PipelineDynamicStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineDynamicStateCreateInfoBuilder<'b> {
        PipelineDynamicStateCreateInfoBuilder {
            raw: vks::VkPipelineDynamicStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineDynamicStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDynamicStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineDynamicStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDynamicStateCreateFlags) -> PipelineDynamicStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineDynamicStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn dynamic_states<'m, 'a>(mut self, dynamic_states: &'a [DynamicState]) -> PipelineDynamicStateCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.dynamicStateCount == 0 || self.raw.dynamicStateCount == dynamic_states.len() as _, 
            "count inconsistency found when specifying `PipelineDynamicStateCreateInfo::dynamic_states`.");
        self.raw.dynamicStateCount = dynamic_states.len() as _;
        self.set_mask |= PipelineDynamicStateCreateInfoFlags::FLAG_DYNAMICSTATECOUNT;
        self.raw.pDynamicStates = dynamic_states.as_ptr() as *const DynamicState as *const _;
        self.set_mask |= PipelineDynamicStateCreateInfoFlags::FLAG_PDYNAMICSTATES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineDynamicStateCreateInfoFlags::FLAG_PNEXT != PipelineDynamicStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineDynamicStateCreateFlags> {
        if self.set_mask & PipelineDynamicStateCreateInfoFlags::FLAG_FLAGS != PipelineDynamicStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineDynamicStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDynamicStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_dynamic_states<'a>(&'a self) -> Option<&'a [DynamicState]> {
        if self.set_mask & PipelineDynamicStateCreateInfoFlags::FLAG_PDYNAMICSTATES != PipelineDynamicStateCreateInfoFlags::FLAG_PDYNAMICSTATES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pDynamicStates as *const _, self.raw.dynamicStateCount as usize) } )
    }

    pub fn build(self) -> PipelineDynamicStateCreateInfo<'b> {
        PipelineDynamicStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkStencilOpState`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct StencilOpState {
    raw: vks::VkStencilOpState,
}

impl StencilOpState {
    pub fn builder() -> StencilOpStateBuilder {
        StencilOpStateBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkStencilOpState) -> StencilOpState {
        StencilOpState { raw, }
    }

    pub fn fail_op<'a>(&'a self) -> StencilOp {
        self.raw.failOp.into()
    }

    pub fn pass_op<'a>(&'a self) -> StencilOp {
        self.raw.passOp.into()
    }

    pub fn depth_fail_op<'a>(&'a self) -> StencilOp {
        self.raw.depthFailOp.into()
    }

    pub fn compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn compare_mask<'a>(&'a self) -> u32 {
        self.raw.compareMask.into()
    }

    pub fn write_mask<'a>(&'a self) -> u32 {
        self.raw.writeMask.into()
    }

    pub fn reference<'a>(&'a self) -> u32 {
        self.raw.reference.into()
    }

    pub fn set_fail_op<'m>(&mut self, fail_op: StencilOp) {
        self.raw.failOp = fail_op.into();
    }

    pub fn set_pass_op<'m>(&mut self, pass_op: StencilOp) {
        self.raw.passOp = pass_op.into();
    }

    pub fn set_depth_fail_op<'m>(&mut self, depth_fail_op: StencilOp) {
        self.raw.depthFailOp = depth_fail_op.into();
    }

    pub fn set_compare_op<'m>(&mut self, compare_op: CompareOp) {
        self.raw.compareOp = compare_op.into();
    }

    pub fn set_compare_mask<'m>(&mut self, compare_mask: u32) {
        self.raw.compareMask = compare_mask.into();
    }

    pub fn set_write_mask<'m>(&mut self, write_mask: u32) {
        self.raw.writeMask = write_mask.into();
    }

    pub fn set_reference<'m>(&mut self, reference: u32) {
        self.raw.reference = reference.into();
    }

    pub fn as_raw(&self) -> &vks::VkStencilOpState {
        &self.raw
    }
}

impl From<StencilOpState> for vks::VkStencilOpState {
    fn from(f: StencilOpState) -> vks::VkStencilOpState {
        f.raw
    }
}


/// Bitflags for `VkStencilOpState`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct StencilOpStateFlags: u32 {
        const FLAG_FAILOP			 = 0b1;
        const FLAG_PASSOP			 = 0b10;
        const FLAG_DEPTHFAILOP			 = 0b100;
        const FLAG_COMPAREOP			 = 0b1000;
        const FLAG_COMPAREMASK			 = 0b10000;
        const FLAG_WRITEMASK			 = 0b100000;
        const FLAG_REFERENCE			 = 0b1000000;
    }
}


/// A builder for `VkStencilOpState`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct StencilOpStateBuilder {
    raw: vks::VkStencilOpState,
    set_mask: StencilOpStateFlags,
}

impl StencilOpStateBuilder {
    pub fn new() -> StencilOpStateBuilder {
        StencilOpStateBuilder {
            raw: vks::VkStencilOpState::default(),
            set_mask: StencilOpStateFlags::default(),
        }
    }

    pub fn fail_op<'m>(mut self, fail_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.failOp = fail_op.into();
        self.set_mask |= StencilOpStateFlags::FLAG_FAILOP;
        self
    }

    pub fn pass_op<'m>(mut self, pass_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.passOp = pass_op.into();
        self.set_mask |= StencilOpStateFlags::FLAG_PASSOP;
        self
    }

    pub fn depth_fail_op<'m>(mut self, depth_fail_op: StencilOp) -> StencilOpStateBuilder {
        self.raw.depthFailOp = depth_fail_op.into();
        self.set_mask |= StencilOpStateFlags::FLAG_DEPTHFAILOP;
        self
    }

    pub fn compare_op<'m>(mut self, compare_op: CompareOp) -> StencilOpStateBuilder {
        self.raw.compareOp = compare_op.into();
        self.set_mask |= StencilOpStateFlags::FLAG_COMPAREOP;
        self
    }

    pub fn compare_mask<'m>(mut self, compare_mask: u32) -> StencilOpStateBuilder {
        self.raw.compareMask = compare_mask.into();
        self.set_mask |= StencilOpStateFlags::FLAG_COMPAREMASK;
        self
    }

    pub fn write_mask<'m>(mut self, write_mask: u32) -> StencilOpStateBuilder {
        self.raw.writeMask = write_mask.into();
        self.set_mask |= StencilOpStateFlags::FLAG_WRITEMASK;
        self
    }

    pub fn reference<'m>(mut self, reference: u32) -> StencilOpStateBuilder {
        self.raw.reference = reference.into();
        self.set_mask |= StencilOpStateFlags::FLAG_REFERENCE;
        self
    }

    pub fn get_fail_op<'a>(&'a self) -> Option<StencilOp> {
        if self.set_mask & StencilOpStateFlags::FLAG_FAILOP != StencilOpStateFlags::FLAG_FAILOP { return None }
        Some( self.raw.failOp.into() )
    }

    pub fn get_pass_op<'a>(&'a self) -> Option<StencilOp> {
        if self.set_mask & StencilOpStateFlags::FLAG_PASSOP != StencilOpStateFlags::FLAG_PASSOP { return None }
        Some( self.raw.passOp.into() )
    }

    pub fn get_depth_fail_op<'a>(&'a self) -> Option<StencilOp> {
        if self.set_mask & StencilOpStateFlags::FLAG_DEPTHFAILOP != StencilOpStateFlags::FLAG_DEPTHFAILOP { return None }
        Some( self.raw.depthFailOp.into() )
    }

    pub fn get_compare_op<'a>(&'a self) -> Option<CompareOp> {
        if self.set_mask & StencilOpStateFlags::FLAG_COMPAREOP != StencilOpStateFlags::FLAG_COMPAREOP { return None }
        Some( self.raw.compareOp.into() )
    }

    pub fn get_compare_mask<'a>(&'a self) -> Option<u32> {
        if self.set_mask & StencilOpStateFlags::FLAG_COMPAREMASK != StencilOpStateFlags::FLAG_COMPAREMASK { return None }
        Some( self.raw.compareMask.into() )
    }

    pub fn get_write_mask<'a>(&'a self) -> Option<u32> {
        if self.set_mask & StencilOpStateFlags::FLAG_WRITEMASK != StencilOpStateFlags::FLAG_WRITEMASK { return None }
        Some( self.raw.writeMask.into() )
    }

    pub fn get_reference<'a>(&'a self) -> Option<u32> {
        if self.set_mask & StencilOpStateFlags::FLAG_REFERENCE != StencilOpStateFlags::FLAG_REFERENCE { return None }
        Some( self.raw.reference.into() )
    }

    pub fn build(self) -> StencilOpState {
        StencilOpState {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineDepthStencilStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDepthStencilStateCreateInfo<'s> {
    raw: vks::VkPipelineDepthStencilStateCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDepthStencilStateCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        PipelineDepthStencilStateCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDepthStencilStateCreateInfo) -> PipelineDepthStencilStateCreateInfo<'s> {
        PipelineDepthStencilStateCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDepthStencilStateCreateFlags {
        PipelineDepthStencilStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDepthStencilStateCreateInfo::flags: error converting flags")
    }

    pub fn depth_test_enable<'a>(&'a self) -> bool {
        self.raw.depthTestEnable != 0
    }

    pub fn depth_write_enable<'a>(&'a self) -> bool {
        self.raw.depthWriteEnable != 0
    }

    pub fn depth_compare_op<'a>(&'a self) -> CompareOp {
        self.raw.depthCompareOp.into()
    }

    pub fn depth_bounds_test_enable<'a>(&'a self) -> bool {
        self.raw.depthBoundsTestEnable != 0
    }

    pub fn stencil_test_enable<'a>(&'a self) -> bool {
        self.raw.stencilTestEnable != 0
    }

    pub fn front<'a>(&'a self) -> &'a StencilOpState {
         unsafe { &*(&self.raw.front as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn front_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.front as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn back<'a>(&'a self) -> &'a StencilOpState {
         unsafe { &*(&self.raw.back as *const vks::VkStencilOpState as *const StencilOpState) }
    }

    pub fn back_mut<'a>(&'a mut self) -> &'a mut StencilOpState {
        unsafe { &mut *(&mut self.raw.back as *mut  vks::VkStencilOpState as *mut StencilOpState) }
    }

    pub fn min_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.minDepthBounds.into()
    }

    pub fn max_depth_bounds<'a>(&'a self) -> f32 {
        self.raw.maxDepthBounds.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDepthStencilStateCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_depth_test_enable<'m>(&mut self, depth_test_enable: bool) {
        self.raw.depthTestEnable = depth_test_enable as u32;
    }

    pub fn set_depth_write_enable<'m>(&mut self, depth_write_enable: bool) {
        self.raw.depthWriteEnable = depth_write_enable as u32;
    }

    pub fn set_depth_compare_op<'m>(&mut self, depth_compare_op: CompareOp) {
        self.raw.depthCompareOp = depth_compare_op.into();
    }

    pub fn set_depth_bounds_test_enable<'m>(&mut self, depth_bounds_test_enable: bool) {
        self.raw.depthBoundsTestEnable = depth_bounds_test_enable as u32;
    }

    pub fn set_stencil_test_enable<'m>(&mut self, stencil_test_enable: bool) {
        self.raw.stencilTestEnable = stencil_test_enable as u32;
    }

    pub fn set_front<'m>(&mut self, front: StencilOpState) {
        self.raw.front = front.raw;
    }

    pub fn set_back<'m>(&mut self, back: StencilOpState) {
        self.raw.back = back.raw;
    }

    pub fn set_min_depth_bounds<'m>(&mut self, min_depth_bounds: f32) {
        self.raw.minDepthBounds = min_depth_bounds.into();
    }

    pub fn set_max_depth_bounds<'m>(&mut self, max_depth_bounds: f32) {
        self.raw.maxDepthBounds = max_depth_bounds.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDepthStencilStateCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineDepthStencilStateCreateInfo<'s>> for vks::VkPipelineDepthStencilStateCreateInfo {
    fn from(f: PipelineDepthStencilStateCreateInfo<'s>) -> vks::VkPipelineDepthStencilStateCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineDepthStencilStateCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineDepthStencilStateCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DEPTHTESTENABLE			 = 0b1000;
        const FLAG_DEPTHWRITEENABLE			 = 0b10000;
        const FLAG_DEPTHCOMPAREOP			 = 0b100000;
        const FLAG_DEPTHBOUNDSTESTENABLE			 = 0b1000000;
        const FLAG_STENCILTESTENABLE			 = 0b10000000;
        const FLAG_FRONT			 = 0b100000000;
        const FLAG_BACK			 = 0b1000000000;
        const FLAG_MINDEPTHBOUNDS			 = 0b10000000000;
        const FLAG_MAXDEPTHBOUNDS			 = 0b100000000000;
    }
}


/// A builder for `VkPipelineDepthStencilStateCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDepthStencilStateCreateInfoBuilder<'b> {
    raw: vks::VkPipelineDepthStencilStateCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineDepthStencilStateCreateInfoFlags,
}

impl<'b> PipelineDepthStencilStateCreateInfoBuilder<'b> {
    pub fn new() -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        PipelineDepthStencilStateCreateInfoBuilder {
            raw: vks::VkPipelineDepthStencilStateCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineDepthStencilStateCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDepthStencilStateCreateFlags) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn depth_test_enable<'m>(mut self, depth_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthTestEnable = depth_test_enable as u32;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHTESTENABLE;
        self
    }

    pub fn depth_write_enable<'m>(mut self, depth_write_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthWriteEnable = depth_write_enable as u32;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHWRITEENABLE;
        self
    }

    pub fn depth_compare_op<'m>(mut self, depth_compare_op: CompareOp) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthCompareOp = depth_compare_op.into();
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHCOMPAREOP;
        self
    }

    pub fn depth_bounds_test_enable<'m>(mut self, depth_bounds_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.depthBoundsTestEnable = depth_bounds_test_enable as u32;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHBOUNDSTESTENABLE;
        self
    }

    pub fn stencil_test_enable<'m>(mut self, stencil_test_enable: bool) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.stencilTestEnable = stencil_test_enable as u32;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_STENCILTESTENABLE;
        self
    }

    pub fn front<'m>(mut self, front: StencilOpState) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.front = front.raw;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_FRONT;
        self
    }

    pub fn back<'m>(mut self, back: StencilOpState) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.back = back.raw;
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_BACK;
        self
    }

    pub fn min_depth_bounds<'m>(mut self, min_depth_bounds: f32) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.minDepthBounds = min_depth_bounds.into();
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_MINDEPTHBOUNDS;
        self
    }

    pub fn max_depth_bounds<'m>(mut self, max_depth_bounds: f32) -> PipelineDepthStencilStateCreateInfoBuilder<'b> {
        self.raw.maxDepthBounds = max_depth_bounds.into();
        self.set_mask |= PipelineDepthStencilStateCreateInfoFlags::FLAG_MAXDEPTHBOUNDS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_PNEXT != PipelineDepthStencilStateCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineDepthStencilStateCreateFlags> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_FLAGS != PipelineDepthStencilStateCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineDepthStencilStateCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineDepthStencilStateCreateInfo::flags: error converting flags") )
    }

    pub fn get_depth_test_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHTESTENABLE != PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHTESTENABLE { return None }
        Some( self.raw.depthTestEnable != 0 )
    }

    pub fn get_depth_write_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHWRITEENABLE != PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHWRITEENABLE { return None }
        Some( self.raw.depthWriteEnable != 0 )
    }

    pub fn get_depth_compare_op<'a>(&'a self) -> Option<CompareOp> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHCOMPAREOP != PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHCOMPAREOP { return None }
        Some( self.raw.depthCompareOp.into() )
    }

    pub fn get_depth_bounds_test_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHBOUNDSTESTENABLE != PipelineDepthStencilStateCreateInfoFlags::FLAG_DEPTHBOUNDSTESTENABLE { return None }
        Some( self.raw.depthBoundsTestEnable != 0 )
    }

    pub fn get_stencil_test_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_STENCILTESTENABLE != PipelineDepthStencilStateCreateInfoFlags::FLAG_STENCILTESTENABLE { return None }
        Some( self.raw.stencilTestEnable != 0 )
    }

    pub fn get_front<'a>(&'a self) -> Option<&'a StencilOpState> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_FRONT != PipelineDepthStencilStateCreateInfoFlags::FLAG_FRONT { return None }
        Some(  unsafe { &*(&self.raw.front as *const vks::VkStencilOpState as *const StencilOpState) } )
    }

    pub fn get_front_mut<'a>(&'a mut self) -> Option<&'a mut StencilOpState> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_FRONT != PipelineDepthStencilStateCreateInfoFlags::FLAG_FRONT { return None }
        Some( unsafe { &mut *(&mut self.raw.front as *mut  vks::VkStencilOpState as *mut StencilOpState) } )
    }

    pub fn get_back<'a>(&'a self) -> Option<&'a StencilOpState> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_BACK != PipelineDepthStencilStateCreateInfoFlags::FLAG_BACK { return None }
        Some(  unsafe { &*(&self.raw.back as *const vks::VkStencilOpState as *const StencilOpState) } )
    }

    pub fn get_back_mut<'a>(&'a mut self) -> Option<&'a mut StencilOpState> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_BACK != PipelineDepthStencilStateCreateInfoFlags::FLAG_BACK { return None }
        Some( unsafe { &mut *(&mut self.raw.back as *mut  vks::VkStencilOpState as *mut StencilOpState) } )
    }

    pub fn get_min_depth_bounds<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_MINDEPTHBOUNDS != PipelineDepthStencilStateCreateInfoFlags::FLAG_MINDEPTHBOUNDS { return None }
        Some( self.raw.minDepthBounds.into() )
    }

    pub fn get_max_depth_bounds<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PipelineDepthStencilStateCreateInfoFlags::FLAG_MAXDEPTHBOUNDS != PipelineDepthStencilStateCreateInfoFlags::FLAG_MAXDEPTHBOUNDS { return None }
        Some( self.raw.maxDepthBounds.into() )
    }

    pub fn build(self) -> PipelineDepthStencilStateCreateInfo<'b> {
        PipelineDepthStencilStateCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkGraphicsPipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct GraphicsPipelineCreateInfo<'s> {
    raw: vks::VkGraphicsPipelineCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> GraphicsPipelineCreateInfo<'s> {
    pub fn builder<'b>() -> GraphicsPipelineCreateInfoBuilder<'b> {
        GraphicsPipelineCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkGraphicsPipelineCreateInfo) -> GraphicsPipelineCreateInfo<'s> {
        GraphicsPipelineCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCreateFlags {
        PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("GraphicsPipelineCreateInfo::flags: error converting flags")
    }

    pub fn stages<'a>(&'a self) -> &'a [PipelineShaderStageCreateInfo] {
        unsafe { slice::from_raw_parts(self.raw.pStages as *const _, self.raw.stageCount as usize) }
    }

    pub fn vertex_input_state<'a>(&'a self) -> &'a PipelineVertexInputStateCreateInfo {
        unsafe { &*(self.raw.pVertexInputState as *const vks::VkPipelineVertexInputStateCreateInfo as *const _) }
    }

    pub fn input_assembly_state<'a>(&'a self) -> &'a PipelineInputAssemblyStateCreateInfo {
        unsafe { &*(self.raw.pInputAssemblyState as *const vks::VkPipelineInputAssemblyStateCreateInfo as *const _) }
    }

    pub fn tessellation_state<'a>(&'a self) -> &'a PipelineTessellationStateCreateInfo {
        unsafe { &*(self.raw.pTessellationState as *const vks::VkPipelineTessellationStateCreateInfo as *const _) }
    }

    pub fn viewport_state<'a>(&'a self) -> &'a PipelineViewportStateCreateInfo {
        unsafe { &*(self.raw.pViewportState as *const vks::VkPipelineViewportStateCreateInfo as *const _) }
    }

    pub fn rasterization_state<'a>(&'a self) -> &'a PipelineRasterizationStateCreateInfo {
        unsafe { &*(self.raw.pRasterizationState as *const vks::VkPipelineRasterizationStateCreateInfo as *const _) }
    }

    pub fn multisample_state<'a>(&'a self) -> &'a PipelineMultisampleStateCreateInfo {
        unsafe { &*(self.raw.pMultisampleState as *const vks::VkPipelineMultisampleStateCreateInfo as *const _) }
    }

    pub fn depth_stencil_state<'a>(&'a self) -> &'a PipelineDepthStencilStateCreateInfo {
        unsafe { &*(self.raw.pDepthStencilState as *const vks::VkPipelineDepthStencilStateCreateInfo as *const _) }
    }

    pub fn color_blend_state<'a>(&'a self) -> &'a PipelineColorBlendStateCreateInfo {
        unsafe { &*(self.raw.pColorBlendState as *const vks::VkPipelineColorBlendStateCreateInfo as *const _) }
    }

    pub fn dynamic_state<'a>(&'a self) -> &'a PipelineDynamicStateCreateInfo {
        unsafe { &*(self.raw.pDynamicState as *const vks::VkPipelineDynamicStateCreateInfo as *const _) }
    }

    pub fn layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.layout
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn base_pipeline_handle<'a>(&'a self) -> vks::VkPipeline {
        self.raw.basePipelineHandle
    }

    pub fn base_pipeline_index<'a>(&'a self) -> i32 {
        self.raw.basePipelineIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_stages<'m, 'a>(&mut self, stages: &'a [PipelineShaderStageCreateInfo])
            where 'a: 's {
        assert!(self.raw.stageCount == 0 || self.raw.stageCount == stages.len() as _, 
            "count inconsistency found when specifying `GraphicsPipelineCreateInfo::stages`.");
        self.raw.stageCount = stages.len() as _;
        self.raw.pStages = stages.as_ptr() as *const vks::VkPipelineShaderStageCreateInfo;
    }

    pub fn set_vertex_input_state<'m, 'a>(&mut self, vertex_input_state: &'a PipelineVertexInputStateCreateInfo)
            where 'a: 's {
        self.raw.pVertexInputState = vertex_input_state.as_raw();
    }

    pub fn set_input_assembly_state<'m, 'a>(&mut self, input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo)
            where 'a: 's {
        self.raw.pInputAssemblyState = input_assembly_state.as_raw();
    }

    pub fn set_tessellation_state<'m, 'a>(&mut self, tessellation_state: &'a PipelineTessellationStateCreateInfo)
            where 'a: 's {
        self.raw.pTessellationState = tessellation_state.as_raw();
    }

    pub fn set_viewport_state<'m, 'a>(&mut self, viewport_state: &'a PipelineViewportStateCreateInfo)
            where 'a: 's {
        self.raw.pViewportState = viewport_state.as_raw();
    }

    pub fn set_rasterization_state<'m, 'a>(&mut self, rasterization_state: &'a PipelineRasterizationStateCreateInfo)
            where 'a: 's {
        self.raw.pRasterizationState = rasterization_state.as_raw();
    }

    pub fn set_multisample_state<'m, 'a>(&mut self, multisample_state: &'a PipelineMultisampleStateCreateInfo)
            where 'a: 's {
        self.raw.pMultisampleState = multisample_state.as_raw();
    }

    pub fn set_depth_stencil_state<'m, 'a>(&mut self, depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo)
            where 'a: 's {
        self.raw.pDepthStencilState = depth_stencil_state.as_raw();
    }

    pub fn set_color_blend_state<'m, 'a>(&mut self, color_blend_state: &'a PipelineColorBlendStateCreateInfo)
            where 'a: 's {
        self.raw.pColorBlendState = color_blend_state.as_raw();
    }

    pub fn set_dynamic_state<'m, 'a>(&mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo)
            where 'a: 's {
        self.raw.pDynamicState = dynamic_state.as_raw();
    }

    pub fn set_layout<'m, H>(&mut self, layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_subpass<'m>(&mut self, subpass: u32) {
        self.raw.subpass = subpass.into();
    }

    pub fn set_base_pipeline_handle<'m, H>(&mut self, base_pipeline_handle: H)
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
    }

    pub fn set_base_pipeline_index<'m>(&mut self, base_pipeline_index: i32) {
        self.raw.basePipelineIndex = base_pipeline_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkGraphicsPipelineCreateInfo {
        &self.raw
    }
}

impl<'s> From<GraphicsPipelineCreateInfo<'s>> for vks::VkGraphicsPipelineCreateInfo {
    fn from(f: GraphicsPipelineCreateInfo<'s>) -> vks::VkGraphicsPipelineCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkGraphicsPipelineCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct GraphicsPipelineCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_STAGECOUNT			 = 0b1000;
        const FLAG_PSTAGES			 = 0b10000;
        const FLAG_PVERTEXINPUTSTATE			 = 0b100000;
        const FLAG_PINPUTASSEMBLYSTATE			 = 0b1000000;
        const FLAG_PTESSELLATIONSTATE			 = 0b10000000;
        const FLAG_PVIEWPORTSTATE			 = 0b100000000;
        const FLAG_PRASTERIZATIONSTATE			 = 0b1000000000;
        const FLAG_PMULTISAMPLESTATE			 = 0b10000000000;
        const FLAG_PDEPTHSTENCILSTATE			 = 0b100000000000;
        const FLAG_PCOLORBLENDSTATE			 = 0b1000000000000;
        const FLAG_PDYNAMICSTATE			 = 0b10000000000000;
        const FLAG_LAYOUT			 = 0b100000000000000;
        const FLAG_RENDERPASS			 = 0b1000000000000000;
        const FLAG_SUBPASS			 = 0b10000000000000000;
        const FLAG_BASEPIPELINEHANDLE			 = 0b100000000000000000;
        const FLAG_BASEPIPELINEINDEX			 = 0b1000000000000000000;
    }
}


/// A builder for `VkGraphicsPipelineCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct GraphicsPipelineCreateInfoBuilder<'b> {
    raw: vks::VkGraphicsPipelineCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: GraphicsPipelineCreateInfoFlags,
}

impl<'b> GraphicsPipelineCreateInfoBuilder<'b> {
    pub fn new() -> GraphicsPipelineCreateInfoBuilder<'b> {
        GraphicsPipelineCreateInfoBuilder {
            raw: vks::VkGraphicsPipelineCreateInfo::default(),
            _p: PhantomData,
            set_mask: GraphicsPipelineCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCreateFlags) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn stages<'m, 'a>(mut self, stages: &'a [PipelineShaderStageCreateInfo]) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.stageCount == 0 || self.raw.stageCount == stages.len() as _, 
            "count inconsistency found when specifying `GraphicsPipelineCreateInfo::stages`.");
        self.raw.stageCount = stages.len() as _;
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_STAGECOUNT;
        self.raw.pStages = stages.as_ptr() as *const vks::VkPipelineShaderStageCreateInfo;
        self
    }

    pub fn vertex_input_state<'m, 'a>(mut self, vertex_input_state: &'a PipelineVertexInputStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pVertexInputState = vertex_input_state.as_raw();
        self
    }

    pub fn input_assembly_state<'m, 'a>(mut self, input_assembly_state: &'a PipelineInputAssemblyStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pInputAssemblyState = input_assembly_state.as_raw();
        self
    }

    pub fn tessellation_state<'m, 'a>(mut self, tessellation_state: &'a PipelineTessellationStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pTessellationState = tessellation_state.as_raw();
        self
    }

    pub fn viewport_state<'m, 'a>(mut self, viewport_state: &'a PipelineViewportStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pViewportState = viewport_state.as_raw();
        self
    }

    pub fn rasterization_state<'m, 'a>(mut self, rasterization_state: &'a PipelineRasterizationStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pRasterizationState = rasterization_state.as_raw();
        self
    }

    pub fn multisample_state<'m, 'a>(mut self, multisample_state: &'a PipelineMultisampleStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pMultisampleState = multisample_state.as_raw();
        self
    }

    pub fn depth_stencil_state<'m, 'a>(mut self, depth_stencil_state: &'a PipelineDepthStencilStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pDepthStencilState = depth_stencil_state.as_raw();
        self
    }

    pub fn color_blend_state<'m, 'a>(mut self, color_blend_state: &'a PipelineColorBlendStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pColorBlendState = color_blend_state.as_raw();
        self
    }

    pub fn dynamic_state<'m, 'a>(mut self, dynamic_state: &'a PipelineDynamicStateCreateInfo) -> GraphicsPipelineCreateInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pDynamicState = dynamic_state.as_raw();
        self
    }

    pub fn layout<'m, H>(mut self, layout: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.layout = layout.handle().0;
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_LAYOUT;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_RENDERPASS;
        self
    }

    pub fn subpass<'m>(mut self, subpass: u32) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.subpass = subpass.into();
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_SUBPASS;
        self
    }

    pub fn base_pipeline_handle<'m, H>(mut self, base_pipeline_handle: H) -> GraphicsPipelineCreateInfoBuilder<'b>
            where H: Handle<Target=PipelineHandle> {
        self.raw.basePipelineHandle = base_pipeline_handle.handle().0;
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE;
        self
    }

    pub fn base_pipeline_index<'m>(mut self, base_pipeline_index: i32) -> GraphicsPipelineCreateInfoBuilder<'b> {
        self.raw.basePipelineIndex = base_pipeline_index.into();
        self.set_mask |= GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_PNEXT != GraphicsPipelineCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineCreateFlags> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_FLAGS != GraphicsPipelineCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineCreateFlags::from_bits(self.raw.flags)
            .expect("GraphicsPipelineCreateInfo::flags: error converting flags") )
    }

    pub fn get_stages<'a>(&'a self) -> Option<&'a [PipelineShaderStageCreateInfo]> {
        if self.raw.pStages.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pStages as *const _, self.raw.stageCount as usize) } )
    }

    pub fn get_vertex_input_state<'a>(&'a self) -> Option<&'a PipelineVertexInputStateCreateInfo> {
        if self.raw.pVertexInputState.is_null() { return None }
        Some( unsafe { &*(self.raw.pVertexInputState as *const vks::VkPipelineVertexInputStateCreateInfo as *const _) } )
    }

    pub fn get_input_assembly_state<'a>(&'a self) -> Option<&'a PipelineInputAssemblyStateCreateInfo> {
        if self.raw.pInputAssemblyState.is_null() { return None }
        Some( unsafe { &*(self.raw.pInputAssemblyState as *const vks::VkPipelineInputAssemblyStateCreateInfo as *const _) } )
    }

    pub fn get_tessellation_state<'a>(&'a self) -> Option<&'a PipelineTessellationStateCreateInfo> {
        if self.raw.pTessellationState.is_null() { return None }
        Some( unsafe { &*(self.raw.pTessellationState as *const vks::VkPipelineTessellationStateCreateInfo as *const _) } )
    }

    pub fn get_viewport_state<'a>(&'a self) -> Option<&'a PipelineViewportStateCreateInfo> {
        if self.raw.pViewportState.is_null() { return None }
        Some( unsafe { &*(self.raw.pViewportState as *const vks::VkPipelineViewportStateCreateInfo as *const _) } )
    }

    pub fn get_rasterization_state<'a>(&'a self) -> Option<&'a PipelineRasterizationStateCreateInfo> {
        if self.raw.pRasterizationState.is_null() { return None }
        Some( unsafe { &*(self.raw.pRasterizationState as *const vks::VkPipelineRasterizationStateCreateInfo as *const _) } )
    }

    pub fn get_multisample_state<'a>(&'a self) -> Option<&'a PipelineMultisampleStateCreateInfo> {
        if self.raw.pMultisampleState.is_null() { return None }
        Some( unsafe { &*(self.raw.pMultisampleState as *const vks::VkPipelineMultisampleStateCreateInfo as *const _) } )
    }

    pub fn get_depth_stencil_state<'a>(&'a self) -> Option<&'a PipelineDepthStencilStateCreateInfo> {
        if self.raw.pDepthStencilState.is_null() { return None }
        Some( unsafe { &*(self.raw.pDepthStencilState as *const vks::VkPipelineDepthStencilStateCreateInfo as *const _) } )
    }

    pub fn get_color_blend_state<'a>(&'a self) -> Option<&'a PipelineColorBlendStateCreateInfo> {
        if self.raw.pColorBlendState.is_null() { return None }
        Some( unsafe { &*(self.raw.pColorBlendState as *const vks::VkPipelineColorBlendStateCreateInfo as *const _) } )
    }

    pub fn get_dynamic_state<'a>(&'a self) -> Option<&'a PipelineDynamicStateCreateInfo> {
        if self.raw.pDynamicState.is_null() { return None }
        Some( unsafe { &*(self.raw.pDynamicState as *const vks::VkPipelineDynamicStateCreateInfo as *const _) } )
    }

    pub fn get_layout<'a>(&'a self) -> Option<vks::VkPipelineLayout> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_LAYOUT != GraphicsPipelineCreateInfoFlags::FLAG_LAYOUT { return None }
        Some( self.raw.layout )
    }

    pub fn get_render_pass<'a>(&'a self) -> Option<vks::VkRenderPass> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_RENDERPASS != GraphicsPipelineCreateInfoFlags::FLAG_RENDERPASS { return None }
        Some( self.raw.renderPass )
    }

    pub fn get_subpass<'a>(&'a self) -> Option<u32> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_SUBPASS != GraphicsPipelineCreateInfoFlags::FLAG_SUBPASS { return None }
        Some( self.raw.subpass.into() )
    }

    pub fn get_base_pipeline_handle<'a>(&'a self) -> Option<vks::VkPipeline> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE != GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEHANDLE { return None }
        Some( self.raw.basePipelineHandle )
    }

    pub fn get_base_pipeline_index<'a>(&'a self) -> Option<i32> {
        if self.set_mask & GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX != GraphicsPipelineCreateInfoFlags::FLAG_BASEPIPELINEINDEX { return None }
        Some( self.raw.basePipelineIndex.into() )
    }

    pub fn build(self) -> GraphicsPipelineCreateInfo<'b> {
        GraphicsPipelineCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCacheCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCacheCreateInfo<'s> {
    raw: vks::VkPipelineCacheCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCacheCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineCacheCreateInfoBuilder<'b> {
        PipelineCacheCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCacheCreateInfo) -> PipelineCacheCreateInfo<'s> {
        PipelineCacheCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCacheCreateFlags {
        PipelineCacheCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineCacheCreateInfo::flags: error converting flags")
    }

    pub fn initial_data_size<'a>(&'a self) -> usize {
        self.raw.initialDataSize.into()
    }

    pub fn initial_data<'a>(&'a self) -> *const c_void {
        self.raw.pInitialData
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCacheCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_initial_data_size<'m>(&mut self, initial_data_size: usize) {
        self.raw.initialDataSize = initial_data_size.into();
    }

    pub unsafe fn set_initial_data<'m>(&mut self, initial_data: *const c_void) {
        self.raw.pInitialData = initial_data;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCacheCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineCacheCreateInfo<'s>> for vks::VkPipelineCacheCreateInfo {
    fn from(f: PipelineCacheCreateInfo<'s>) -> vks::VkPipelineCacheCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineCacheCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineCacheCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_INITIALDATASIZE			 = 0b1000;
        const FLAG_PINITIALDATA			 = 0b10000;
    }
}


/// A builder for `VkPipelineCacheCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCacheCreateInfoBuilder<'b> {
    raw: vks::VkPipelineCacheCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineCacheCreateInfoFlags,
}

impl<'b> PipelineCacheCreateInfoBuilder<'b> {
    pub fn new() -> PipelineCacheCreateInfoBuilder<'b> {
        PipelineCacheCreateInfoBuilder {
            raw: vks::VkPipelineCacheCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineCacheCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineCacheCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCacheCreateFlags) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineCacheCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn initial_data_size<'m>(mut self, initial_data_size: usize) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.initialDataSize = initial_data_size.into();
        self.set_mask |= PipelineCacheCreateInfoFlags::FLAG_INITIALDATASIZE;
        self
    }

    pub unsafe fn initial_data<'m>(mut self, initial_data: *const c_void) -> PipelineCacheCreateInfoBuilder<'b> {
        self.raw.pInitialData = initial_data;
        self.set_mask |= PipelineCacheCreateInfoFlags::FLAG_PINITIALDATA;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineCacheCreateInfoFlags::FLAG_PNEXT != PipelineCacheCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineCacheCreateFlags> {
        if self.set_mask & PipelineCacheCreateInfoFlags::FLAG_FLAGS != PipelineCacheCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineCacheCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineCacheCreateInfo::flags: error converting flags") )
    }

    pub fn get_initial_data_size<'a>(&'a self) -> Option<usize> {
        if self.set_mask & PipelineCacheCreateInfoFlags::FLAG_INITIALDATASIZE != PipelineCacheCreateInfoFlags::FLAG_INITIALDATASIZE { return None }
        Some( self.raw.initialDataSize.into() )
    }

    pub fn get_initial_data<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineCacheCreateInfoFlags::FLAG_PINITIALDATA != PipelineCacheCreateInfoFlags::FLAG_PINITIALDATA { return None }
        Some( self.raw.pInitialData )
    }

    pub fn build(self) -> PipelineCacheCreateInfo<'b> {
        PipelineCacheCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPushConstantRange`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PushConstantRange {
    raw: vks::VkPushConstantRange,
}

impl PushConstantRange {
    pub fn builder() -> PushConstantRangeBuilder {
        PushConstantRangeBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPushConstantRange) -> PushConstantRange {
        PushConstantRange { raw, }
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("PushConstantRange::stage_flags: error converting flags")
    }

    pub fn offset<'a>(&'a self) -> u32 {
        self.raw.offset.into()
    }

    pub fn size<'a>(&'a self) -> u32 {
        self.raw.size.into()
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn set_offset<'m>(&mut self, offset: u32) {
        self.raw.offset = offset.into();
    }

    pub fn set_size<'m>(&mut self, size: u32) {
        self.raw.size = size.into();
    }

    pub fn as_raw(&self) -> &vks::VkPushConstantRange {
        &self.raw
    }
}

impl From<PushConstantRange> for vks::VkPushConstantRange {
    fn from(f: PushConstantRange) -> vks::VkPushConstantRange {
        f.raw
    }
}


/// Bitflags for `VkPushConstantRange`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PushConstantRangeFlags: u32 {
        const FLAG_STAGEFLAGS			 = 0b1;
        const FLAG_OFFSET			 = 0b10;
        const FLAG_SIZE			 = 0b100;
    }
}


/// A builder for `VkPushConstantRange`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PushConstantRangeBuilder {
    raw: vks::VkPushConstantRange,
    set_mask: PushConstantRangeFlags,
}

impl PushConstantRangeBuilder {
    pub fn new() -> PushConstantRangeBuilder {
        PushConstantRangeBuilder {
            raw: vks::VkPushConstantRange::default(),
            set_mask: PushConstantRangeFlags::default(),
        }
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> PushConstantRangeBuilder {
        self.raw.stageFlags = stage_flags.bits();
        self.set_mask |= PushConstantRangeFlags::FLAG_STAGEFLAGS;
        self
    }

    pub fn offset<'m>(mut self, offset: u32) -> PushConstantRangeBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= PushConstantRangeFlags::FLAG_OFFSET;
        self
    }

    pub fn size<'m>(mut self, size: u32) -> PushConstantRangeBuilder {
        self.raw.size = size.into();
        self.set_mask |= PushConstantRangeFlags::FLAG_SIZE;
        self
    }

    pub fn get_stage_flags<'a>(&'a self) -> Option<ShaderStageFlags> {
        if self.set_mask & PushConstantRangeFlags::FLAG_STAGEFLAGS != PushConstantRangeFlags::FLAG_STAGEFLAGS { return None }
        Some( ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("PushConstantRange::stage_flags: error converting flags") )
    }

    pub fn get_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PushConstantRangeFlags::FLAG_OFFSET != PushConstantRangeFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_size<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PushConstantRangeFlags::FLAG_SIZE != PushConstantRangeFlags::FLAG_SIZE { return None }
        Some( self.raw.size.into() )
    }

    pub fn build(self) -> PushConstantRange {
        PushConstantRange {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineLayoutCreateInfo<'s> {
    raw: vks::VkPipelineLayoutCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineLayoutCreateInfo<'s> {
    pub fn builder<'b>() -> PipelineLayoutCreateInfoBuilder<'b> {
        PipelineLayoutCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineLayoutCreateInfo) -> PipelineLayoutCreateInfo<'s> {
        PipelineLayoutCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineLayoutCreateFlags {
        PipelineLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineLayoutCreateInfo::flags: error converting flags")
    }

    pub fn set_layouts<'a>(&'a self) -> &'a [vks::VkDescriptorSetLayout] {
        unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.setLayoutCount as usize) }
    }

    pub fn push_constant_ranges<'a>(&'a self) -> &'a [PushConstantRange] {
        unsafe { slice::from_raw_parts(self.raw.pPushConstantRanges as *const _, self.raw.pushConstantRangeCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineLayoutCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_set_layouts<'m, 'a>(&mut self, set_layouts: &'a [DescriptorSetLayoutHandle])
            where 'a: 's {
        assert!(self.raw.setLayoutCount == 0 || self.raw.setLayoutCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::set_layouts`.");
        self.raw.setLayoutCount = set_layouts.len() as _;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
    }

    pub fn set_push_constant_ranges<'m, 'a>(&mut self, push_constant_ranges: &'a [PushConstantRange])
            where 'a: 's {
        assert!(self.raw.pushConstantRangeCount == 0 || self.raw.pushConstantRangeCount == push_constant_ranges.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::push_constant_ranges`.");
        self.raw.pushConstantRangeCount = push_constant_ranges.len() as _;
        self.raw.pPushConstantRanges = push_constant_ranges.as_ptr() as *const vks::VkPushConstantRange;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineLayoutCreateInfo {
        &self.raw
    }
}

impl<'s> From<PipelineLayoutCreateInfo<'s>> for vks::VkPipelineLayoutCreateInfo {
    fn from(f: PipelineLayoutCreateInfo<'s>) -> vks::VkPipelineLayoutCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkPipelineLayoutCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineLayoutCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_SETLAYOUTCOUNT			 = 0b1000;
        const FLAG_PSETLAYOUTS			 = 0b10000;
        const FLAG_PUSHCONSTANTRANGECOUNT			 = 0b100000;
        const FLAG_PPUSHCONSTANTRANGES			 = 0b1000000;
    }
}


/// A builder for `VkPipelineLayoutCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineLayoutCreateInfoBuilder<'b> {
    raw: vks::VkPipelineLayoutCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineLayoutCreateInfoFlags,
}

impl<'b> PipelineLayoutCreateInfoBuilder<'b> {
    pub fn new() -> PipelineLayoutCreateInfoBuilder<'b> {
        PipelineLayoutCreateInfoBuilder {
            raw: vks::VkPipelineLayoutCreateInfo::default(),
            _p: PhantomData,
            set_mask: PipelineLayoutCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineLayoutCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineLayoutCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineLayoutCreateFlags) -> PipelineLayoutCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineLayoutCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn set_layouts<'m, 'a>(mut self, set_layouts: &'a [DescriptorSetLayoutHandle]) -> PipelineLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.setLayoutCount == 0 || self.raw.setLayoutCount == set_layouts.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::set_layouts`.");
        self.raw.setLayoutCount = set_layouts.len() as _;
        self.set_mask |= PipelineLayoutCreateInfoFlags::FLAG_SETLAYOUTCOUNT;
        self.raw.pSetLayouts = set_layouts.as_ptr() as *const vks::VkDescriptorSetLayout;
        self.set_mask |= PipelineLayoutCreateInfoFlags::FLAG_PSETLAYOUTS;
        self
    }

    pub fn push_constant_ranges<'m, 'a>(mut self, push_constant_ranges: &'a [PushConstantRange]) -> PipelineLayoutCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.pushConstantRangeCount == 0 || self.raw.pushConstantRangeCount == push_constant_ranges.len() as _, 
            "count inconsistency found when specifying `PipelineLayoutCreateInfo::push_constant_ranges`.");
        self.raw.pushConstantRangeCount = push_constant_ranges.len() as _;
        self.set_mask |= PipelineLayoutCreateInfoFlags::FLAG_PUSHCONSTANTRANGECOUNT;
        self.raw.pPushConstantRanges = push_constant_ranges.as_ptr() as *const vks::VkPushConstantRange;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineLayoutCreateInfoFlags::FLAG_PNEXT != PipelineLayoutCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineLayoutCreateFlags> {
        if self.set_mask & PipelineLayoutCreateInfoFlags::FLAG_FLAGS != PipelineLayoutCreateInfoFlags::FLAG_FLAGS { return None }
        Some( PipelineLayoutCreateFlags::from_bits(self.raw.flags)
            .expect("PipelineLayoutCreateInfo::flags: error converting flags") )
    }

    pub fn get_set_layouts<'a>(&'a self) -> Option<&'a [vks::VkDescriptorSetLayout]> {
        if self.set_mask & PipelineLayoutCreateInfoFlags::FLAG_PSETLAYOUTS != PipelineLayoutCreateInfoFlags::FLAG_PSETLAYOUTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSetLayouts as *const _, self.raw.setLayoutCount as usize) } )
    }

    pub fn get_push_constant_ranges<'a>(&'a self) -> Option<&'a [PushConstantRange]> {
        if self.raw.pPushConstantRanges.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pPushConstantRanges as *const _, self.raw.pushConstantRangeCount as usize) } )
    }

    pub fn build(self) -> PipelineLayoutCreateInfo<'b> {
        PipelineLayoutCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSamplerCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SamplerCreateInfo<'s> {
    raw: vks::VkSamplerCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SamplerCreateInfo<'s> {
    pub fn builder<'b>() -> SamplerCreateInfoBuilder<'b> {
        SamplerCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSamplerCreateInfo) -> SamplerCreateInfo<'s> {
        SamplerCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SamplerCreateFlags {
        SamplerCreateFlags::from_bits(self.raw.flags)
            .expect("SamplerCreateInfo::flags: error converting flags")
    }

    pub fn mag_filter<'a>(&'a self) -> Filter {
        self.raw.magFilter.into()
    }

    pub fn min_filter<'a>(&'a self) -> Filter {
        self.raw.minFilter.into()
    }

    pub fn mipmap_mode<'a>(&'a self) -> SamplerMipmapMode {
        self.raw.mipmapMode.into()
    }

    pub fn address_mode_u<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeU.into()
    }

    pub fn address_mode_v<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeV.into()
    }

    pub fn address_mode_w<'a>(&'a self) -> SamplerAddressMode {
        self.raw.addressModeW.into()
    }

    pub fn mip_lod_bias<'a>(&'a self) -> f32 {
        self.raw.mipLodBias.into()
    }

    pub fn anisotropy_enable<'a>(&'a self) -> bool {
        self.raw.anisotropyEnable != 0
    }

    pub fn max_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxAnisotropy.into()
    }

    pub fn compare_enable<'a>(&'a self) -> bool {
        self.raw.compareEnable != 0
    }

    pub fn compare_op<'a>(&'a self) -> CompareOp {
        self.raw.compareOp.into()
    }

    pub fn min_lod<'a>(&'a self) -> f32 {
        self.raw.minLod.into()
    }

    pub fn max_lod<'a>(&'a self) -> f32 {
        self.raw.maxLod.into()
    }

    pub fn border_color<'a>(&'a self) -> BorderColor {
        self.raw.borderColor.into()
    }

    pub fn unnormalized_coordinates<'a>(&'a self) -> bool {
        self.raw.unnormalizedCoordinates != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SamplerCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_mag_filter<'m>(&mut self, mag_filter: Filter) {
        self.raw.magFilter = mag_filter.into();
    }

    pub fn set_min_filter<'m>(&mut self, min_filter: Filter) {
        self.raw.minFilter = min_filter.into();
    }

    pub fn set_mipmap_mode<'m>(&mut self, mipmap_mode: SamplerMipmapMode) {
        self.raw.mipmapMode = mipmap_mode.into();
    }

    pub fn set_address_mode_u<'m>(&mut self, address_mode_u: SamplerAddressMode) {
        self.raw.addressModeU = address_mode_u.into();
    }

    pub fn set_address_mode_v<'m>(&mut self, address_mode_v: SamplerAddressMode) {
        self.raw.addressModeV = address_mode_v.into();
    }

    pub fn set_address_mode_w<'m>(&mut self, address_mode_w: SamplerAddressMode) {
        self.raw.addressModeW = address_mode_w.into();
    }

    pub fn set_mip_lod_bias<'m>(&mut self, mip_lod_bias: f32) {
        self.raw.mipLodBias = mip_lod_bias.into();
    }

    pub fn set_anisotropy_enable<'m>(&mut self, anisotropy_enable: bool) {
        self.raw.anisotropyEnable = anisotropy_enable as u32;
    }

    pub fn set_max_anisotropy<'m>(&mut self, max_anisotropy: f32) {
        self.raw.maxAnisotropy = max_anisotropy.into();
    }

    pub fn set_compare_enable<'m>(&mut self, compare_enable: bool) {
        self.raw.compareEnable = compare_enable as u32;
    }

    pub fn set_compare_op<'m>(&mut self, compare_op: CompareOp) {
        self.raw.compareOp = compare_op.into();
    }

    pub fn set_min_lod<'m>(&mut self, min_lod: f32) {
        self.raw.minLod = min_lod.into();
    }

    pub fn set_max_lod<'m>(&mut self, max_lod: f32) {
        self.raw.maxLod = max_lod.into();
    }

    pub fn set_border_color<'m>(&mut self, border_color: BorderColor) {
        self.raw.borderColor = border_color.into();
    }

    pub fn set_unnormalized_coordinates<'m>(&mut self, unnormalized_coordinates: bool) {
        self.raw.unnormalizedCoordinates = unnormalized_coordinates as u32;
    }

    pub fn as_raw(&self) -> &vks::VkSamplerCreateInfo {
        &self.raw
    }
}

impl<'s> From<SamplerCreateInfo<'s>> for vks::VkSamplerCreateInfo {
    fn from(f: SamplerCreateInfo<'s>) -> vks::VkSamplerCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkSamplerCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SamplerCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_MAGFILTER			 = 0b1000;
        const FLAG_MINFILTER			 = 0b10000;
        const FLAG_MIPMAPMODE			 = 0b100000;
        const FLAG_ADDRESSMODEU			 = 0b1000000;
        const FLAG_ADDRESSMODEV			 = 0b10000000;
        const FLAG_ADDRESSMODEW			 = 0b100000000;
        const FLAG_MIPLODBIAS			 = 0b1000000000;
        const FLAG_ANISOTROPYENABLE			 = 0b10000000000;
        const FLAG_MAXANISOTROPY			 = 0b100000000000;
        const FLAG_COMPAREENABLE			 = 0b1000000000000;
        const FLAG_COMPAREOP			 = 0b10000000000000;
        const FLAG_MINLOD			 = 0b100000000000000;
        const FLAG_MAXLOD			 = 0b1000000000000000;
        const FLAG_BORDERCOLOR			 = 0b10000000000000000;
        const FLAG_UNNORMALIZEDCOORDINATES			 = 0b100000000000000000;
    }
}


/// A builder for `VkSamplerCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SamplerCreateInfoBuilder<'b> {
    raw: vks::VkSamplerCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SamplerCreateInfoFlags,
}

impl<'b> SamplerCreateInfoBuilder<'b> {
    pub fn new() -> SamplerCreateInfoBuilder<'b> {
        SamplerCreateInfoBuilder {
            raw: vks::VkSamplerCreateInfo::default(),
            _p: PhantomData,
            set_mask: SamplerCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SamplerCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SamplerCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: SamplerCreateFlags) -> SamplerCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn mag_filter<'m>(mut self, mag_filter: Filter) -> SamplerCreateInfoBuilder<'b> {
        self.raw.magFilter = mag_filter.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MAGFILTER;
        self
    }

    pub fn min_filter<'m>(mut self, min_filter: Filter) -> SamplerCreateInfoBuilder<'b> {
        self.raw.minFilter = min_filter.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MINFILTER;
        self
    }

    pub fn mipmap_mode<'m>(mut self, mipmap_mode: SamplerMipmapMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.mipmapMode = mipmap_mode.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MIPMAPMODE;
        self
    }

    pub fn address_mode_u<'m>(mut self, address_mode_u: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeU = address_mode_u.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_ADDRESSMODEU;
        self
    }

    pub fn address_mode_v<'m>(mut self, address_mode_v: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeV = address_mode_v.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_ADDRESSMODEV;
        self
    }

    pub fn address_mode_w<'m>(mut self, address_mode_w: SamplerAddressMode) -> SamplerCreateInfoBuilder<'b> {
        self.raw.addressModeW = address_mode_w.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_ADDRESSMODEW;
        self
    }

    pub fn mip_lod_bias<'m>(mut self, mip_lod_bias: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.mipLodBias = mip_lod_bias.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MIPLODBIAS;
        self
    }

    pub fn anisotropy_enable<'m>(mut self, anisotropy_enable: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.anisotropyEnable = anisotropy_enable as u32;
        self.set_mask |= SamplerCreateInfoFlags::FLAG_ANISOTROPYENABLE;
        self
    }

    pub fn max_anisotropy<'m>(mut self, max_anisotropy: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.maxAnisotropy = max_anisotropy.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MAXANISOTROPY;
        self
    }

    pub fn compare_enable<'m>(mut self, compare_enable: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.compareEnable = compare_enable as u32;
        self.set_mask |= SamplerCreateInfoFlags::FLAG_COMPAREENABLE;
        self
    }

    pub fn compare_op<'m>(mut self, compare_op: CompareOp) -> SamplerCreateInfoBuilder<'b> {
        self.raw.compareOp = compare_op.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_COMPAREOP;
        self
    }

    pub fn min_lod<'m>(mut self, min_lod: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.minLod = min_lod.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MINLOD;
        self
    }

    pub fn max_lod<'m>(mut self, max_lod: f32) -> SamplerCreateInfoBuilder<'b> {
        self.raw.maxLod = max_lod.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_MAXLOD;
        self
    }

    pub fn border_color<'m>(mut self, border_color: BorderColor) -> SamplerCreateInfoBuilder<'b> {
        self.raw.borderColor = border_color.into();
        self.set_mask |= SamplerCreateInfoFlags::FLAG_BORDERCOLOR;
        self
    }

    pub fn unnormalized_coordinates<'m>(mut self, unnormalized_coordinates: bool) -> SamplerCreateInfoBuilder<'b> {
        self.raw.unnormalizedCoordinates = unnormalized_coordinates as u32;
        self.set_mask |= SamplerCreateInfoFlags::FLAG_UNNORMALIZEDCOORDINATES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_PNEXT != SamplerCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SamplerCreateFlags> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_FLAGS != SamplerCreateInfoFlags::FLAG_FLAGS { return None }
        Some( SamplerCreateFlags::from_bits(self.raw.flags)
            .expect("SamplerCreateInfo::flags: error converting flags") )
    }

    pub fn get_mag_filter<'a>(&'a self) -> Option<Filter> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MAGFILTER != SamplerCreateInfoFlags::FLAG_MAGFILTER { return None }
        Some( self.raw.magFilter.into() )
    }

    pub fn get_min_filter<'a>(&'a self) -> Option<Filter> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MINFILTER != SamplerCreateInfoFlags::FLAG_MINFILTER { return None }
        Some( self.raw.minFilter.into() )
    }

    pub fn get_mipmap_mode<'a>(&'a self) -> Option<SamplerMipmapMode> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MIPMAPMODE != SamplerCreateInfoFlags::FLAG_MIPMAPMODE { return None }
        Some( self.raw.mipmapMode.into() )
    }

    pub fn get_address_mode_u<'a>(&'a self) -> Option<SamplerAddressMode> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_ADDRESSMODEU != SamplerCreateInfoFlags::FLAG_ADDRESSMODEU { return None }
        Some( self.raw.addressModeU.into() )
    }

    pub fn get_address_mode_v<'a>(&'a self) -> Option<SamplerAddressMode> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_ADDRESSMODEV != SamplerCreateInfoFlags::FLAG_ADDRESSMODEV { return None }
        Some( self.raw.addressModeV.into() )
    }

    pub fn get_address_mode_w<'a>(&'a self) -> Option<SamplerAddressMode> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_ADDRESSMODEW != SamplerCreateInfoFlags::FLAG_ADDRESSMODEW { return None }
        Some( self.raw.addressModeW.into() )
    }

    pub fn get_mip_lod_bias<'a>(&'a self) -> Option<f32> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MIPLODBIAS != SamplerCreateInfoFlags::FLAG_MIPLODBIAS { return None }
        Some( self.raw.mipLodBias.into() )
    }

    pub fn get_anisotropy_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_ANISOTROPYENABLE != SamplerCreateInfoFlags::FLAG_ANISOTROPYENABLE { return None }
        Some( self.raw.anisotropyEnable != 0 )
    }

    pub fn get_max_anisotropy<'a>(&'a self) -> Option<f32> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MAXANISOTROPY != SamplerCreateInfoFlags::FLAG_MAXANISOTROPY { return None }
        Some( self.raw.maxAnisotropy.into() )
    }

    pub fn get_compare_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_COMPAREENABLE != SamplerCreateInfoFlags::FLAG_COMPAREENABLE { return None }
        Some( self.raw.compareEnable != 0 )
    }

    pub fn get_compare_op<'a>(&'a self) -> Option<CompareOp> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_COMPAREOP != SamplerCreateInfoFlags::FLAG_COMPAREOP { return None }
        Some( self.raw.compareOp.into() )
    }

    pub fn get_min_lod<'a>(&'a self) -> Option<f32> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MINLOD != SamplerCreateInfoFlags::FLAG_MINLOD { return None }
        Some( self.raw.minLod.into() )
    }

    pub fn get_max_lod<'a>(&'a self) -> Option<f32> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_MAXLOD != SamplerCreateInfoFlags::FLAG_MAXLOD { return None }
        Some( self.raw.maxLod.into() )
    }

    pub fn get_border_color<'a>(&'a self) -> Option<BorderColor> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_BORDERCOLOR != SamplerCreateInfoFlags::FLAG_BORDERCOLOR { return None }
        Some( self.raw.borderColor.into() )
    }

    pub fn get_unnormalized_coordinates<'a>(&'a self) -> Option<bool> {
        if self.set_mask & SamplerCreateInfoFlags::FLAG_UNNORMALIZEDCOORDINATES != SamplerCreateInfoFlags::FLAG_UNNORMALIZEDCOORDINATES { return None }
        Some( self.raw.unnormalizedCoordinates != 0 )
    }

    pub fn build(self) -> SamplerCreateInfo<'b> {
        SamplerCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandPoolCreateInfo<'s> {
    raw: vks::VkCommandPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandPoolCreateInfo<'s> {
    pub fn builder<'b>() -> CommandPoolCreateInfoBuilder<'b> {
        CommandPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandPoolCreateInfo) -> CommandPoolCreateInfo<'s> {
        CommandPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> CommandPoolCreateFlags {
        CommandPoolCreateFlags::from_bits(self.raw.flags)
            .expect("CommandPoolCreateInfo::flags: error converting flags")
    }

    pub fn queue_family_index<'a>(&'a self) -> u32 {
        self.raw.queueFamilyIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: CommandPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_queue_family_index<'m>(&mut self, queue_family_index: u32) {
        self.raw.queueFamilyIndex = queue_family_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkCommandPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<CommandPoolCreateInfo<'s>> for vks::VkCommandPoolCreateInfo {
    fn from(f: CommandPoolCreateInfo<'s>) -> vks::VkCommandPoolCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkCommandPoolCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CommandPoolCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_QUEUEFAMILYINDEX			 = 0b1000;
    }
}


/// A builder for `VkCommandPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandPoolCreateInfoBuilder<'b> {
    raw: vks::VkCommandPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: CommandPoolCreateInfoFlags,
}

impl<'b> CommandPoolCreateInfoBuilder<'b> {
    pub fn new() -> CommandPoolCreateInfoBuilder<'b> {
        CommandPoolCreateInfoBuilder {
            raw: vks::VkCommandPoolCreateInfo::default(),
            _p: PhantomData,
            set_mask: CommandPoolCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CommandPoolCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: CommandPoolCreateFlags) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= CommandPoolCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn queue_family_index<'m>(mut self, queue_family_index: u32) -> CommandPoolCreateInfoBuilder<'b> {
        self.raw.queueFamilyIndex = queue_family_index.into();
        self.set_mask |= CommandPoolCreateInfoFlags::FLAG_QUEUEFAMILYINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CommandPoolCreateInfoFlags::FLAG_PNEXT != CommandPoolCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<CommandPoolCreateFlags> {
        if self.set_mask & CommandPoolCreateInfoFlags::FLAG_FLAGS != CommandPoolCreateInfoFlags::FLAG_FLAGS { return None }
        Some( CommandPoolCreateFlags::from_bits(self.raw.flags)
            .expect("CommandPoolCreateInfo::flags: error converting flags") )
    }

    pub fn get_queue_family_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CommandPoolCreateInfoFlags::FLAG_QUEUEFAMILYINDEX != CommandPoolCreateInfoFlags::FLAG_QUEUEFAMILYINDEX { return None }
        Some( self.raw.queueFamilyIndex.into() )
    }

    pub fn build(self) -> CommandPoolCreateInfo<'b> {
        CommandPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferAllocateInfo<'s> {
    raw: vks::VkCommandBufferAllocateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferAllocateInfo<'s> {
    pub fn builder<'b>() -> CommandBufferAllocateInfoBuilder<'b> {
        CommandBufferAllocateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferAllocateInfo) -> CommandBufferAllocateInfo<'s> {
        CommandBufferAllocateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn command_pool<'a>(&'a self) -> vks::VkCommandPool {
        self.raw.commandPool
    }

    pub fn level<'a>(&'a self) -> CommandBufferLevel {
        self.raw.level.into()
    }

    pub fn command_buffer_count<'a>(&'a self) -> u32 {
        self.raw.commandBufferCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_command_pool<'m, H>(&mut self, command_pool: H)
            where H: Handle<Target=CommandPoolHandle> {
        self.raw.commandPool = command_pool.handle().0;
    }

    pub fn set_level<'m>(&mut self, level: CommandBufferLevel) {
        self.raw.level = level.into();
    }

    pub fn set_command_buffer_count<'m>(&mut self, command_buffer_count: u32) {
        self.raw.commandBufferCount = command_buffer_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferAllocateInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferAllocateInfo<'s>> for vks::VkCommandBufferAllocateInfo {
    fn from(f: CommandBufferAllocateInfo<'s>) -> vks::VkCommandBufferAllocateInfo {
        f.raw
    }
}


/// Bitflags for `VkCommandBufferAllocateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CommandBufferAllocateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_COMMANDPOOL			 = 0b100;
        const FLAG_LEVEL			 = 0b1000;
        const FLAG_COMMANDBUFFERCOUNT			 = 0b10000;
    }
}


/// A builder for `VkCommandBufferAllocateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferAllocateInfoBuilder<'b> {
    raw: vks::VkCommandBufferAllocateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: CommandBufferAllocateInfoFlags,
}

impl<'b> CommandBufferAllocateInfoBuilder<'b> {
    pub fn new() -> CommandBufferAllocateInfoBuilder<'b> {
        CommandBufferAllocateInfoBuilder {
            raw: vks::VkCommandBufferAllocateInfo::default(),
            _p: PhantomData,
            set_mask: CommandBufferAllocateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CommandBufferAllocateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn command_pool<'m, H>(mut self, command_pool: H) -> CommandBufferAllocateInfoBuilder<'b>
            where H: Handle<Target=CommandPoolHandle> {
        self.raw.commandPool = command_pool.handle().0;
        self.set_mask |= CommandBufferAllocateInfoFlags::FLAG_COMMANDPOOL;
        self
    }

    pub fn level<'m>(mut self, level: CommandBufferLevel) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.level = level.into();
        self.set_mask |= CommandBufferAllocateInfoFlags::FLAG_LEVEL;
        self
    }

    pub fn command_buffer_count<'m>(mut self, command_buffer_count: u32) -> CommandBufferAllocateInfoBuilder<'b> {
        self.raw.commandBufferCount = command_buffer_count.into();
        self.set_mask |= CommandBufferAllocateInfoFlags::FLAG_COMMANDBUFFERCOUNT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CommandBufferAllocateInfoFlags::FLAG_PNEXT != CommandBufferAllocateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_command_pool<'a>(&'a self) -> Option<vks::VkCommandPool> {
        if self.set_mask & CommandBufferAllocateInfoFlags::FLAG_COMMANDPOOL != CommandBufferAllocateInfoFlags::FLAG_COMMANDPOOL { return None }
        Some( self.raw.commandPool )
    }

    pub fn get_level<'a>(&'a self) -> Option<CommandBufferLevel> {
        if self.set_mask & CommandBufferAllocateInfoFlags::FLAG_LEVEL != CommandBufferAllocateInfoFlags::FLAG_LEVEL { return None }
        Some( self.raw.level.into() )
    }

    pub fn get_command_buffer_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CommandBufferAllocateInfoFlags::FLAG_COMMANDBUFFERCOUNT != CommandBufferAllocateInfoFlags::FLAG_COMMANDBUFFERCOUNT { return None }
        Some( self.raw.commandBufferCount.into() )
    }

    pub fn build(self) -> CommandBufferAllocateInfo<'b> {
        CommandBufferAllocateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferInheritanceInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferInheritanceInfo<'s> {
    raw: vks::VkCommandBufferInheritanceInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferInheritanceInfo<'s> {
    pub fn builder<'b>() -> CommandBufferInheritanceInfoBuilder<'b> {
        CommandBufferInheritanceInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferInheritanceInfo) -> CommandBufferInheritanceInfo<'s> {
        CommandBufferInheritanceInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn subpass<'a>(&'a self) -> u32 {
        self.raw.subpass.into()
    }

    pub fn framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn occlusion_query_enable<'a>(&'a self) -> bool {
        self.raw.occlusionQueryEnable != 0
    }

    pub fn query_flags<'a>(&'a self) -> QueryControlFlags {
        QueryControlFlags::from_bits(self.raw.queryFlags)
            .expect("CommandBufferInheritanceInfo::query_flags: error converting flags")
    }

    pub fn pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("CommandBufferInheritanceInfo::pipeline_statistics: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_subpass<'m>(&mut self, subpass: u32) {
        self.raw.subpass = subpass.into();
    }

    pub fn set_framebuffer<'m, H>(&mut self, framebuffer: H)
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
    }

    pub fn set_occlusion_query_enable<'m>(&mut self, occlusion_query_enable: bool) {
        self.raw.occlusionQueryEnable = occlusion_query_enable as u32;
    }

    pub fn set_query_flags<'m>(&mut self, query_flags: QueryControlFlags) {
        self.raw.queryFlags = query_flags.bits();
    }

    pub fn set_pipeline_statistics<'m>(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferInheritanceInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferInheritanceInfo<'s>> for vks::VkCommandBufferInheritanceInfo {
    fn from(f: CommandBufferInheritanceInfo<'s>) -> vks::VkCommandBufferInheritanceInfo {
        f.raw
    }
}


/// Bitflags for `VkCommandBufferInheritanceInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CommandBufferInheritanceInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_RENDERPASS			 = 0b100;
        const FLAG_SUBPASS			 = 0b1000;
        const FLAG_FRAMEBUFFER			 = 0b10000;
        const FLAG_OCCLUSIONQUERYENABLE			 = 0b100000;
        const FLAG_QUERYFLAGS			 = 0b1000000;
        const FLAG_PIPELINESTATISTICS			 = 0b10000000;
    }
}


/// A builder for `VkCommandBufferInheritanceInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferInheritanceInfoBuilder<'b> {
    raw: vks::VkCommandBufferInheritanceInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: CommandBufferInheritanceInfoFlags,
}

impl<'b> CommandBufferInheritanceInfoBuilder<'b> {
    pub fn new() -> CommandBufferInheritanceInfoBuilder<'b> {
        CommandBufferInheritanceInfoBuilder {
            raw: vks::VkCommandBufferInheritanceInfo::default(),
            _p: PhantomData,
            set_mask: CommandBufferInheritanceInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> CommandBufferInheritanceInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_RENDERPASS;
        self
    }

    pub fn subpass<'m>(mut self, subpass: u32) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.subpass = subpass.into();
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_SUBPASS;
        self
    }

    pub fn framebuffer<'m, H>(mut self, framebuffer: H) -> CommandBufferInheritanceInfoBuilder<'b>
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_FRAMEBUFFER;
        self
    }

    pub fn occlusion_query_enable<'m>(mut self, occlusion_query_enable: bool) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.occlusionQueryEnable = occlusion_query_enable as u32;
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_OCCLUSIONQUERYENABLE;
        self
    }

    pub fn query_flags<'m>(mut self, query_flags: QueryControlFlags) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.queryFlags = query_flags.bits();
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_QUERYFLAGS;
        self
    }

    pub fn pipeline_statistics<'m>(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> CommandBufferInheritanceInfoBuilder<'b> {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
        self.set_mask |= CommandBufferInheritanceInfoFlags::FLAG_PIPELINESTATISTICS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_PNEXT != CommandBufferInheritanceInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_render_pass<'a>(&'a self) -> Option<vks::VkRenderPass> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_RENDERPASS != CommandBufferInheritanceInfoFlags::FLAG_RENDERPASS { return None }
        Some( self.raw.renderPass )
    }

    pub fn get_subpass<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_SUBPASS != CommandBufferInheritanceInfoFlags::FLAG_SUBPASS { return None }
        Some( self.raw.subpass.into() )
    }

    pub fn get_framebuffer<'a>(&'a self) -> Option<vks::VkFramebuffer> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_FRAMEBUFFER != CommandBufferInheritanceInfoFlags::FLAG_FRAMEBUFFER { return None }
        Some( self.raw.framebuffer )
    }

    pub fn get_occlusion_query_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_OCCLUSIONQUERYENABLE != CommandBufferInheritanceInfoFlags::FLAG_OCCLUSIONQUERYENABLE { return None }
        Some( self.raw.occlusionQueryEnable != 0 )
    }

    pub fn get_query_flags<'a>(&'a self) -> Option<QueryControlFlags> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_QUERYFLAGS != CommandBufferInheritanceInfoFlags::FLAG_QUERYFLAGS { return None }
        Some( QueryControlFlags::from_bits(self.raw.queryFlags)
            .expect("CommandBufferInheritanceInfo::query_flags: error converting flags") )
    }

    pub fn get_pipeline_statistics<'a>(&'a self) -> Option<QueryPipelineStatisticFlags> {
        if self.set_mask & CommandBufferInheritanceInfoFlags::FLAG_PIPELINESTATISTICS != CommandBufferInheritanceInfoFlags::FLAG_PIPELINESTATISTICS { return None }
        Some( QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("CommandBufferInheritanceInfo::pipeline_statistics: error converting flags") )
    }

    pub fn build(self) -> CommandBufferInheritanceInfo<'b> {
        CommandBufferInheritanceInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCommandBufferBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CommandBufferBeginInfo<'s> {
    raw: vks::VkCommandBufferBeginInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> CommandBufferBeginInfo<'s> {
    pub fn builder<'b>() -> CommandBufferBeginInfoBuilder<'b> {
        CommandBufferBeginInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCommandBufferBeginInfo) -> CommandBufferBeginInfo<'s> {
        CommandBufferBeginInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> CommandBufferUsageFlags {
        CommandBufferUsageFlags::from_bits(self.raw.flags)
            .expect("CommandBufferBeginInfo::flags: error converting flags")
    }

    pub fn inheritance_info<'a>(&'a self) -> &'a CommandBufferInheritanceInfo {
        unsafe { &*(self.raw.pInheritanceInfo as *const vks::VkCommandBufferInheritanceInfo as *const _) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: CommandBufferUsageFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_inheritance_info<'m, 'a>(&mut self, inheritance_info: &'a CommandBufferInheritanceInfo)
            where 'a: 's {
        self.raw.pInheritanceInfo = inheritance_info.as_raw();
    }

    pub fn as_raw(&self) -> &vks::VkCommandBufferBeginInfo {
        &self.raw
    }
}

impl<'s> From<CommandBufferBeginInfo<'s>> for vks::VkCommandBufferBeginInfo {
    fn from(f: CommandBufferBeginInfo<'s>) -> vks::VkCommandBufferBeginInfo {
        f.raw
    }
}


/// Bitflags for `VkCommandBufferBeginInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CommandBufferBeginInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PINHERITANCEINFO			 = 0b1000;
    }
}


/// A builder for `VkCommandBufferBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct CommandBufferBeginInfoBuilder<'b> {
    raw: vks::VkCommandBufferBeginInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: CommandBufferBeginInfoFlags,
}

impl<'b> CommandBufferBeginInfoBuilder<'b> {
    pub fn new() -> CommandBufferBeginInfoBuilder<'b> {
        CommandBufferBeginInfoBuilder {
            raw: vks::VkCommandBufferBeginInfo::default(),
            _p: PhantomData,
            set_mask: CommandBufferBeginInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CommandBufferBeginInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CommandBufferBeginInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: CommandBufferUsageFlags) -> CommandBufferBeginInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= CommandBufferBeginInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn inheritance_info<'m, 'a>(mut self, inheritance_info: &'a CommandBufferInheritanceInfo) -> CommandBufferBeginInfoBuilder<'b>
            where 'a: 'b {
        self.raw.pInheritanceInfo = inheritance_info.as_raw();
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CommandBufferBeginInfoFlags::FLAG_PNEXT != CommandBufferBeginInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<CommandBufferUsageFlags> {
        if self.set_mask & CommandBufferBeginInfoFlags::FLAG_FLAGS != CommandBufferBeginInfoFlags::FLAG_FLAGS { return None }
        Some( CommandBufferUsageFlags::from_bits(self.raw.flags)
            .expect("CommandBufferBeginInfo::flags: error converting flags") )
    }

    pub fn get_inheritance_info<'a>(&'a self) -> Option<&'a CommandBufferInheritanceInfo> {
        if self.raw.pInheritanceInfo.is_null() { return None }
        Some( unsafe { &*(self.raw.pInheritanceInfo as *const vks::VkCommandBufferInheritanceInfo as *const _) } )
    }

    pub fn build(self) -> CommandBufferBeginInfo<'b> {
        CommandBufferBeginInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRenderPassBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RenderPassBeginInfo<'s> {
    raw: vks::VkRenderPassBeginInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> RenderPassBeginInfo<'s> {
    pub fn builder<'b>() -> RenderPassBeginInfoBuilder<'b> {
        RenderPassBeginInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRenderPassBeginInfo) -> RenderPassBeginInfo<'s> {
        RenderPassBeginInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn framebuffer<'a>(&'a self) -> vks::VkFramebuffer {
        self.raw.framebuffer
    }

    pub fn render_area<'a>(&'a self) -> &'a Rect2d {
         unsafe { &*(&self.raw.renderArea as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn render_area_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.renderArea as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn clear_values<'a>(&'a self) -> &'a [ClearValue] {
        unsafe { slice::from_raw_parts(self.raw.pClearValues as *const _, self.raw.clearValueCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_framebuffer<'m, H>(&mut self, framebuffer: H)
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
    }

    pub fn set_render_area<'m>(&mut self, render_area: Rect2d) {
        self.raw.renderArea = render_area.raw;
    }

    pub fn set_clear_values<'m, 'a>(&mut self, clear_values: &'a [ClearValue])
            where 'a: 's {
        assert!(self.raw.clearValueCount == 0 || self.raw.clearValueCount == clear_values.len() as _, 
            "count inconsistency found when specifying `RenderPassBeginInfo::clear_values`.");
        self.raw.clearValueCount = clear_values.len() as _;
        self.raw.pClearValues = clear_values.as_ptr() as *const ClearValue as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkRenderPassBeginInfo {
        &self.raw
    }
}

impl<'s> From<RenderPassBeginInfo<'s>> for vks::VkRenderPassBeginInfo {
    fn from(f: RenderPassBeginInfo<'s>) -> vks::VkRenderPassBeginInfo {
        f.raw
    }
}


/// Bitflags for `VkRenderPassBeginInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct RenderPassBeginInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_RENDERPASS			 = 0b100;
        const FLAG_FRAMEBUFFER			 = 0b1000;
        const FLAG_RENDERAREA			 = 0b10000;
        const FLAG_CLEARVALUECOUNT			 = 0b100000;
        const FLAG_PCLEARVALUES			 = 0b1000000;
    }
}


/// A builder for `VkRenderPassBeginInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RenderPassBeginInfoBuilder<'b> {
    raw: vks::VkRenderPassBeginInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: RenderPassBeginInfoFlags,
}

impl<'b> RenderPassBeginInfoBuilder<'b> {
    pub fn new() -> RenderPassBeginInfoBuilder<'b> {
        RenderPassBeginInfoBuilder {
            raw: vks::VkRenderPassBeginInfo::default(),
            _p: PhantomData,
            set_mask: RenderPassBeginInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> RenderPassBeginInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> RenderPassBeginInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_RENDERPASS;
        self
    }

    pub fn framebuffer<'m, H>(mut self, framebuffer: H) -> RenderPassBeginInfoBuilder<'b>
            where H: Handle<Target=FramebufferHandle> {
        self.raw.framebuffer = framebuffer.handle().0;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_FRAMEBUFFER;
        self
    }

    pub fn render_area<'m>(mut self, render_area: Rect2d) -> RenderPassBeginInfoBuilder<'b> {
        self.raw.renderArea = render_area.raw;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_RENDERAREA;
        self
    }

    pub fn clear_values<'m, 'a>(mut self, clear_values: &'a [ClearValue]) -> RenderPassBeginInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.clearValueCount == 0 || self.raw.clearValueCount == clear_values.len() as _, 
            "count inconsistency found when specifying `RenderPassBeginInfo::clear_values`.");
        self.raw.clearValueCount = clear_values.len() as _;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_CLEARVALUECOUNT;
        self.raw.pClearValues = clear_values.as_ptr() as *const ClearValue as *const _;
        self.set_mask |= RenderPassBeginInfoFlags::FLAG_PCLEARVALUES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_PNEXT != RenderPassBeginInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_render_pass<'a>(&'a self) -> Option<vks::VkRenderPass> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_RENDERPASS != RenderPassBeginInfoFlags::FLAG_RENDERPASS { return None }
        Some( self.raw.renderPass )
    }

    pub fn get_framebuffer<'a>(&'a self) -> Option<vks::VkFramebuffer> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_FRAMEBUFFER != RenderPassBeginInfoFlags::FLAG_FRAMEBUFFER { return None }
        Some( self.raw.framebuffer )
    }

    pub fn get_render_area<'a>(&'a self) -> Option<&'a Rect2d> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_RENDERAREA != RenderPassBeginInfoFlags::FLAG_RENDERAREA { return None }
        Some(  unsafe { &*(&self.raw.renderArea as *const vks::VkRect2D as *const Rect2d) } )
    }

    pub fn get_render_area_mut<'a>(&'a mut self) -> Option<&'a mut Rect2d> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_RENDERAREA != RenderPassBeginInfoFlags::FLAG_RENDERAREA { return None }
        Some( unsafe { &mut *(&mut self.raw.renderArea as *mut  vks::VkRect2D as *mut Rect2d) } )
    }

    pub fn get_clear_values<'a>(&'a self) -> Option<&'a [ClearValue]> {
        if self.set_mask & RenderPassBeginInfoFlags::FLAG_PCLEARVALUES != RenderPassBeginInfoFlags::FLAG_PCLEARVALUES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pClearValues as *const _, self.raw.clearValueCount as usize) } )
    }

    pub fn build(self) -> RenderPassBeginInfo<'b> {
        RenderPassBeginInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkClearDepthStencilValue`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearDepthStencilValue {
    raw: vks::VkClearDepthStencilValue,
}

impl ClearDepthStencilValue {
    pub fn builder() -> ClearDepthStencilValueBuilder {
        ClearDepthStencilValueBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearDepthStencilValue) -> ClearDepthStencilValue {
        ClearDepthStencilValue { raw, }
    }

    pub fn depth<'a>(&'a self) -> f32 {
        self.raw.depth.into()
    }

    pub fn stencil<'a>(&'a self) -> u32 {
        self.raw.stencil.into()
    }

    pub fn set_depth<'m>(&mut self, depth: f32) {
        self.raw.depth = depth.into();
    }

    pub fn set_stencil<'m>(&mut self, stencil: u32) {
        self.raw.stencil = stencil.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearDepthStencilValue {
        &self.raw
    }
}

impl From<ClearDepthStencilValue> for vks::VkClearDepthStencilValue {
    fn from(f: ClearDepthStencilValue) -> vks::VkClearDepthStencilValue {
        f.raw
    }
}


/// Bitflags for `VkClearDepthStencilValue`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ClearDepthStencilValueFlags: u32 {
        const FLAG_DEPTH			 = 0b1;
        const FLAG_STENCIL			 = 0b10;
    }
}


/// A builder for `VkClearDepthStencilValue`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearDepthStencilValueBuilder {
    raw: vks::VkClearDepthStencilValue,
    set_mask: ClearDepthStencilValueFlags,
}

impl ClearDepthStencilValueBuilder {
    pub fn new() -> ClearDepthStencilValueBuilder {
        ClearDepthStencilValueBuilder {
            raw: vks::VkClearDepthStencilValue::default(),
            set_mask: ClearDepthStencilValueFlags::default(),
        }
    }

    pub fn depth<'m>(mut self, depth: f32) -> ClearDepthStencilValueBuilder {
        self.raw.depth = depth.into();
        self.set_mask |= ClearDepthStencilValueFlags::FLAG_DEPTH;
        self
    }

    pub fn stencil<'m>(mut self, stencil: u32) -> ClearDepthStencilValueBuilder {
        self.raw.stencil = stencil.into();
        self.set_mask |= ClearDepthStencilValueFlags::FLAG_STENCIL;
        self
    }

    pub fn get_depth<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ClearDepthStencilValueFlags::FLAG_DEPTH != ClearDepthStencilValueFlags::FLAG_DEPTH { return None }
        Some( self.raw.depth.into() )
    }

    pub fn get_stencil<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ClearDepthStencilValueFlags::FLAG_STENCIL != ClearDepthStencilValueFlags::FLAG_STENCIL { return None }
        Some( self.raw.stencil.into() )
    }

    pub fn build(self) -> ClearDepthStencilValue {
        ClearDepthStencilValue {
            raw: self.raw,
        }
    }
}


/// A `VkClearAttachment`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ClearAttachment {
    raw: vks::VkClearAttachment,
}

impl ClearAttachment {
    pub fn builder() -> ClearAttachmentBuilder {
        ClearAttachmentBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkClearAttachment) -> ClearAttachment {
        ClearAttachment { raw, }
    }

    pub fn aspect_mask<'a>(&'a self) -> ImageAspectFlags {
        ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ClearAttachment::aspect_mask: error converting flags")
    }

    pub fn color_attachment<'a>(&'a self) -> u32 {
        self.raw.colorAttachment.into()
    }

    pub fn clear_value<'a>(&'a self) -> ClearValue {
        self.raw.clearValue.into()
    }

    pub fn set_aspect_mask<'m>(&mut self, aspect_mask: ImageAspectFlags) {
        self.raw.aspectMask = aspect_mask.bits();
    }

    pub fn set_color_attachment<'m>(&mut self, color_attachment: u32) {
        self.raw.colorAttachment = color_attachment.into();
    }

    pub fn set_clear_value<'m>(&mut self, clear_value: ClearValue) {
        self.raw.clearValue = clear_value.into();
    }

    pub fn as_raw(&self) -> &vks::VkClearAttachment {
        &self.raw
    }
}

impl From<ClearAttachment> for vks::VkClearAttachment {
    fn from(f: ClearAttachment) -> vks::VkClearAttachment {
        f.raw
    }
}


/// Bitflags for `VkClearAttachment`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ClearAttachmentFlags: u32 {
        const FLAG_ASPECTMASK			 = 0b1;
        const FLAG_COLORATTACHMENT			 = 0b10;
        const FLAG_CLEARVALUE			 = 0b100;
    }
}


/// A builder for `VkClearAttachment`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ClearAttachmentBuilder {
    raw: vks::VkClearAttachment,
    set_mask: ClearAttachmentFlags,
}

impl ClearAttachmentBuilder {
    pub fn new() -> ClearAttachmentBuilder {
        ClearAttachmentBuilder {
            raw: vks::VkClearAttachment::default(),
            set_mask: ClearAttachmentFlags::default(),
        }
    }

    pub fn aspect_mask<'m>(mut self, aspect_mask: ImageAspectFlags) -> ClearAttachmentBuilder {
        self.raw.aspectMask = aspect_mask.bits();
        self.set_mask |= ClearAttachmentFlags::FLAG_ASPECTMASK;
        self
    }

    pub fn color_attachment<'m>(mut self, color_attachment: u32) -> ClearAttachmentBuilder {
        self.raw.colorAttachment = color_attachment.into();
        self.set_mask |= ClearAttachmentFlags::FLAG_COLORATTACHMENT;
        self
    }

    pub fn clear_value<'m>(mut self, clear_value: ClearValue) -> ClearAttachmentBuilder {
        self.raw.clearValue = clear_value.into();
        self.set_mask |= ClearAttachmentFlags::FLAG_CLEARVALUE;
        self
    }

    pub fn get_aspect_mask<'a>(&'a self) -> Option<ImageAspectFlags> {
        if self.set_mask & ClearAttachmentFlags::FLAG_ASPECTMASK != ClearAttachmentFlags::FLAG_ASPECTMASK { return None }
        Some( ImageAspectFlags::from_bits(self.raw.aspectMask)
            .expect("ClearAttachment::aspect_mask: error converting flags") )
    }

    pub fn get_color_attachment<'a>(&'a self) -> Option<u32> {
        if self.set_mask & ClearAttachmentFlags::FLAG_COLORATTACHMENT != ClearAttachmentFlags::FLAG_COLORATTACHMENT { return None }
        Some( self.raw.colorAttachment.into() )
    }

    pub fn get_clear_value<'a>(&'a self) -> Option<ClearValue> {
        if self.set_mask & ClearAttachmentFlags::FLAG_CLEARVALUE != ClearAttachmentFlags::FLAG_CLEARVALUE { return None }
        Some( self.raw.clearValue.into() )
    }

    pub fn build(self) -> ClearAttachment {
        ClearAttachment {
            raw: self.raw,
        }
    }
}


/// A `VkAttachmentDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AttachmentDescription {
    raw: vks::VkAttachmentDescription,
}

impl AttachmentDescription {
    pub fn builder() -> AttachmentDescriptionBuilder {
        AttachmentDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAttachmentDescription) -> AttachmentDescription {
        AttachmentDescription { raw, }
    }

    pub fn flags<'a>(&'a self) -> AttachmentDescriptionFlags {
        AttachmentDescriptionFlags::from_bits(self.raw.flags)
            .expect("AttachmentDescription::flags: error converting flags")
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("AttachmentDescription::samples: error converting flags")
    }

    pub fn load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.loadOp.into()
    }

    pub fn store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.storeOp.into()
    }

    pub fn stencil_load_op<'a>(&'a self) -> AttachmentLoadOp {
        self.raw.stencilLoadOp.into()
    }

    pub fn stencil_store_op<'a>(&'a self) -> AttachmentStoreOp {
        self.raw.stencilStoreOp.into()
    }

    pub fn initial_layout<'a>(&'a self) -> ImageLayout {
        self.raw.initialLayout.into()
    }

    pub fn final_layout<'a>(&'a self) -> ImageLayout {
        self.raw.finalLayout.into()
    }

    pub fn set_flags<'m>(&mut self, flags: AttachmentDescriptionFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_load_op<'m>(&mut self, load_op: AttachmentLoadOp) {
        self.raw.loadOp = load_op.into();
    }

    pub fn set_store_op<'m>(&mut self, store_op: AttachmentStoreOp) {
        self.raw.storeOp = store_op.into();
    }

    pub fn set_stencil_load_op<'m>(&mut self, stencil_load_op: AttachmentLoadOp) {
        self.raw.stencilLoadOp = stencil_load_op.into();
    }

    pub fn set_stencil_store_op<'m>(&mut self, stencil_store_op: AttachmentStoreOp) {
        self.raw.stencilStoreOp = stencil_store_op.into();
    }

    pub fn set_initial_layout<'m>(&mut self, initial_layout: ImageLayout) {
        self.raw.initialLayout = initial_layout.into();
    }

    pub fn set_final_layout<'m>(&mut self, final_layout: ImageLayout) {
        self.raw.finalLayout = final_layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkAttachmentDescription {
        &self.raw
    }
}

impl From<AttachmentDescription> for vks::VkAttachmentDescription {
    fn from(f: AttachmentDescription) -> vks::VkAttachmentDescription {
        f.raw
    }
}


/// Bitflags for `VkAttachmentDescription`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct AttachmentDescriptionFlags: u32 {
        const FLAG_FLAGS			 = 0b1;
        const FLAG_FORMAT			 = 0b10;
        const FLAG_SAMPLES			 = 0b100;
        const FLAG_LOADOP			 = 0b1000;
        const FLAG_STOREOP			 = 0b10000;
        const FLAG_STENCILLOADOP			 = 0b100000;
        const FLAG_STENCILSTOREOP			 = 0b1000000;
        const FLAG_INITIALLAYOUT			 = 0b10000000;
        const FLAG_FINALLAYOUT			 = 0b100000000;
    }
}


/// A builder for `VkAttachmentDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AttachmentDescriptionBuilder {
    raw: vks::VkAttachmentDescription,
    set_mask: AttachmentDescriptionFlags,
}

impl AttachmentDescriptionBuilder {
    pub fn new() -> AttachmentDescriptionBuilder {
        AttachmentDescriptionBuilder {
            raw: vks::VkAttachmentDescription::default(),
            set_mask: AttachmentDescriptionFlags::default(),
        }
    }

    pub fn flags<'m>(mut self, flags: AttachmentDescriptionFlags) -> AttachmentDescriptionBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_FLAGS;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> AttachmentDescriptionBuilder {
        self.raw.format = format.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_FORMAT;
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> AttachmentDescriptionBuilder {
        self.raw.samples = samples.bits();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_SAMPLES;
        self
    }

    pub fn load_op<'m>(mut self, load_op: AttachmentLoadOp) -> AttachmentDescriptionBuilder {
        self.raw.loadOp = load_op.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_LOADOP;
        self
    }

    pub fn store_op<'m>(mut self, store_op: AttachmentStoreOp) -> AttachmentDescriptionBuilder {
        self.raw.storeOp = store_op.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_STOREOP;
        self
    }

    pub fn stencil_load_op<'m>(mut self, stencil_load_op: AttachmentLoadOp) -> AttachmentDescriptionBuilder {
        self.raw.stencilLoadOp = stencil_load_op.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_STENCILLOADOP;
        self
    }

    pub fn stencil_store_op<'m>(mut self, stencil_store_op: AttachmentStoreOp) -> AttachmentDescriptionBuilder {
        self.raw.stencilStoreOp = stencil_store_op.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_STENCILSTOREOP;
        self
    }

    pub fn initial_layout<'m>(mut self, initial_layout: ImageLayout) -> AttachmentDescriptionBuilder {
        self.raw.initialLayout = initial_layout.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_INITIALLAYOUT;
        self
    }

    pub fn final_layout<'m>(mut self, final_layout: ImageLayout) -> AttachmentDescriptionBuilder {
        self.raw.finalLayout = final_layout.into();
        self.set_mask |= AttachmentDescriptionFlags::FLAG_FINALLAYOUT;
        self
    }

    pub fn get_flags<'a>(&'a self) -> Option<AttachmentDescriptionFlags> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_FLAGS != AttachmentDescriptionFlags::FLAG_FLAGS { return None }
        Some( AttachmentDescriptionFlags::from_bits(self.raw.flags)
            .expect("AttachmentDescription::flags: error converting flags") )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_FORMAT != AttachmentDescriptionFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_samples<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_SAMPLES != AttachmentDescriptionFlags::FLAG_SAMPLES { return None }
        Some( SampleCountFlags::from_bits(self.raw.samples)
            .expect("AttachmentDescription::samples: error converting flags") )
    }

    pub fn get_load_op<'a>(&'a self) -> Option<AttachmentLoadOp> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_LOADOP != AttachmentDescriptionFlags::FLAG_LOADOP { return None }
        Some( self.raw.loadOp.into() )
    }

    pub fn get_store_op<'a>(&'a self) -> Option<AttachmentStoreOp> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_STOREOP != AttachmentDescriptionFlags::FLAG_STOREOP { return None }
        Some( self.raw.storeOp.into() )
    }

    pub fn get_stencil_load_op<'a>(&'a self) -> Option<AttachmentLoadOp> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_STENCILLOADOP != AttachmentDescriptionFlags::FLAG_STENCILLOADOP { return None }
        Some( self.raw.stencilLoadOp.into() )
    }

    pub fn get_stencil_store_op<'a>(&'a self) -> Option<AttachmentStoreOp> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_STENCILSTOREOP != AttachmentDescriptionFlags::FLAG_STENCILSTOREOP { return None }
        Some( self.raw.stencilStoreOp.into() )
    }

    pub fn get_initial_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_INITIALLAYOUT != AttachmentDescriptionFlags::FLAG_INITIALLAYOUT { return None }
        Some( self.raw.initialLayout.into() )
    }

    pub fn get_final_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & AttachmentDescriptionFlags::FLAG_FINALLAYOUT != AttachmentDescriptionFlags::FLAG_FINALLAYOUT { return None }
        Some( self.raw.finalLayout.into() )
    }

    pub fn build(self) -> AttachmentDescription {
        AttachmentDescription {
            raw: self.raw,
        }
    }
}


/// A `VkAttachmentReference`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AttachmentReference {
    raw: vks::VkAttachmentReference,
}

impl AttachmentReference {
    pub fn builder() -> AttachmentReferenceBuilder {
        AttachmentReferenceBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAttachmentReference) -> AttachmentReference {
        AttachmentReference { raw, }
    }

    pub fn attachment<'a>(&'a self) -> u32 {
        self.raw.attachment.into()
    }

    pub fn layout<'a>(&'a self) -> ImageLayout {
        self.raw.layout.into()
    }

    pub fn set_attachment<'m>(&mut self, attachment: u32) {
        self.raw.attachment = attachment.into();
    }

    pub fn set_layout<'m>(&mut self, layout: ImageLayout) {
        self.raw.layout = layout.into();
    }

    pub fn as_raw(&self) -> &vks::VkAttachmentReference {
        &self.raw
    }
}

impl From<AttachmentReference> for vks::VkAttachmentReference {
    fn from(f: AttachmentReference) -> vks::VkAttachmentReference {
        f.raw
    }
}


/// Bitflags for `VkAttachmentReference`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct AttachmentReferenceFlags: u32 {
        const FLAG_ATTACHMENT			 = 0b1;
        const FLAG_LAYOUT			 = 0b10;
    }
}


/// A builder for `VkAttachmentReference`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AttachmentReferenceBuilder {
    raw: vks::VkAttachmentReference,
    set_mask: AttachmentReferenceFlags,
}

impl AttachmentReferenceBuilder {
    pub fn new() -> AttachmentReferenceBuilder {
        AttachmentReferenceBuilder {
            raw: vks::VkAttachmentReference::default(),
            set_mask: AttachmentReferenceFlags::default(),
        }
    }

    pub fn attachment<'m>(mut self, attachment: u32) -> AttachmentReferenceBuilder {
        self.raw.attachment = attachment.into();
        self.set_mask |= AttachmentReferenceFlags::FLAG_ATTACHMENT;
        self
    }

    pub fn layout<'m>(mut self, layout: ImageLayout) -> AttachmentReferenceBuilder {
        self.raw.layout = layout.into();
        self.set_mask |= AttachmentReferenceFlags::FLAG_LAYOUT;
        self
    }

    pub fn get_attachment<'a>(&'a self) -> Option<u32> {
        if self.set_mask & AttachmentReferenceFlags::FLAG_ATTACHMENT != AttachmentReferenceFlags::FLAG_ATTACHMENT { return None }
        Some( self.raw.attachment.into() )
    }

    pub fn get_layout<'a>(&'a self) -> Option<ImageLayout> {
        if self.set_mask & AttachmentReferenceFlags::FLAG_LAYOUT != AttachmentReferenceFlags::FLAG_LAYOUT { return None }
        Some( self.raw.layout.into() )
    }

    pub fn build(self) -> AttachmentReference {
        AttachmentReference {
            raw: self.raw,
        }
    }
}


/// A `VkSubpassDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubpassDescription<'s> {
    raw: vks::VkSubpassDescription,
    _p: PhantomData<&'s ()>,
}

impl<'s> SubpassDescription<'s> {
    pub fn builder<'b>() -> SubpassDescriptionBuilder<'b> {
        SubpassDescriptionBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubpassDescription) -> SubpassDescription<'s> {
        SubpassDescription { raw, _p: PhantomData }
    }

    pub fn flags<'a>(&'a self) -> SubpassDescriptionFlags {
        SubpassDescriptionFlags::from_bits(self.raw.flags)
            .expect("SubpassDescription::flags: error converting flags")
    }

    pub fn pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn input_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pInputAttachments as *const _, self.raw.inputAttachmentCount as usize) }
    }

    pub fn color_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pColorAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn resolve_attachments<'a>(&'a self) -> &'a [AttachmentReference] {
        unsafe { slice::from_raw_parts(self.raw.pResolveAttachments as *const _, self.raw.colorAttachmentCount as usize) }
    }

    pub fn depth_stencil_attachment<'a>(&'a self) -> &'a AttachmentReference {
        unsafe { &*(self.raw.pDepthStencilAttachment as *const vks::VkAttachmentReference as *const _) }
    }

    pub fn preserve_attachments<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pPreserveAttachments as *const _, self.raw.preserveAttachmentCount as usize) }
    }

    pub fn set_flags<'m>(&mut self, flags: SubpassDescriptionFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_bind_point<'m>(&mut self, pipeline_bind_point: PipelineBindPoint) {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
    }

    pub fn set_input_attachments<'m, 'a>(&mut self, input_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.inputAttachmentCount == 0 || self.raw.inputAttachmentCount == input_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::input_attachments`.");
        self.raw.inputAttachmentCount = input_attachments.len() as _;
        self.raw.pInputAttachments = input_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_color_attachments<'m, 'a>(&mut self, color_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == color_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::color_attachments`.");
        self.raw.colorAttachmentCount = color_attachments.len() as _;
        self.raw.pColorAttachments = color_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_resolve_attachments<'m, 'a>(&mut self, resolve_attachments: &'a [AttachmentReference])
            where 'a: 's {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == resolve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::resolve_attachments`.");
        self.raw.colorAttachmentCount = resolve_attachments.len() as _;
        self.raw.pResolveAttachments = resolve_attachments.as_ptr() as *const vks::VkAttachmentReference;
    }

    pub fn set_depth_stencil_attachment<'m, 'a>(&mut self, depth_stencil_attachment: &'a AttachmentReference)
            where 'a: 's {
        self.raw.pDepthStencilAttachment = depth_stencil_attachment.as_raw();
    }

    pub fn set_preserve_attachments<'m, 'a>(&mut self, preserve_attachments: &'a [u32])
            where 'a: 's {
        assert!(self.raw.preserveAttachmentCount == 0 || self.raw.preserveAttachmentCount == preserve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::preserve_attachments`.");
        self.raw.preserveAttachmentCount = preserve_attachments.len() as _;
        self.raw.pPreserveAttachments = preserve_attachments.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkSubpassDescription {
        &self.raw
    }
}

impl<'s> From<SubpassDescription<'s>> for vks::VkSubpassDescription {
    fn from(f: SubpassDescription<'s>) -> vks::VkSubpassDescription {
        f.raw
    }
}


/// Bitflags for `VkSubpassDescription`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SubpassDescriptionFlags: u32 {
        const FLAG_FLAGS			 = 0b1;
        const FLAG_PIPELINEBINDPOINT			 = 0b10;
        const FLAG_INPUTATTACHMENTCOUNT			 = 0b100;
        const FLAG_PINPUTATTACHMENTS			 = 0b1000;
        const FLAG_COLORATTACHMENTCOUNT			 = 0b10000;
        const FLAG_PCOLORATTACHMENTS			 = 0b100000;
        const FLAG_PRESOLVEATTACHMENTS			 = 0b1000000;
        const FLAG_PDEPTHSTENCILATTACHMENT			 = 0b10000000;
        const FLAG_PRESERVEATTACHMENTCOUNT			 = 0b100000000;
        const FLAG_PPRESERVEATTACHMENTS			 = 0b1000000000;
    }
}


/// A builder for `VkSubpassDescription`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubpassDescriptionBuilder<'b> {
    raw: vks::VkSubpassDescription,
    _p: PhantomData<&'b ()>, 
    set_mask: SubpassDescriptionFlags,
}

impl<'b> SubpassDescriptionBuilder<'b> {
    pub fn new() -> SubpassDescriptionBuilder<'b> {
        SubpassDescriptionBuilder {
            raw: vks::VkSubpassDescription::default(),
            _p: PhantomData,
            set_mask: SubpassDescriptionFlags::default(),
        }
    }

    pub fn flags<'m>(mut self, flags: SubpassDescriptionFlags) -> SubpassDescriptionBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= SubpassDescriptionFlags::FLAG_FLAGS;
        self
    }

    pub fn pipeline_bind_point<'m>(mut self, pipeline_bind_point: PipelineBindPoint) -> SubpassDescriptionBuilder<'b> {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
        self.set_mask |= SubpassDescriptionFlags::FLAG_PIPELINEBINDPOINT;
        self
    }

    pub fn input_attachments<'m, 'a>(mut self, input_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.inputAttachmentCount == 0 || self.raw.inputAttachmentCount == input_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::input_attachments`.");
        self.raw.inputAttachmentCount = input_attachments.len() as _;
        self.set_mask |= SubpassDescriptionFlags::FLAG_INPUTATTACHMENTCOUNT;
        self.raw.pInputAttachments = input_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn color_attachments<'m, 'a>(mut self, color_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == color_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::color_attachments`.");
        self.raw.colorAttachmentCount = color_attachments.len() as _;
        self.set_mask |= SubpassDescriptionFlags::FLAG_COLORATTACHMENTCOUNT;
        self.raw.pColorAttachments = color_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn resolve_attachments<'m, 'a>(mut self, resolve_attachments: &'a [AttachmentReference]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.colorAttachmentCount == 0 || self.raw.colorAttachmentCount == resolve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::resolve_attachments`.");
        self.raw.colorAttachmentCount = resolve_attachments.len() as _;
        self.set_mask |= SubpassDescriptionFlags::FLAG_COLORATTACHMENTCOUNT;
        self.raw.pResolveAttachments = resolve_attachments.as_ptr() as *const vks::VkAttachmentReference;
        self
    }

    pub fn depth_stencil_attachment<'m, 'a>(mut self, depth_stencil_attachment: &'a AttachmentReference) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        self.raw.pDepthStencilAttachment = depth_stencil_attachment.as_raw();
        self
    }

    pub fn preserve_attachments<'m, 'a>(mut self, preserve_attachments: &'a [u32]) -> SubpassDescriptionBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.preserveAttachmentCount == 0 || self.raw.preserveAttachmentCount == preserve_attachments.len() as _, 
            "count inconsistency found when specifying `SubpassDescription::preserve_attachments`.");
        self.raw.preserveAttachmentCount = preserve_attachments.len() as _;
        self.set_mask |= SubpassDescriptionFlags::FLAG_PRESERVEATTACHMENTCOUNT;
        self.raw.pPreserveAttachments = preserve_attachments.as_ptr() as *const u32 as *const _;
        self.set_mask |= SubpassDescriptionFlags::FLAG_PPRESERVEATTACHMENTS;
        self
    }

    pub fn get_flags<'a>(&'a self) -> Option<SubpassDescriptionFlags> {
        if self.set_mask & SubpassDescriptionFlags::FLAG_FLAGS != SubpassDescriptionFlags::FLAG_FLAGS { return None }
        Some( SubpassDescriptionFlags::from_bits(self.raw.flags)
            .expect("SubpassDescription::flags: error converting flags") )
    }

    pub fn get_pipeline_bind_point<'a>(&'a self) -> Option<PipelineBindPoint> {
        if self.set_mask & SubpassDescriptionFlags::FLAG_PIPELINEBINDPOINT != SubpassDescriptionFlags::FLAG_PIPELINEBINDPOINT { return None }
        Some( self.raw.pipelineBindPoint.into() )
    }

    pub fn get_input_attachments<'a>(&'a self) -> Option<&'a [AttachmentReference]> {
        if self.raw.pInputAttachments.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pInputAttachments as *const _, self.raw.inputAttachmentCount as usize) } )
    }

    pub fn get_color_attachments<'a>(&'a self) -> Option<&'a [AttachmentReference]> {
        if self.raw.pColorAttachments.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pColorAttachments as *const _, self.raw.colorAttachmentCount as usize) } )
    }

    pub fn get_resolve_attachments<'a>(&'a self) -> Option<&'a [AttachmentReference]> {
        if self.raw.pResolveAttachments.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pResolveAttachments as *const _, self.raw.colorAttachmentCount as usize) } )
    }

    pub fn get_depth_stencil_attachment<'a>(&'a self) -> Option<&'a AttachmentReference> {
        if self.raw.pDepthStencilAttachment.is_null() { return None }
        Some( unsafe { &*(self.raw.pDepthStencilAttachment as *const vks::VkAttachmentReference as *const _) } )
    }

    pub fn get_preserve_attachments<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & SubpassDescriptionFlags::FLAG_PPRESERVEATTACHMENTS != SubpassDescriptionFlags::FLAG_PPRESERVEATTACHMENTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pPreserveAttachments as *const _, self.raw.preserveAttachmentCount as usize) } )
    }

    pub fn build(self) -> SubpassDescription<'b> {
        SubpassDescription {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSubpassDependency`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubpassDependency {
    raw: vks::VkSubpassDependency,
}

impl SubpassDependency {
    pub fn builder() -> SubpassDependencyBuilder {
        SubpassDependencyBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubpassDependency) -> SubpassDependency {
        SubpassDependency { raw, }
    }

    pub fn src_subpass<'a>(&'a self) -> u32 {
        self.raw.srcSubpass.into()
    }

    pub fn dst_subpass<'a>(&'a self) -> u32 {
        self.raw.dstSubpass.into()
    }

    pub fn src_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.srcStageMask)
            .expect("SubpassDependency::src_stage_mask: error converting flags")
    }

    pub fn dst_stage_mask<'a>(&'a self) -> PipelineStageFlags {
        PipelineStageFlags::from_bits(self.raw.dstStageMask)
            .expect("SubpassDependency::dst_stage_mask: error converting flags")
    }

    pub fn src_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("SubpassDependency::src_access_mask: error converting flags")
    }

    pub fn dst_access_mask<'a>(&'a self) -> AccessFlags {
        AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("SubpassDependency::dst_access_mask: error converting flags")
    }

    pub fn dependency_flags<'a>(&'a self) -> DependencyFlags {
        DependencyFlags::from_bits(self.raw.dependencyFlags)
            .expect("SubpassDependency::dependency_flags: error converting flags")
    }

    pub fn set_src_subpass<'m>(&mut self, src_subpass: u32) {
        self.raw.srcSubpass = src_subpass.into();
    }

    pub fn set_dst_subpass<'m>(&mut self, dst_subpass: u32) {
        self.raw.dstSubpass = dst_subpass.into();
    }

    pub fn set_src_stage_mask<'m>(&mut self, src_stage_mask: PipelineStageFlags) {
        self.raw.srcStageMask = src_stage_mask.bits();
    }

    pub fn set_dst_stage_mask<'m>(&mut self, dst_stage_mask: PipelineStageFlags) {
        self.raw.dstStageMask = dst_stage_mask.bits();
    }

    pub fn set_src_access_mask<'m>(&mut self, src_access_mask: AccessFlags) {
        self.raw.srcAccessMask = src_access_mask.bits();
    }

    pub fn set_dst_access_mask<'m>(&mut self, dst_access_mask: AccessFlags) {
        self.raw.dstAccessMask = dst_access_mask.bits();
    }

    pub fn set_dependency_flags<'m>(&mut self, dependency_flags: DependencyFlags) {
        self.raw.dependencyFlags = dependency_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSubpassDependency {
        &self.raw
    }
}

impl From<SubpassDependency> for vks::VkSubpassDependency {
    fn from(f: SubpassDependency) -> vks::VkSubpassDependency {
        f.raw
    }
}


/// Bitflags for `VkSubpassDependency`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SubpassDependencyFlags: u32 {
        const FLAG_SRCSUBPASS			 = 0b1;
        const FLAG_DSTSUBPASS			 = 0b10;
        const FLAG_SRCSTAGEMASK			 = 0b100;
        const FLAG_DSTSTAGEMASK			 = 0b1000;
        const FLAG_SRCACCESSMASK			 = 0b10000;
        const FLAG_DSTACCESSMASK			 = 0b100000;
        const FLAG_DEPENDENCYFLAGS			 = 0b1000000;
    }
}


/// A builder for `VkSubpassDependency`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubpassDependencyBuilder {
    raw: vks::VkSubpassDependency,
    set_mask: SubpassDependencyFlags,
}

impl SubpassDependencyBuilder {
    pub fn new() -> SubpassDependencyBuilder {
        SubpassDependencyBuilder {
            raw: vks::VkSubpassDependency::default(),
            set_mask: SubpassDependencyFlags::default(),
        }
    }

    pub fn src_subpass<'m>(mut self, src_subpass: u32) -> SubpassDependencyBuilder {
        self.raw.srcSubpass = src_subpass.into();
        self.set_mask |= SubpassDependencyFlags::FLAG_SRCSUBPASS;
        self
    }

    pub fn dst_subpass<'m>(mut self, dst_subpass: u32) -> SubpassDependencyBuilder {
        self.raw.dstSubpass = dst_subpass.into();
        self.set_mask |= SubpassDependencyFlags::FLAG_DSTSUBPASS;
        self
    }

    pub fn src_stage_mask<'m>(mut self, src_stage_mask: PipelineStageFlags) -> SubpassDependencyBuilder {
        self.raw.srcStageMask = src_stage_mask.bits();
        self.set_mask |= SubpassDependencyFlags::FLAG_SRCSTAGEMASK;
        self
    }

    pub fn dst_stage_mask<'m>(mut self, dst_stage_mask: PipelineStageFlags) -> SubpassDependencyBuilder {
        self.raw.dstStageMask = dst_stage_mask.bits();
        self.set_mask |= SubpassDependencyFlags::FLAG_DSTSTAGEMASK;
        self
    }

    pub fn src_access_mask<'m>(mut self, src_access_mask: AccessFlags) -> SubpassDependencyBuilder {
        self.raw.srcAccessMask = src_access_mask.bits();
        self.set_mask |= SubpassDependencyFlags::FLAG_SRCACCESSMASK;
        self
    }

    pub fn dst_access_mask<'m>(mut self, dst_access_mask: AccessFlags) -> SubpassDependencyBuilder {
        self.raw.dstAccessMask = dst_access_mask.bits();
        self.set_mask |= SubpassDependencyFlags::FLAG_DSTACCESSMASK;
        self
    }

    pub fn dependency_flags<'m>(mut self, dependency_flags: DependencyFlags) -> SubpassDependencyBuilder {
        self.raw.dependencyFlags = dependency_flags.bits();
        self.set_mask |= SubpassDependencyFlags::FLAG_DEPENDENCYFLAGS;
        self
    }

    pub fn get_src_subpass<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SubpassDependencyFlags::FLAG_SRCSUBPASS != SubpassDependencyFlags::FLAG_SRCSUBPASS { return None }
        Some( self.raw.srcSubpass.into() )
    }

    pub fn get_dst_subpass<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SubpassDependencyFlags::FLAG_DSTSUBPASS != SubpassDependencyFlags::FLAG_DSTSUBPASS { return None }
        Some( self.raw.dstSubpass.into() )
    }

    pub fn get_src_stage_mask<'a>(&'a self) -> Option<PipelineStageFlags> {
        if self.set_mask & SubpassDependencyFlags::FLAG_SRCSTAGEMASK != SubpassDependencyFlags::FLAG_SRCSTAGEMASK { return None }
        Some( PipelineStageFlags::from_bits(self.raw.srcStageMask)
            .expect("SubpassDependency::src_stage_mask: error converting flags") )
    }

    pub fn get_dst_stage_mask<'a>(&'a self) -> Option<PipelineStageFlags> {
        if self.set_mask & SubpassDependencyFlags::FLAG_DSTSTAGEMASK != SubpassDependencyFlags::FLAG_DSTSTAGEMASK { return None }
        Some( PipelineStageFlags::from_bits(self.raw.dstStageMask)
            .expect("SubpassDependency::dst_stage_mask: error converting flags") )
    }

    pub fn get_src_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & SubpassDependencyFlags::FLAG_SRCACCESSMASK != SubpassDependencyFlags::FLAG_SRCACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.srcAccessMask)
            .expect("SubpassDependency::src_access_mask: error converting flags") )
    }

    pub fn get_dst_access_mask<'a>(&'a self) -> Option<AccessFlags> {
        if self.set_mask & SubpassDependencyFlags::FLAG_DSTACCESSMASK != SubpassDependencyFlags::FLAG_DSTACCESSMASK { return None }
        Some( AccessFlags::from_bits(self.raw.dstAccessMask)
            .expect("SubpassDependency::dst_access_mask: error converting flags") )
    }

    pub fn get_dependency_flags<'a>(&'a self) -> Option<DependencyFlags> {
        if self.set_mask & SubpassDependencyFlags::FLAG_DEPENDENCYFLAGS != SubpassDependencyFlags::FLAG_DEPENDENCYFLAGS { return None }
        Some( DependencyFlags::from_bits(self.raw.dependencyFlags)
            .expect("SubpassDependency::dependency_flags: error converting flags") )
    }

    pub fn build(self) -> SubpassDependency {
        SubpassDependency {
            raw: self.raw,
        }
    }
}


/// A `VkRenderPassCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RenderPassCreateInfo<'s> {
    raw: vks::VkRenderPassCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> RenderPassCreateInfo<'s> {
    pub fn builder<'b>() -> RenderPassCreateInfoBuilder<'b> {
        RenderPassCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRenderPassCreateInfo) -> RenderPassCreateInfo<'s> {
        RenderPassCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> RenderPassCreateFlags {
        RenderPassCreateFlags::from_bits(self.raw.flags)
            .expect("RenderPassCreateInfo::flags: error converting flags")
    }

    pub fn attachments<'a>(&'a self) -> &'a [AttachmentDescription] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn subpasses<'a>(&'a self) -> &'a [SubpassDescription] {
        unsafe { slice::from_raw_parts(self.raw.pSubpasses as *const _, self.raw.subpassCount as usize) }
    }

    pub fn dependencies<'a>(&'a self) -> &'a [SubpassDependency] {
        unsafe { slice::from_raw_parts(self.raw.pDependencies as *const _, self.raw.dependencyCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: RenderPassCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [AttachmentDescription])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkAttachmentDescription;
    }

    pub fn set_subpasses<'m, 'a>(&mut self, subpasses: &'a [SubpassDescription])
            where 'a: 's {
        assert!(self.raw.subpassCount == 0 || self.raw.subpassCount == subpasses.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::subpasses`.");
        self.raw.subpassCount = subpasses.len() as _;
        self.raw.pSubpasses = subpasses.as_ptr() as *const vks::VkSubpassDescription;
    }

    pub fn set_dependencies<'m, 'a>(&mut self, dependencies: &'a [SubpassDependency])
            where 'a: 's {
        assert!(self.raw.dependencyCount == 0 || self.raw.dependencyCount == dependencies.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::dependencies`.");
        self.raw.dependencyCount = dependencies.len() as _;
        self.raw.pDependencies = dependencies.as_ptr() as *const vks::VkSubpassDependency;
    }

    pub fn as_raw(&self) -> &vks::VkRenderPassCreateInfo {
        &self.raw
    }
}

impl<'s> From<RenderPassCreateInfo<'s>> for vks::VkRenderPassCreateInfo {
    fn from(f: RenderPassCreateInfo<'s>) -> vks::VkRenderPassCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkRenderPassCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct RenderPassCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_ATTACHMENTCOUNT			 = 0b1000;
        const FLAG_PATTACHMENTS			 = 0b10000;
        const FLAG_SUBPASSCOUNT			 = 0b100000;
        const FLAG_PSUBPASSES			 = 0b1000000;
        const FLAG_DEPENDENCYCOUNT			 = 0b10000000;
        const FLAG_PDEPENDENCIES			 = 0b100000000;
    }
}


/// A builder for `VkRenderPassCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RenderPassCreateInfoBuilder<'b> {
    raw: vks::VkRenderPassCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: RenderPassCreateInfoFlags,
}

impl<'b> RenderPassCreateInfoBuilder<'b> {
    pub fn new() -> RenderPassCreateInfoBuilder<'b> {
        RenderPassCreateInfoBuilder {
            raw: vks::VkRenderPassCreateInfo::default(),
            _p: PhantomData,
            set_mask: RenderPassCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> RenderPassCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= RenderPassCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: RenderPassCreateFlags) -> RenderPassCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= RenderPassCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [AttachmentDescription]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.set_mask |= RenderPassCreateInfoFlags::FLAG_ATTACHMENTCOUNT;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkAttachmentDescription;
        self
    }

    pub fn subpasses<'m, 'a>(mut self, subpasses: &'a [SubpassDescription]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.subpassCount == 0 || self.raw.subpassCount == subpasses.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::subpasses`.");
        self.raw.subpassCount = subpasses.len() as _;
        self.set_mask |= RenderPassCreateInfoFlags::FLAG_SUBPASSCOUNT;
        self.raw.pSubpasses = subpasses.as_ptr() as *const vks::VkSubpassDescription;
        self
    }

    pub fn dependencies<'m, 'a>(mut self, dependencies: &'a [SubpassDependency]) -> RenderPassCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.dependencyCount == 0 || self.raw.dependencyCount == dependencies.len() as _, 
            "count inconsistency found when specifying `RenderPassCreateInfo::dependencies`.");
        self.raw.dependencyCount = dependencies.len() as _;
        self.set_mask |= RenderPassCreateInfoFlags::FLAG_DEPENDENCYCOUNT;
        self.raw.pDependencies = dependencies.as_ptr() as *const vks::VkSubpassDependency;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & RenderPassCreateInfoFlags::FLAG_PNEXT != RenderPassCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<RenderPassCreateFlags> {
        if self.set_mask & RenderPassCreateInfoFlags::FLAG_FLAGS != RenderPassCreateInfoFlags::FLAG_FLAGS { return None }
        Some( RenderPassCreateFlags::from_bits(self.raw.flags)
            .expect("RenderPassCreateInfo::flags: error converting flags") )
    }

    pub fn get_attachments<'a>(&'a self) -> Option<&'a [AttachmentDescription]> {
        if self.raw.pAttachments.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) } )
    }

    pub fn get_subpasses<'a>(&'a self) -> Option<&'a [SubpassDescription]> {
        if self.raw.pSubpasses.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSubpasses as *const _, self.raw.subpassCount as usize) } )
    }

    pub fn get_dependencies<'a>(&'a self) -> Option<&'a [SubpassDependency]> {
        if self.raw.pDependencies.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pDependencies as *const _, self.raw.dependencyCount as usize) } )
    }

    pub fn build(self) -> RenderPassCreateInfo<'b> {
        RenderPassCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkEventCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct EventCreateInfo<'s> {
    raw: vks::VkEventCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> EventCreateInfo<'s> {
    pub fn builder<'b>() -> EventCreateInfoBuilder<'b> {
        EventCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkEventCreateInfo) -> EventCreateInfo<'s> {
        EventCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> EventCreateFlags {
        EventCreateFlags::from_bits(self.raw.flags)
            .expect("EventCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: EventCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkEventCreateInfo {
        &self.raw
    }
}

impl<'s> From<EventCreateInfo<'s>> for vks::VkEventCreateInfo {
    fn from(f: EventCreateInfo<'s>) -> vks::VkEventCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkEventCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct EventCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
    }
}


/// A builder for `VkEventCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct EventCreateInfoBuilder<'b> {
    raw: vks::VkEventCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: EventCreateInfoFlags,
}

impl<'b> EventCreateInfoBuilder<'b> {
    pub fn new() -> EventCreateInfoBuilder<'b> {
        EventCreateInfoBuilder {
            raw: vks::VkEventCreateInfo::default(),
            _p: PhantomData,
            set_mask: EventCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> EventCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= EventCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: EventCreateFlags) -> EventCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= EventCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & EventCreateInfoFlags::FLAG_PNEXT != EventCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<EventCreateFlags> {
        if self.set_mask & EventCreateInfoFlags::FLAG_FLAGS != EventCreateInfoFlags::FLAG_FLAGS { return None }
        Some( EventCreateFlags::from_bits(self.raw.flags)
            .expect("EventCreateInfo::flags: error converting flags") )
    }

    pub fn build(self) -> EventCreateInfo<'b> {
        EventCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceCreateInfo<'s> {
    raw: vks::VkFenceCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceCreateInfo<'s> {
    pub fn builder<'b>() -> FenceCreateInfoBuilder<'b> {
        FenceCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceCreateInfo) -> FenceCreateInfo<'s> {
        FenceCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> FenceCreateFlags {
        FenceCreateFlags::from_bits(self.raw.flags)
            .expect("FenceCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceCreateInfo {
        &self.raw
    }
}

impl<'s> From<FenceCreateInfo<'s>> for vks::VkFenceCreateInfo {
    fn from(f: FenceCreateInfo<'s>) -> vks::VkFenceCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkFenceCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FenceCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
    }
}


/// A builder for `VkFenceCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceCreateInfoBuilder<'b> {
    raw: vks::VkFenceCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: FenceCreateInfoFlags,
}

impl<'b> FenceCreateInfoBuilder<'b> {
    pub fn new() -> FenceCreateInfoBuilder<'b> {
        FenceCreateInfoBuilder {
            raw: vks::VkFenceCreateInfo::default(),
            _p: PhantomData,
            set_mask: FenceCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= FenceCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceCreateFlags) -> FenceCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= FenceCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & FenceCreateInfoFlags::FLAG_PNEXT != FenceCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<FenceCreateFlags> {
        if self.set_mask & FenceCreateInfoFlags::FLAG_FLAGS != FenceCreateInfoFlags::FLAG_FLAGS { return None }
        Some( FenceCreateFlags::from_bits(self.raw.flags)
            .expect("FenceCreateInfo::flags: error converting flags") )
    }

    pub fn build(self) -> FenceCreateInfo<'b> {
        FenceCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceFeatures`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceFeatures {
    raw: vks::VkPhysicalDeviceFeatures,
}

impl PhysicalDeviceFeatures {
    pub fn builder() -> PhysicalDeviceFeaturesBuilder {
        PhysicalDeviceFeaturesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceFeatures) -> PhysicalDeviceFeatures {
        PhysicalDeviceFeatures { raw, }
    }

    pub fn robust_buffer_access<'a>(&'a self) -> bool {
        self.raw.robustBufferAccess != 0
    }

    pub fn full_draw_index_uint_32<'a>(&'a self) -> bool {
        self.raw.fullDrawIndexUint32 != 0
    }

    pub fn image_cube_array<'a>(&'a self) -> bool {
        self.raw.imageCubeArray != 0
    }

    pub fn independent_blend<'a>(&'a self) -> bool {
        self.raw.independentBlend != 0
    }

    pub fn geometry_shader<'a>(&'a self) -> bool {
        self.raw.geometryShader != 0
    }

    pub fn tessellation_shader<'a>(&'a self) -> bool {
        self.raw.tessellationShader != 0
    }

    pub fn sample_rate_shading<'a>(&'a self) -> bool {
        self.raw.sampleRateShading != 0
    }

    pub fn dual_src_blend<'a>(&'a self) -> bool {
        self.raw.dualSrcBlend != 0
    }

    pub fn logic_op<'a>(&'a self) -> bool {
        self.raw.logicOp != 0
    }

    pub fn multi_draw_indirect<'a>(&'a self) -> bool {
        self.raw.multiDrawIndirect != 0
    }

    pub fn draw_indirect_first_instance<'a>(&'a self) -> bool {
        self.raw.drawIndirectFirstInstance != 0
    }

    pub fn depth_clamp<'a>(&'a self) -> bool {
        self.raw.depthClamp != 0
    }

    pub fn depth_bias_clamp<'a>(&'a self) -> bool {
        self.raw.depthBiasClamp != 0
    }

    pub fn fill_mode_non_solid<'a>(&'a self) -> bool {
        self.raw.fillModeNonSolid != 0
    }

    pub fn depth_bounds<'a>(&'a self) -> bool {
        self.raw.depthBounds != 0
    }

    pub fn wide_lines<'a>(&'a self) -> bool {
        self.raw.wideLines != 0
    }

    pub fn large_points<'a>(&'a self) -> bool {
        self.raw.largePoints != 0
    }

    pub fn alpha_to_one<'a>(&'a self) -> bool {
        self.raw.alphaToOne != 0
    }

    pub fn multi_viewport<'a>(&'a self) -> bool {
        self.raw.multiViewport != 0
    }

    pub fn sampler_anisotropy<'a>(&'a self) -> bool {
        self.raw.samplerAnisotropy != 0
    }

    pub fn texture_compression_etc2<'a>(&'a self) -> bool {
        self.raw.textureCompressionETC2 != 0
    }

    pub fn texture_compression_astcldr<'a>(&'a self) -> bool {
        self.raw.textureCompressionASTC_LDR != 0
    }

    pub fn texture_compression_bc<'a>(&'a self) -> bool {
        self.raw.textureCompressionBC != 0
    }

    pub fn occlusion_query_precise<'a>(&'a self) -> bool {
        self.raw.occlusionQueryPrecise != 0
    }

    pub fn pipeline_statistics_query<'a>(&'a self) -> bool {
        self.raw.pipelineStatisticsQuery != 0
    }

    pub fn vertex_pipeline_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.vertexPipelineStoresAndAtomics != 0
    }

    pub fn fragment_stores_and_atomics<'a>(&'a self) -> bool {
        self.raw.fragmentStoresAndAtomics != 0
    }

    pub fn shader_tessellation_and_geometry_point_size<'a>(&'a self) -> bool {
        self.raw.shaderTessellationAndGeometryPointSize != 0
    }

    pub fn shader_image_gather_extended<'a>(&'a self) -> bool {
        self.raw.shaderImageGatherExtended != 0
    }

    pub fn shader_storage_image_extended_formats<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageExtendedFormats != 0
    }

    pub fn shader_storage_image_multisample<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageMultisample != 0
    }

    pub fn shader_storage_image_read_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageReadWithoutFormat != 0
    }

    pub fn shader_storage_image_write_without_format<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageWriteWithoutFormat != 0
    }

    pub fn shader_uniform_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderUniformBufferArrayDynamicIndexing != 0
    }

    pub fn shader_sampled_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderSampledImageArrayDynamicIndexing != 0
    }

    pub fn shader_storage_buffer_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageBufferArrayDynamicIndexing != 0
    }

    pub fn shader_storage_image_array_dynamic_indexing<'a>(&'a self) -> bool {
        self.raw.shaderStorageImageArrayDynamicIndexing != 0
    }

    pub fn shader_clip_distance<'a>(&'a self) -> bool {
        self.raw.shaderClipDistance != 0
    }

    pub fn shader_cull_distance<'a>(&'a self) -> bool {
        self.raw.shaderCullDistance != 0
    }

    pub fn shader_float_64<'a>(&'a self) -> bool {
        self.raw.shaderFloat64 != 0
    }

    pub fn shader_int_64<'a>(&'a self) -> bool {
        self.raw.shaderInt64 != 0
    }

    pub fn shader_int_16<'a>(&'a self) -> bool {
        self.raw.shaderInt16 != 0
    }

    pub fn shader_resource_residency<'a>(&'a self) -> bool {
        self.raw.shaderResourceResidency != 0
    }

    pub fn shader_resource_min_lod<'a>(&'a self) -> bool {
        self.raw.shaderResourceMinLod != 0
    }

    pub fn sparse_binding<'a>(&'a self) -> bool {
        self.raw.sparseBinding != 0
    }

    pub fn sparse_residency_buffer<'a>(&'a self) -> bool {
        self.raw.sparseResidencyBuffer != 0
    }

    pub fn sparse_residency_image_2d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage2D != 0
    }

    pub fn sparse_residency_image_3d<'a>(&'a self) -> bool {
        self.raw.sparseResidencyImage3D != 0
    }

    pub fn sparse_residency_2samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency2Samples != 0
    }

    pub fn sparse_residency_4samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency4Samples != 0
    }

    pub fn sparse_residency_8samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency8Samples != 0
    }

    pub fn sparse_residency_16_samples<'a>(&'a self) -> bool {
        self.raw.sparseResidency16Samples != 0
    }

    pub fn sparse_residency_aliased<'a>(&'a self) -> bool {
        self.raw.sparseResidencyAliased != 0
    }

    pub fn variable_multisample_rate<'a>(&'a self) -> bool {
        self.raw.variableMultisampleRate != 0
    }

    pub fn inherited_queries<'a>(&'a self) -> bool {
        self.raw.inheritedQueries != 0
    }

    pub fn set_robust_buffer_access<'m>(&mut self, robust_buffer_access: bool) {
        self.raw.robustBufferAccess = robust_buffer_access as u32;
    }

    pub fn set_full_draw_index_uint_32<'m>(&mut self, full_draw_index_uint_32: bool) {
        self.raw.fullDrawIndexUint32 = full_draw_index_uint_32 as u32;
    }

    pub fn set_image_cube_array<'m>(&mut self, image_cube_array: bool) {
        self.raw.imageCubeArray = image_cube_array as u32;
    }

    pub fn set_independent_blend<'m>(&mut self, independent_blend: bool) {
        self.raw.independentBlend = independent_blend as u32;
    }

    pub fn set_geometry_shader<'m>(&mut self, geometry_shader: bool) {
        self.raw.geometryShader = geometry_shader as u32;
    }

    pub fn set_tessellation_shader<'m>(&mut self, tessellation_shader: bool) {
        self.raw.tessellationShader = tessellation_shader as u32;
    }

    pub fn set_sample_rate_shading<'m>(&mut self, sample_rate_shading: bool) {
        self.raw.sampleRateShading = sample_rate_shading as u32;
    }

    pub fn set_dual_src_blend<'m>(&mut self, dual_src_blend: bool) {
        self.raw.dualSrcBlend = dual_src_blend as u32;
    }

    pub fn set_logic_op<'m>(&mut self, logic_op: bool) {
        self.raw.logicOp = logic_op as u32;
    }

    pub fn set_multi_draw_indirect<'m>(&mut self, multi_draw_indirect: bool) {
        self.raw.multiDrawIndirect = multi_draw_indirect as u32;
    }

    pub fn set_draw_indirect_first_instance<'m>(&mut self, draw_indirect_first_instance: bool) {
        self.raw.drawIndirectFirstInstance = draw_indirect_first_instance as u32;
    }

    pub fn set_depth_clamp<'m>(&mut self, depth_clamp: bool) {
        self.raw.depthClamp = depth_clamp as u32;
    }

    pub fn set_depth_bias_clamp<'m>(&mut self, depth_bias_clamp: bool) {
        self.raw.depthBiasClamp = depth_bias_clamp as u32;
    }

    pub fn set_fill_mode_non_solid<'m>(&mut self, fill_mode_non_solid: bool) {
        self.raw.fillModeNonSolid = fill_mode_non_solid as u32;
    }

    pub fn set_depth_bounds<'m>(&mut self, depth_bounds: bool) {
        self.raw.depthBounds = depth_bounds as u32;
    }

    pub fn set_wide_lines<'m>(&mut self, wide_lines: bool) {
        self.raw.wideLines = wide_lines as u32;
    }

    pub fn set_large_points<'m>(&mut self, large_points: bool) {
        self.raw.largePoints = large_points as u32;
    }

    pub fn set_alpha_to_one<'m>(&mut self, alpha_to_one: bool) {
        self.raw.alphaToOne = alpha_to_one as u32;
    }

    pub fn set_multi_viewport<'m>(&mut self, multi_viewport: bool) {
        self.raw.multiViewport = multi_viewport as u32;
    }

    pub fn set_sampler_anisotropy<'m>(&mut self, sampler_anisotropy: bool) {
        self.raw.samplerAnisotropy = sampler_anisotropy as u32;
    }

    pub fn set_texture_compression_etc2<'m>(&mut self, texture_compression_etc2: bool) {
        self.raw.textureCompressionETC2 = texture_compression_etc2 as u32;
    }

    pub fn set_texture_compression_astcldr<'m>(&mut self, texture_compression_astcldr: bool) {
        self.raw.textureCompressionASTC_LDR = texture_compression_astcldr as u32;
    }

    pub fn set_texture_compression_bc<'m>(&mut self, texture_compression_bc: bool) {
        self.raw.textureCompressionBC = texture_compression_bc as u32;
    }

    pub fn set_occlusion_query_precise<'m>(&mut self, occlusion_query_precise: bool) {
        self.raw.occlusionQueryPrecise = occlusion_query_precise as u32;
    }

    pub fn set_pipeline_statistics_query<'m>(&mut self, pipeline_statistics_query: bool) {
        self.raw.pipelineStatisticsQuery = pipeline_statistics_query as u32;
    }

    pub fn set_vertex_pipeline_stores_and_atomics<'m>(&mut self, vertex_pipeline_stores_and_atomics: bool) {
        self.raw.vertexPipelineStoresAndAtomics = vertex_pipeline_stores_and_atomics as u32;
    }

    pub fn set_fragment_stores_and_atomics<'m>(&mut self, fragment_stores_and_atomics: bool) {
        self.raw.fragmentStoresAndAtomics = fragment_stores_and_atomics as u32;
    }

    pub fn set_shader_tessellation_and_geometry_point_size<'m>(&mut self, shader_tessellation_and_geometry_point_size: bool) {
        self.raw.shaderTessellationAndGeometryPointSize = shader_tessellation_and_geometry_point_size as u32;
    }

    pub fn set_shader_image_gather_extended<'m>(&mut self, shader_image_gather_extended: bool) {
        self.raw.shaderImageGatherExtended = shader_image_gather_extended as u32;
    }

    pub fn set_shader_storage_image_extended_formats<'m>(&mut self, shader_storage_image_extended_formats: bool) {
        self.raw.shaderStorageImageExtendedFormats = shader_storage_image_extended_formats as u32;
    }

    pub fn set_shader_storage_image_multisample<'m>(&mut self, shader_storage_image_multisample: bool) {
        self.raw.shaderStorageImageMultisample = shader_storage_image_multisample as u32;
    }

    pub fn set_shader_storage_image_read_without_format<'m>(&mut self, shader_storage_image_read_without_format: bool) {
        self.raw.shaderStorageImageReadWithoutFormat = shader_storage_image_read_without_format as u32;
    }

    pub fn set_shader_storage_image_write_without_format<'m>(&mut self, shader_storage_image_write_without_format: bool) {
        self.raw.shaderStorageImageWriteWithoutFormat = shader_storage_image_write_without_format as u32;
    }

    pub fn set_shader_uniform_buffer_array_dynamic_indexing<'m>(&mut self, shader_uniform_buffer_array_dynamic_indexing: bool) {
        self.raw.shaderUniformBufferArrayDynamicIndexing = shader_uniform_buffer_array_dynamic_indexing as u32;
    }

    pub fn set_shader_sampled_image_array_dynamic_indexing<'m>(&mut self, shader_sampled_image_array_dynamic_indexing: bool) {
        self.raw.shaderSampledImageArrayDynamicIndexing = shader_sampled_image_array_dynamic_indexing as u32;
    }

    pub fn set_shader_storage_buffer_array_dynamic_indexing<'m>(&mut self, shader_storage_buffer_array_dynamic_indexing: bool) {
        self.raw.shaderStorageBufferArrayDynamicIndexing = shader_storage_buffer_array_dynamic_indexing as u32;
    }

    pub fn set_shader_storage_image_array_dynamic_indexing<'m>(&mut self, shader_storage_image_array_dynamic_indexing: bool) {
        self.raw.shaderStorageImageArrayDynamicIndexing = shader_storage_image_array_dynamic_indexing as u32;
    }

    pub fn set_shader_clip_distance<'m>(&mut self, shader_clip_distance: bool) {
        self.raw.shaderClipDistance = shader_clip_distance as u32;
    }

    pub fn set_shader_cull_distance<'m>(&mut self, shader_cull_distance: bool) {
        self.raw.shaderCullDistance = shader_cull_distance as u32;
    }

    pub fn set_shader_float_64<'m>(&mut self, shader_float_64: bool) {
        self.raw.shaderFloat64 = shader_float_64 as u32;
    }

    pub fn set_shader_int_64<'m>(&mut self, shader_int_64: bool) {
        self.raw.shaderInt64 = shader_int_64 as u32;
    }

    pub fn set_shader_int_16<'m>(&mut self, shader_int_16: bool) {
        self.raw.shaderInt16 = shader_int_16 as u32;
    }

    pub fn set_shader_resource_residency<'m>(&mut self, shader_resource_residency: bool) {
        self.raw.shaderResourceResidency = shader_resource_residency as u32;
    }

    pub fn set_shader_resource_min_lod<'m>(&mut self, shader_resource_min_lod: bool) {
        self.raw.shaderResourceMinLod = shader_resource_min_lod as u32;
    }

    pub fn set_sparse_binding<'m>(&mut self, sparse_binding: bool) {
        self.raw.sparseBinding = sparse_binding as u32;
    }

    pub fn set_sparse_residency_buffer<'m>(&mut self, sparse_residency_buffer: bool) {
        self.raw.sparseResidencyBuffer = sparse_residency_buffer as u32;
    }

    pub fn set_sparse_residency_image_2d<'m>(&mut self, sparse_residency_image_2d: bool) {
        self.raw.sparseResidencyImage2D = sparse_residency_image_2d as u32;
    }

    pub fn set_sparse_residency_image_3d<'m>(&mut self, sparse_residency_image_3d: bool) {
        self.raw.sparseResidencyImage3D = sparse_residency_image_3d as u32;
    }

    pub fn set_sparse_residency_2samples<'m>(&mut self, sparse_residency_2samples: bool) {
        self.raw.sparseResidency2Samples = sparse_residency_2samples as u32;
    }

    pub fn set_sparse_residency_4samples<'m>(&mut self, sparse_residency_4samples: bool) {
        self.raw.sparseResidency4Samples = sparse_residency_4samples as u32;
    }

    pub fn set_sparse_residency_8samples<'m>(&mut self, sparse_residency_8samples: bool) {
        self.raw.sparseResidency8Samples = sparse_residency_8samples as u32;
    }

    pub fn set_sparse_residency_16_samples<'m>(&mut self, sparse_residency_16_samples: bool) {
        self.raw.sparseResidency16Samples = sparse_residency_16_samples as u32;
    }

    pub fn set_sparse_residency_aliased<'m>(&mut self, sparse_residency_aliased: bool) {
        self.raw.sparseResidencyAliased = sparse_residency_aliased as u32;
    }

    pub fn set_variable_multisample_rate<'m>(&mut self, variable_multisample_rate: bool) {
        self.raw.variableMultisampleRate = variable_multisample_rate as u32;
    }

    pub fn set_inherited_queries<'m>(&mut self, inherited_queries: bool) {
        self.raw.inheritedQueries = inherited_queries as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceFeatures {
        &self.raw
    }
}

impl From<PhysicalDeviceFeatures> for vks::VkPhysicalDeviceFeatures {
    fn from(f: PhysicalDeviceFeatures) -> vks::VkPhysicalDeviceFeatures {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceFeatures`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceFeaturesFlags: u32 {
        const FLAG_ROBUSTBUFFERACCESS			 = 0b1;
        const FLAG_FULLDRAWINDEXUINT32			 = 0b10;
        const FLAG_IMAGECUBEARRAY			 = 0b100;
        const FLAG_INDEPENDENTBLEND			 = 0b1000;
        const FLAG_GEOMETRYSHADER			 = 0b10000;
        const FLAG_TESSELLATIONSHADER			 = 0b100000;
        const FLAG_SAMPLERATESHADING			 = 0b1000000;
        const FLAG_DUALSRCBLEND			 = 0b10000000;
        const FLAG_LOGICOP			 = 0b100000000;
        const FLAG_MULTIDRAWINDIRECT			 = 0b1000000000;
        const FLAG_DRAWINDIRECTFIRSTINSTANCE			 = 0b10000000000;
        const FLAG_DEPTHCLAMP			 = 0b100000000000;
        const FLAG_DEPTHBIASCLAMP			 = 0b1000000000000;
        const FLAG_FILLMODENONSOLID			 = 0b10000000000000;
        const FLAG_DEPTHBOUNDS			 = 0b100000000000000;
        const FLAG_WIDELINES			 = 0b1000000000000000;
        const FLAG_LARGEPOINTS			 = 0b10000000000000000;
        const FLAG_ALPHATOONE			 = 0b100000000000000000;
        const FLAG_MULTIVIEWPORT			 = 0b1000000000000000000;
        const FLAG_SAMPLERANISOTROPY			 = 0b10000000000000000000;
        const FLAG_TEXTURECOMPRESSIONETC2			 = 0b100000000000000000000;
        const FLAG_TEXTURECOMPRESSIONASTC_LDR			 = 0b1000000000000000000000;
        const FLAG_TEXTURECOMPRESSIONBC			 = 0b10000000000000000000000;
        const FLAG_OCCLUSIONQUERYPRECISE			 = 0b100000000000000000000000;
        const FLAG_PIPELINESTATISTICSQUERY			 = 0b1000000000000000000000000;
        const FLAG_VERTEXPIPELINESTORESANDATOMICS			 = 0b10000000000000000000000000;
        const FLAG_FRAGMENTSTORESANDATOMICS			 = 0b100000000000000000000000000;
        const FLAG_SHADERTESSELLATIONANDGEOMETRYPOINTSIZE			 = 0b1000000000000000000000000000;
        const FLAG_SHADERIMAGEGATHEREXTENDED			 = 0b10000000000000000000000000000;
        const FLAG_SHADERSTORAGEIMAGEEXTENDEDFORMATS			 = 0b100000000000000000000000000000;
        const FLAG_SHADERSTORAGEIMAGEMULTISAMPLE			 = 0b1000000000000000000000000000000;
        const FLAG_SHADERSTORAGEIMAGEREADWITHOUTFORMAT			 = 0b10000000000000000000000000000000;
        const FLAG_SHADERSTORAGEIMAGEWRITEWITHOUTFORMAT			 = 0b0;
        const FLAG_SHADERUNIFORMBUFFERARRAYDYNAMICINDEXING			 = 0b0;
        const FLAG_SHADERSAMPLEDIMAGEARRAYDYNAMICINDEXING			 = 0b0;
        const FLAG_SHADERSTORAGEBUFFERARRAYDYNAMICINDEXING			 = 0b0;
        const FLAG_SHADERSTORAGEIMAGEARRAYDYNAMICINDEXING			 = 0b0;
        const FLAG_SHADERCLIPDISTANCE			 = 0b0;
        const FLAG_SHADERCULLDISTANCE			 = 0b0;
        const FLAG_SHADERFLOAT64			 = 0b0;
        const FLAG_SHADERINT64			 = 0b0;
        const FLAG_SHADERINT16			 = 0b0;
        const FLAG_SHADERRESOURCERESIDENCY			 = 0b0;
        const FLAG_SHADERRESOURCEMINLOD			 = 0b0;
        const FLAG_SPARSEBINDING			 = 0b0;
        const FLAG_SPARSERESIDENCYBUFFER			 = 0b0;
        const FLAG_SPARSERESIDENCYIMAGE2D			 = 0b0;
        const FLAG_SPARSERESIDENCYIMAGE3D			 = 0b0;
        const FLAG_SPARSERESIDENCY2SAMPLES			 = 0b0;
        const FLAG_SPARSERESIDENCY4SAMPLES			 = 0b0;
        const FLAG_SPARSERESIDENCY8SAMPLES			 = 0b0;
        const FLAG_SPARSERESIDENCY16SAMPLES			 = 0b0;
        const FLAG_SPARSERESIDENCYALIASED			 = 0b0;
        const FLAG_VARIABLEMULTISAMPLERATE			 = 0b0;
        const FLAG_INHERITEDQUERIES			 = 0b0;
    }
}


/// A builder for `VkPhysicalDeviceFeatures`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceFeaturesBuilder {
    raw: vks::VkPhysicalDeviceFeatures,
    set_mask: PhysicalDeviceFeaturesFlags,
}

impl PhysicalDeviceFeaturesBuilder {
    pub fn new() -> PhysicalDeviceFeaturesBuilder {
        PhysicalDeviceFeaturesBuilder {
            raw: vks::VkPhysicalDeviceFeatures::default(),
            set_mask: PhysicalDeviceFeaturesFlags::default(),
        }
    }

    pub fn robust_buffer_access<'m>(mut self, robust_buffer_access: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.robustBufferAccess = robust_buffer_access as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_ROBUSTBUFFERACCESS;
        self
    }

    pub fn full_draw_index_uint_32<'m>(mut self, full_draw_index_uint_32: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fullDrawIndexUint32 = full_draw_index_uint_32 as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_FULLDRAWINDEXUINT32;
        self
    }

    pub fn image_cube_array<'m>(mut self, image_cube_array: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.imageCubeArray = image_cube_array as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_IMAGECUBEARRAY;
        self
    }

    pub fn independent_blend<'m>(mut self, independent_blend: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.independentBlend = independent_blend as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_INDEPENDENTBLEND;
        self
    }

    pub fn geometry_shader<'m>(mut self, geometry_shader: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.geometryShader = geometry_shader as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_GEOMETRYSHADER;
        self
    }

    pub fn tessellation_shader<'m>(mut self, tessellation_shader: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.tessellationShader = tessellation_shader as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_TESSELLATIONSHADER;
        self
    }

    pub fn sample_rate_shading<'m>(mut self, sample_rate_shading: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sampleRateShading = sample_rate_shading as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SAMPLERATESHADING;
        self
    }

    pub fn dual_src_blend<'m>(mut self, dual_src_blend: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.dualSrcBlend = dual_src_blend as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_DUALSRCBLEND;
        self
    }

    pub fn logic_op<'m>(mut self, logic_op: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.logicOp = logic_op as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_LOGICOP;
        self
    }

    pub fn multi_draw_indirect<'m>(mut self, multi_draw_indirect: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.multiDrawIndirect = multi_draw_indirect as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_MULTIDRAWINDIRECT;
        self
    }

    pub fn draw_indirect_first_instance<'m>(mut self, draw_indirect_first_instance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.drawIndirectFirstInstance = draw_indirect_first_instance as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_DRAWINDIRECTFIRSTINSTANCE;
        self
    }

    pub fn depth_clamp<'m>(mut self, depth_clamp: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthClamp = depth_clamp as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_DEPTHCLAMP;
        self
    }

    pub fn depth_bias_clamp<'m>(mut self, depth_bias_clamp: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthBiasClamp = depth_bias_clamp as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_DEPTHBIASCLAMP;
        self
    }

    pub fn fill_mode_non_solid<'m>(mut self, fill_mode_non_solid: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fillModeNonSolid = fill_mode_non_solid as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_FILLMODENONSOLID;
        self
    }

    pub fn depth_bounds<'m>(mut self, depth_bounds: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.depthBounds = depth_bounds as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_DEPTHBOUNDS;
        self
    }

    pub fn wide_lines<'m>(mut self, wide_lines: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.wideLines = wide_lines as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_WIDELINES;
        self
    }

    pub fn large_points<'m>(mut self, large_points: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.largePoints = large_points as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_LARGEPOINTS;
        self
    }

    pub fn alpha_to_one<'m>(mut self, alpha_to_one: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.alphaToOne = alpha_to_one as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_ALPHATOONE;
        self
    }

    pub fn multi_viewport<'m>(mut self, multi_viewport: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.multiViewport = multi_viewport as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_MULTIVIEWPORT;
        self
    }

    pub fn sampler_anisotropy<'m>(mut self, sampler_anisotropy: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.samplerAnisotropy = sampler_anisotropy as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SAMPLERANISOTROPY;
        self
    }

    pub fn texture_compression_etc2<'m>(mut self, texture_compression_etc2: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionETC2 = texture_compression_etc2 as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONETC2;
        self
    }

    pub fn texture_compression_astcldr<'m>(mut self, texture_compression_astcldr: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionASTC_LDR = texture_compression_astcldr as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONASTC_LDR;
        self
    }

    pub fn texture_compression_bc<'m>(mut self, texture_compression_bc: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.textureCompressionBC = texture_compression_bc as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONBC;
        self
    }

    pub fn occlusion_query_precise<'m>(mut self, occlusion_query_precise: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.occlusionQueryPrecise = occlusion_query_precise as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_OCCLUSIONQUERYPRECISE;
        self
    }

    pub fn pipeline_statistics_query<'m>(mut self, pipeline_statistics_query: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.pipelineStatisticsQuery = pipeline_statistics_query as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_PIPELINESTATISTICSQUERY;
        self
    }

    pub fn vertex_pipeline_stores_and_atomics<'m>(mut self, vertex_pipeline_stores_and_atomics: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.vertexPipelineStoresAndAtomics = vertex_pipeline_stores_and_atomics as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_VERTEXPIPELINESTORESANDATOMICS;
        self
    }

    pub fn fragment_stores_and_atomics<'m>(mut self, fragment_stores_and_atomics: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.fragmentStoresAndAtomics = fragment_stores_and_atomics as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_FRAGMENTSTORESANDATOMICS;
        self
    }

    pub fn shader_tessellation_and_geometry_point_size<'m>(mut self, shader_tessellation_and_geometry_point_size: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderTessellationAndGeometryPointSize = shader_tessellation_and_geometry_point_size as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERTESSELLATIONANDGEOMETRYPOINTSIZE;
        self
    }

    pub fn shader_image_gather_extended<'m>(mut self, shader_image_gather_extended: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderImageGatherExtended = shader_image_gather_extended as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERIMAGEGATHEREXTENDED;
        self
    }

    pub fn shader_storage_image_extended_formats<'m>(mut self, shader_storage_image_extended_formats: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageExtendedFormats = shader_storage_image_extended_formats as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEEXTENDEDFORMATS;
        self
    }

    pub fn shader_storage_image_multisample<'m>(mut self, shader_storage_image_multisample: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageMultisample = shader_storage_image_multisample as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEMULTISAMPLE;
        self
    }

    pub fn shader_storage_image_read_without_format<'m>(mut self, shader_storage_image_read_without_format: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageReadWithoutFormat = shader_storage_image_read_without_format as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEREADWITHOUTFORMAT;
        self
    }

    pub fn shader_storage_image_write_without_format<'m>(mut self, shader_storage_image_write_without_format: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageWriteWithoutFormat = shader_storage_image_write_without_format as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEWRITEWITHOUTFORMAT;
        self
    }

    pub fn shader_uniform_buffer_array_dynamic_indexing<'m>(mut self, shader_uniform_buffer_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderUniformBufferArrayDynamicIndexing = shader_uniform_buffer_array_dynamic_indexing as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERUNIFORMBUFFERARRAYDYNAMICINDEXING;
        self
    }

    pub fn shader_sampled_image_array_dynamic_indexing<'m>(mut self, shader_sampled_image_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderSampledImageArrayDynamicIndexing = shader_sampled_image_array_dynamic_indexing as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSAMPLEDIMAGEARRAYDYNAMICINDEXING;
        self
    }

    pub fn shader_storage_buffer_array_dynamic_indexing<'m>(mut self, shader_storage_buffer_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageBufferArrayDynamicIndexing = shader_storage_buffer_array_dynamic_indexing as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEBUFFERARRAYDYNAMICINDEXING;
        self
    }

    pub fn shader_storage_image_array_dynamic_indexing<'m>(mut self, shader_storage_image_array_dynamic_indexing: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderStorageImageArrayDynamicIndexing = shader_storage_image_array_dynamic_indexing as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEARRAYDYNAMICINDEXING;
        self
    }

    pub fn shader_clip_distance<'m>(mut self, shader_clip_distance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderClipDistance = shader_clip_distance as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERCLIPDISTANCE;
        self
    }

    pub fn shader_cull_distance<'m>(mut self, shader_cull_distance: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderCullDistance = shader_cull_distance as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERCULLDISTANCE;
        self
    }

    pub fn shader_float_64<'m>(mut self, shader_float_64: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderFloat64 = shader_float_64 as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERFLOAT64;
        self
    }

    pub fn shader_int_64<'m>(mut self, shader_int_64: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderInt64 = shader_int_64 as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERINT64;
        self
    }

    pub fn shader_int_16<'m>(mut self, shader_int_16: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderInt16 = shader_int_16 as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERINT16;
        self
    }

    pub fn shader_resource_residency<'m>(mut self, shader_resource_residency: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderResourceResidency = shader_resource_residency as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCERESIDENCY;
        self
    }

    pub fn shader_resource_min_lod<'m>(mut self, shader_resource_min_lod: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.shaderResourceMinLod = shader_resource_min_lod as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCEMINLOD;
        self
    }

    pub fn sparse_binding<'m>(mut self, sparse_binding: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseBinding = sparse_binding as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSEBINDING;
        self
    }

    pub fn sparse_residency_buffer<'m>(mut self, sparse_residency_buffer: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyBuffer = sparse_residency_buffer as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYBUFFER;
        self
    }

    pub fn sparse_residency_image_2d<'m>(mut self, sparse_residency_image_2d: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyImage2D = sparse_residency_image_2d as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE2D;
        self
    }

    pub fn sparse_residency_image_3d<'m>(mut self, sparse_residency_image_3d: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyImage3D = sparse_residency_image_3d as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE3D;
        self
    }

    pub fn sparse_residency_2samples<'m>(mut self, sparse_residency_2samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency2Samples = sparse_residency_2samples as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY2SAMPLES;
        self
    }

    pub fn sparse_residency_4samples<'m>(mut self, sparse_residency_4samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency4Samples = sparse_residency_4samples as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY4SAMPLES;
        self
    }

    pub fn sparse_residency_8samples<'m>(mut self, sparse_residency_8samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency8Samples = sparse_residency_8samples as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY8SAMPLES;
        self
    }

    pub fn sparse_residency_16_samples<'m>(mut self, sparse_residency_16_samples: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidency16Samples = sparse_residency_16_samples as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY16SAMPLES;
        self
    }

    pub fn sparse_residency_aliased<'m>(mut self, sparse_residency_aliased: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.sparseResidencyAliased = sparse_residency_aliased as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYALIASED;
        self
    }

    pub fn variable_multisample_rate<'m>(mut self, variable_multisample_rate: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.variableMultisampleRate = variable_multisample_rate as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_VARIABLEMULTISAMPLERATE;
        self
    }

    pub fn inherited_queries<'m>(mut self, inherited_queries: bool) -> PhysicalDeviceFeaturesBuilder {
        self.raw.inheritedQueries = inherited_queries as u32;
        self.set_mask |= PhysicalDeviceFeaturesFlags::FLAG_INHERITEDQUERIES;
        self
    }

    pub fn get_robust_buffer_access<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_ROBUSTBUFFERACCESS != PhysicalDeviceFeaturesFlags::FLAG_ROBUSTBUFFERACCESS { return None }
        Some( self.raw.robustBufferAccess != 0 )
    }

    pub fn get_full_draw_index_uint_32<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_FULLDRAWINDEXUINT32 != PhysicalDeviceFeaturesFlags::FLAG_FULLDRAWINDEXUINT32 { return None }
        Some( self.raw.fullDrawIndexUint32 != 0 )
    }

    pub fn get_image_cube_array<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_IMAGECUBEARRAY != PhysicalDeviceFeaturesFlags::FLAG_IMAGECUBEARRAY { return None }
        Some( self.raw.imageCubeArray != 0 )
    }

    pub fn get_independent_blend<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_INDEPENDENTBLEND != PhysicalDeviceFeaturesFlags::FLAG_INDEPENDENTBLEND { return None }
        Some( self.raw.independentBlend != 0 )
    }

    pub fn get_geometry_shader<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_GEOMETRYSHADER != PhysicalDeviceFeaturesFlags::FLAG_GEOMETRYSHADER { return None }
        Some( self.raw.geometryShader != 0 )
    }

    pub fn get_tessellation_shader<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_TESSELLATIONSHADER != PhysicalDeviceFeaturesFlags::FLAG_TESSELLATIONSHADER { return None }
        Some( self.raw.tessellationShader != 0 )
    }

    pub fn get_sample_rate_shading<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SAMPLERATESHADING != PhysicalDeviceFeaturesFlags::FLAG_SAMPLERATESHADING { return None }
        Some( self.raw.sampleRateShading != 0 )
    }

    pub fn get_dual_src_blend<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_DUALSRCBLEND != PhysicalDeviceFeaturesFlags::FLAG_DUALSRCBLEND { return None }
        Some( self.raw.dualSrcBlend != 0 )
    }

    pub fn get_logic_op<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_LOGICOP != PhysicalDeviceFeaturesFlags::FLAG_LOGICOP { return None }
        Some( self.raw.logicOp != 0 )
    }

    pub fn get_multi_draw_indirect<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_MULTIDRAWINDIRECT != PhysicalDeviceFeaturesFlags::FLAG_MULTIDRAWINDIRECT { return None }
        Some( self.raw.multiDrawIndirect != 0 )
    }

    pub fn get_draw_indirect_first_instance<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_DRAWINDIRECTFIRSTINSTANCE != PhysicalDeviceFeaturesFlags::FLAG_DRAWINDIRECTFIRSTINSTANCE { return None }
        Some( self.raw.drawIndirectFirstInstance != 0 )
    }

    pub fn get_depth_clamp<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_DEPTHCLAMP != PhysicalDeviceFeaturesFlags::FLAG_DEPTHCLAMP { return None }
        Some( self.raw.depthClamp != 0 )
    }

    pub fn get_depth_bias_clamp<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_DEPTHBIASCLAMP != PhysicalDeviceFeaturesFlags::FLAG_DEPTHBIASCLAMP { return None }
        Some( self.raw.depthBiasClamp != 0 )
    }

    pub fn get_fill_mode_non_solid<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_FILLMODENONSOLID != PhysicalDeviceFeaturesFlags::FLAG_FILLMODENONSOLID { return None }
        Some( self.raw.fillModeNonSolid != 0 )
    }

    pub fn get_depth_bounds<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_DEPTHBOUNDS != PhysicalDeviceFeaturesFlags::FLAG_DEPTHBOUNDS { return None }
        Some( self.raw.depthBounds != 0 )
    }

    pub fn get_wide_lines<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_WIDELINES != PhysicalDeviceFeaturesFlags::FLAG_WIDELINES { return None }
        Some( self.raw.wideLines != 0 )
    }

    pub fn get_large_points<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_LARGEPOINTS != PhysicalDeviceFeaturesFlags::FLAG_LARGEPOINTS { return None }
        Some( self.raw.largePoints != 0 )
    }

    pub fn get_alpha_to_one<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_ALPHATOONE != PhysicalDeviceFeaturesFlags::FLAG_ALPHATOONE { return None }
        Some( self.raw.alphaToOne != 0 )
    }

    pub fn get_multi_viewport<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_MULTIVIEWPORT != PhysicalDeviceFeaturesFlags::FLAG_MULTIVIEWPORT { return None }
        Some( self.raw.multiViewport != 0 )
    }

    pub fn get_sampler_anisotropy<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SAMPLERANISOTROPY != PhysicalDeviceFeaturesFlags::FLAG_SAMPLERANISOTROPY { return None }
        Some( self.raw.samplerAnisotropy != 0 )
    }

    pub fn get_texture_compression_etc2<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONETC2 != PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONETC2 { return None }
        Some( self.raw.textureCompressionETC2 != 0 )
    }

    pub fn get_texture_compression_astcldr<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONASTC_LDR != PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONASTC_LDR { return None }
        Some( self.raw.textureCompressionASTC_LDR != 0 )
    }

    pub fn get_texture_compression_bc<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONBC != PhysicalDeviceFeaturesFlags::FLAG_TEXTURECOMPRESSIONBC { return None }
        Some( self.raw.textureCompressionBC != 0 )
    }

    pub fn get_occlusion_query_precise<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_OCCLUSIONQUERYPRECISE != PhysicalDeviceFeaturesFlags::FLAG_OCCLUSIONQUERYPRECISE { return None }
        Some( self.raw.occlusionQueryPrecise != 0 )
    }

    pub fn get_pipeline_statistics_query<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_PIPELINESTATISTICSQUERY != PhysicalDeviceFeaturesFlags::FLAG_PIPELINESTATISTICSQUERY { return None }
        Some( self.raw.pipelineStatisticsQuery != 0 )
    }

    pub fn get_vertex_pipeline_stores_and_atomics<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_VERTEXPIPELINESTORESANDATOMICS != PhysicalDeviceFeaturesFlags::FLAG_VERTEXPIPELINESTORESANDATOMICS { return None }
        Some( self.raw.vertexPipelineStoresAndAtomics != 0 )
    }

    pub fn get_fragment_stores_and_atomics<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_FRAGMENTSTORESANDATOMICS != PhysicalDeviceFeaturesFlags::FLAG_FRAGMENTSTORESANDATOMICS { return None }
        Some( self.raw.fragmentStoresAndAtomics != 0 )
    }

    pub fn get_shader_tessellation_and_geometry_point_size<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERTESSELLATIONANDGEOMETRYPOINTSIZE != PhysicalDeviceFeaturesFlags::FLAG_SHADERTESSELLATIONANDGEOMETRYPOINTSIZE { return None }
        Some( self.raw.shaderTessellationAndGeometryPointSize != 0 )
    }

    pub fn get_shader_image_gather_extended<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERIMAGEGATHEREXTENDED != PhysicalDeviceFeaturesFlags::FLAG_SHADERIMAGEGATHEREXTENDED { return None }
        Some( self.raw.shaderImageGatherExtended != 0 )
    }

    pub fn get_shader_storage_image_extended_formats<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEEXTENDEDFORMATS != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEEXTENDEDFORMATS { return None }
        Some( self.raw.shaderStorageImageExtendedFormats != 0 )
    }

    pub fn get_shader_storage_image_multisample<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEMULTISAMPLE != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEMULTISAMPLE { return None }
        Some( self.raw.shaderStorageImageMultisample != 0 )
    }

    pub fn get_shader_storage_image_read_without_format<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEREADWITHOUTFORMAT != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEREADWITHOUTFORMAT { return None }
        Some( self.raw.shaderStorageImageReadWithoutFormat != 0 )
    }

    pub fn get_shader_storage_image_write_without_format<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEWRITEWITHOUTFORMAT != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEWRITEWITHOUTFORMAT { return None }
        Some( self.raw.shaderStorageImageWriteWithoutFormat != 0 )
    }

    pub fn get_shader_uniform_buffer_array_dynamic_indexing<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERUNIFORMBUFFERARRAYDYNAMICINDEXING != PhysicalDeviceFeaturesFlags::FLAG_SHADERUNIFORMBUFFERARRAYDYNAMICINDEXING { return None }
        Some( self.raw.shaderUniformBufferArrayDynamicIndexing != 0 )
    }

    pub fn get_shader_sampled_image_array_dynamic_indexing<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSAMPLEDIMAGEARRAYDYNAMICINDEXING != PhysicalDeviceFeaturesFlags::FLAG_SHADERSAMPLEDIMAGEARRAYDYNAMICINDEXING { return None }
        Some( self.raw.shaderSampledImageArrayDynamicIndexing != 0 )
    }

    pub fn get_shader_storage_buffer_array_dynamic_indexing<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEBUFFERARRAYDYNAMICINDEXING != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEBUFFERARRAYDYNAMICINDEXING { return None }
        Some( self.raw.shaderStorageBufferArrayDynamicIndexing != 0 )
    }

    pub fn get_shader_storage_image_array_dynamic_indexing<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEARRAYDYNAMICINDEXING != PhysicalDeviceFeaturesFlags::FLAG_SHADERSTORAGEIMAGEARRAYDYNAMICINDEXING { return None }
        Some( self.raw.shaderStorageImageArrayDynamicIndexing != 0 )
    }

    pub fn get_shader_clip_distance<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERCLIPDISTANCE != PhysicalDeviceFeaturesFlags::FLAG_SHADERCLIPDISTANCE { return None }
        Some( self.raw.shaderClipDistance != 0 )
    }

    pub fn get_shader_cull_distance<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERCULLDISTANCE != PhysicalDeviceFeaturesFlags::FLAG_SHADERCULLDISTANCE { return None }
        Some( self.raw.shaderCullDistance != 0 )
    }

    pub fn get_shader_float_64<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERFLOAT64 != PhysicalDeviceFeaturesFlags::FLAG_SHADERFLOAT64 { return None }
        Some( self.raw.shaderFloat64 != 0 )
    }

    pub fn get_shader_int_64<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERINT64 != PhysicalDeviceFeaturesFlags::FLAG_SHADERINT64 { return None }
        Some( self.raw.shaderInt64 != 0 )
    }

    pub fn get_shader_int_16<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERINT16 != PhysicalDeviceFeaturesFlags::FLAG_SHADERINT16 { return None }
        Some( self.raw.shaderInt16 != 0 )
    }

    pub fn get_shader_resource_residency<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCERESIDENCY != PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCERESIDENCY { return None }
        Some( self.raw.shaderResourceResidency != 0 )
    }

    pub fn get_shader_resource_min_lod<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCEMINLOD != PhysicalDeviceFeaturesFlags::FLAG_SHADERRESOURCEMINLOD { return None }
        Some( self.raw.shaderResourceMinLod != 0 )
    }

    pub fn get_sparse_binding<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSEBINDING != PhysicalDeviceFeaturesFlags::FLAG_SPARSEBINDING { return None }
        Some( self.raw.sparseBinding != 0 )
    }

    pub fn get_sparse_residency_buffer<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYBUFFER != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYBUFFER { return None }
        Some( self.raw.sparseResidencyBuffer != 0 )
    }

    pub fn get_sparse_residency_image_2d<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE2D != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE2D { return None }
        Some( self.raw.sparseResidencyImage2D != 0 )
    }

    pub fn get_sparse_residency_image_3d<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE3D != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYIMAGE3D { return None }
        Some( self.raw.sparseResidencyImage3D != 0 )
    }

    pub fn get_sparse_residency_2samples<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY2SAMPLES != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY2SAMPLES { return None }
        Some( self.raw.sparseResidency2Samples != 0 )
    }

    pub fn get_sparse_residency_4samples<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY4SAMPLES != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY4SAMPLES { return None }
        Some( self.raw.sparseResidency4Samples != 0 )
    }

    pub fn get_sparse_residency_8samples<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY8SAMPLES != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY8SAMPLES { return None }
        Some( self.raw.sparseResidency8Samples != 0 )
    }

    pub fn get_sparse_residency_16_samples<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY16SAMPLES != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCY16SAMPLES { return None }
        Some( self.raw.sparseResidency16Samples != 0 )
    }

    pub fn get_sparse_residency_aliased<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYALIASED != PhysicalDeviceFeaturesFlags::FLAG_SPARSERESIDENCYALIASED { return None }
        Some( self.raw.sparseResidencyAliased != 0 )
    }

    pub fn get_variable_multisample_rate<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_VARIABLEMULTISAMPLERATE != PhysicalDeviceFeaturesFlags::FLAG_VARIABLEMULTISAMPLERATE { return None }
        Some( self.raw.variableMultisampleRate != 0 )
    }

    pub fn get_inherited_queries<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceFeaturesFlags::FLAG_INHERITEDQUERIES != PhysicalDeviceFeaturesFlags::FLAG_INHERITEDQUERIES { return None }
        Some( self.raw.inheritedQueries != 0 )
    }

    pub fn build(self) -> PhysicalDeviceFeatures {
        PhysicalDeviceFeatures {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceSparseProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSparseProperties {
    raw: vks::VkPhysicalDeviceSparseProperties,
}

impl PhysicalDeviceSparseProperties {
    pub fn builder() -> PhysicalDeviceSparsePropertiesBuilder {
        PhysicalDeviceSparsePropertiesBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSparseProperties) -> PhysicalDeviceSparseProperties {
        PhysicalDeviceSparseProperties { raw, }
    }

    pub fn residency_standard_2d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DBlockShape != 0
    }

    pub fn residency_standard_2d_multisample_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard2DMultisampleBlockShape != 0
    }

    pub fn residency_standard_3d_block_shape<'a>(&'a self) -> bool {
        self.raw.residencyStandard3DBlockShape != 0
    }

    pub fn residency_aligned_mip_size<'a>(&'a self) -> bool {
        self.raw.residencyAlignedMipSize != 0
    }

    pub fn residency_non_resident_strict<'a>(&'a self) -> bool {
        self.raw.residencyNonResidentStrict != 0
    }

    pub fn set_residency_standard_2d_block_shape<'m>(&mut self, residency_standard_2d_block_shape: bool) {
        self.raw.residencyStandard2DBlockShape = residency_standard_2d_block_shape as u32;
    }

    pub fn set_residency_standard_2d_multisample_block_shape<'m>(&mut self, residency_standard_2d_multisample_block_shape: bool) {
        self.raw.residencyStandard2DMultisampleBlockShape = residency_standard_2d_multisample_block_shape as u32;
    }

    pub fn set_residency_standard_3d_block_shape<'m>(&mut self, residency_standard_3d_block_shape: bool) {
        self.raw.residencyStandard3DBlockShape = residency_standard_3d_block_shape as u32;
    }

    pub fn set_residency_aligned_mip_size<'m>(&mut self, residency_aligned_mip_size: bool) {
        self.raw.residencyAlignedMipSize = residency_aligned_mip_size as u32;
    }

    pub fn set_residency_non_resident_strict<'m>(&mut self, residency_non_resident_strict: bool) {
        self.raw.residencyNonResidentStrict = residency_non_resident_strict as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSparseProperties {
        &self.raw
    }
}

impl From<PhysicalDeviceSparseProperties> for vks::VkPhysicalDeviceSparseProperties {
    fn from(f: PhysicalDeviceSparseProperties) -> vks::VkPhysicalDeviceSparseProperties {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceSparseProperties`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceSparsePropertiesFlags: u32 {
        const FLAG_RESIDENCYSTANDARD2DBLOCKSHAPE			 = 0b1;
        const FLAG_RESIDENCYSTANDARD2DMULTISAMPLEBLOCKSHAPE			 = 0b10;
        const FLAG_RESIDENCYSTANDARD3DBLOCKSHAPE			 = 0b100;
        const FLAG_RESIDENCYALIGNEDMIPSIZE			 = 0b1000;
        const FLAG_RESIDENCYNONRESIDENTSTRICT			 = 0b10000;
    }
}


/// A builder for `VkPhysicalDeviceSparseProperties`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSparsePropertiesBuilder {
    raw: vks::VkPhysicalDeviceSparseProperties,
    set_mask: PhysicalDeviceSparsePropertiesFlags,
}

impl PhysicalDeviceSparsePropertiesBuilder {
    pub fn new() -> PhysicalDeviceSparsePropertiesBuilder {
        PhysicalDeviceSparsePropertiesBuilder {
            raw: vks::VkPhysicalDeviceSparseProperties::default(),
            set_mask: PhysicalDeviceSparsePropertiesFlags::default(),
        }
    }

    pub fn residency_standard_2d_block_shape<'m>(mut self, residency_standard_2d_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard2DBlockShape = residency_standard_2d_block_shape as u32;
        self.set_mask |= PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DBLOCKSHAPE;
        self
    }

    pub fn residency_standard_2d_multisample_block_shape<'m>(mut self, residency_standard_2d_multisample_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard2DMultisampleBlockShape = residency_standard_2d_multisample_block_shape as u32;
        self.set_mask |= PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DMULTISAMPLEBLOCKSHAPE;
        self
    }

    pub fn residency_standard_3d_block_shape<'m>(mut self, residency_standard_3d_block_shape: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyStandard3DBlockShape = residency_standard_3d_block_shape as u32;
        self.set_mask |= PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD3DBLOCKSHAPE;
        self
    }

    pub fn residency_aligned_mip_size<'m>(mut self, residency_aligned_mip_size: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyAlignedMipSize = residency_aligned_mip_size as u32;
        self.set_mask |= PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYALIGNEDMIPSIZE;
        self
    }

    pub fn residency_non_resident_strict<'m>(mut self, residency_non_resident_strict: bool) -> PhysicalDeviceSparsePropertiesBuilder {
        self.raw.residencyNonResidentStrict = residency_non_resident_strict as u32;
        self.set_mask |= PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYNONRESIDENTSTRICT;
        self
    }

    pub fn get_residency_standard_2d_block_shape<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DBLOCKSHAPE != PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DBLOCKSHAPE { return None }
        Some( self.raw.residencyStandard2DBlockShape != 0 )
    }

    pub fn get_residency_standard_2d_multisample_block_shape<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DMULTISAMPLEBLOCKSHAPE != PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD2DMULTISAMPLEBLOCKSHAPE { return None }
        Some( self.raw.residencyStandard2DMultisampleBlockShape != 0 )
    }

    pub fn get_residency_standard_3d_block_shape<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD3DBLOCKSHAPE != PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYSTANDARD3DBLOCKSHAPE { return None }
        Some( self.raw.residencyStandard3DBlockShape != 0 )
    }

    pub fn get_residency_aligned_mip_size<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYALIGNEDMIPSIZE != PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYALIGNEDMIPSIZE { return None }
        Some( self.raw.residencyAlignedMipSize != 0 )
    }

    pub fn get_residency_non_resident_strict<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYNONRESIDENTSTRICT != PhysicalDeviceSparsePropertiesFlags::FLAG_RESIDENCYNONRESIDENTSTRICT { return None }
        Some( self.raw.residencyNonResidentStrict != 0 )
    }

    pub fn build(self) -> PhysicalDeviceSparseProperties {
        PhysicalDeviceSparseProperties {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceLimits`.
///
/// compute stage limits
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceLimits {
    raw: vks::VkPhysicalDeviceLimits,
}

impl PhysicalDeviceLimits {
    pub fn builder() -> PhysicalDeviceLimitsBuilder {
        PhysicalDeviceLimitsBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceLimits) -> PhysicalDeviceLimits {
        PhysicalDeviceLimits { raw, }
    }

    pub fn max_image_dimension_1d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension1D.into()
    }

    pub fn max_image_dimension_2d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension2D.into()
    }

    pub fn max_image_dimension_3d<'a>(&'a self) -> u32 {
        self.raw.maxImageDimension3D.into()
    }

    pub fn max_image_dimension_cube<'a>(&'a self) -> u32 {
        self.raw.maxImageDimensionCube.into()
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn max_texel_buffer_elements<'a>(&'a self) -> u32 {
        self.raw.maxTexelBufferElements.into()
    }

    pub fn max_uniform_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxUniformBufferRange.into()
    }

    pub fn max_storage_buffer_range<'a>(&'a self) -> u32 {
        self.raw.maxStorageBufferRange.into()
    }

    pub fn max_push_constants_size<'a>(&'a self) -> u32 {
        self.raw.maxPushConstantsSize.into()
    }

    pub fn max_memory_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxMemoryAllocationCount.into()
    }

    pub fn max_sampler_allocation_count<'a>(&'a self) -> u32 {
        self.raw.maxSamplerAllocationCount.into()
    }

    pub fn buffer_image_granularity<'a>(&'a self) -> u64 {
        self.raw.bufferImageGranularity.into()
    }

    pub fn sparse_address_space_size<'a>(&'a self) -> u64 {
        self.raw.sparseAddressSpaceSize.into()
    }

    pub fn max_bound_descriptor_sets<'a>(&'a self) -> u32 {
        self.raw.maxBoundDescriptorSets.into()
    }

    pub fn max_per_stage_descriptor_samplers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSamplers.into()
    }

    pub fn max_per_stage_descriptor_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorUniformBuffers.into()
    }

    pub fn max_per_stage_descriptor_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageBuffers.into()
    }

    pub fn max_per_stage_descriptor_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorSampledImages.into()
    }

    pub fn max_per_stage_descriptor_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorStorageImages.into()
    }

    pub fn max_per_stage_descriptor_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxPerStageDescriptorInputAttachments.into()
    }

    pub fn max_per_stage_resources<'a>(&'a self) -> u32 {
        self.raw.maxPerStageResources.into()
    }

    pub fn max_descriptor_set_samplers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSamplers.into()
    }

    pub fn max_descriptor_set_uniform_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffers.into()
    }

    pub fn max_descriptor_set_uniform_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetUniformBuffersDynamic.into()
    }

    pub fn max_descriptor_set_storage_buffers<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffers.into()
    }

    pub fn max_descriptor_set_storage_buffers_dynamic<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageBuffersDynamic.into()
    }

    pub fn max_descriptor_set_sampled_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetSampledImages.into()
    }

    pub fn max_descriptor_set_storage_images<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetStorageImages.into()
    }

    pub fn max_descriptor_set_input_attachments<'a>(&'a self) -> u32 {
        self.raw.maxDescriptorSetInputAttachments.into()
    }

    pub fn max_vertex_input_attributes<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributes.into()
    }

    pub fn max_vertex_input_bindings<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindings.into()
    }

    pub fn max_vertex_input_attribute_offset<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputAttributeOffset.into()
    }

    pub fn max_vertex_input_binding_stride<'a>(&'a self) -> u32 {
        self.raw.maxVertexInputBindingStride.into()
    }

    pub fn max_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxVertexOutputComponents.into()
    }

    pub fn max_tessellation_generation_level<'a>(&'a self) -> u32 {
        self.raw.maxTessellationGenerationLevel.into()
    }

    pub fn max_tessellation_patch_size<'a>(&'a self) -> u32 {
        self.raw.maxTessellationPatchSize.into()
    }

    pub fn max_tessellation_control_per_vertex_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexInputComponents.into()
    }

    pub fn max_tessellation_control_per_vertex_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerVertexOutputComponents.into()
    }

    pub fn max_tessellation_control_per_patch_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlPerPatchOutputComponents.into()
    }

    pub fn max_tessellation_control_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationControlTotalOutputComponents.into()
    }

    pub fn max_tessellation_evaluation_input_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationInputComponents.into()
    }

    pub fn max_tessellation_evaluation_output_components<'a>(&'a self) -> u32 {
        self.raw.maxTessellationEvaluationOutputComponents.into()
    }

    pub fn max_geometry_shader_invocations<'a>(&'a self) -> u32 {
        self.raw.maxGeometryShaderInvocations.into()
    }

    pub fn max_geometry_input_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryInputComponents.into()
    }

    pub fn max_geometry_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputComponents.into()
    }

    pub fn max_geometry_output_vertices<'a>(&'a self) -> u32 {
        self.raw.maxGeometryOutputVertices.into()
    }

    pub fn max_geometry_total_output_components<'a>(&'a self) -> u32 {
        self.raw.maxGeometryTotalOutputComponents.into()
    }

    pub fn max_fragment_input_components<'a>(&'a self) -> u32 {
        self.raw.maxFragmentInputComponents.into()
    }

    pub fn max_fragment_output_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentOutputAttachments.into()
    }

    pub fn max_fragment_dual_src_attachments<'a>(&'a self) -> u32 {
        self.raw.maxFragmentDualSrcAttachments.into()
    }

    pub fn max_fragment_combined_output_resources<'a>(&'a self) -> u32 {
        self.raw.maxFragmentCombinedOutputResources.into()
    }

    pub fn max_compute_shared_memory_size<'a>(&'a self) -> u32 {
        self.raw.maxComputeSharedMemorySize.into()
    }

    pub fn max_compute_work_group_count<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupCount as *const _, 3 as usize) }
    }

    pub fn max_compute_work_group_invocations<'a>(&'a self) -> u32 {
        self.raw.maxComputeWorkGroupInvocations.into()
    }

    pub fn max_compute_work_group_size<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupSize as *const _, 3 as usize) }
    }

    pub fn sub_pixel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelPrecisionBits.into()
    }

    pub fn sub_texel_precision_bits<'a>(&'a self) -> u32 {
        self.raw.subTexelPrecisionBits.into()
    }

    pub fn mipmap_precision_bits<'a>(&'a self) -> u32 {
        self.raw.mipmapPrecisionBits.into()
    }

    pub fn max_draw_indexed_index_value<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndexedIndexValue.into()
    }

    pub fn max_draw_indirect_count<'a>(&'a self) -> u32 {
        self.raw.maxDrawIndirectCount.into()
    }

    pub fn max_sampler_lod_bias<'a>(&'a self) -> f32 {
        self.raw.maxSamplerLodBias.into()
    }

    pub fn max_sampler_anisotropy<'a>(&'a self) -> f32 {
        self.raw.maxSamplerAnisotropy.into()
    }

    pub fn max_viewports<'a>(&'a self) -> u32 {
        self.raw.maxViewports.into()
    }

    pub fn max_viewport_dimensions<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.maxViewportDimensions as *const _, 2 as usize) }
    }

    pub fn viewport_bounds_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.viewportBoundsRange as *const _, 2 as usize) }
    }

    pub fn viewport_sub_pixel_bits<'a>(&'a self) -> u32 {
        self.raw.viewportSubPixelBits.into()
    }

    pub fn min_memory_map_alignment<'a>(&'a self) -> usize {
        self.raw.minMemoryMapAlignment.into()
    }

    pub fn min_texel_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minTexelBufferOffsetAlignment.into()
    }

    pub fn min_uniform_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minUniformBufferOffsetAlignment.into()
    }

    pub fn min_storage_buffer_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.minStorageBufferOffsetAlignment.into()
    }

    pub fn min_texel_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelOffset.into()
    }

    pub fn max_texel_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelOffset.into()
    }

    pub fn min_texel_gather_offset<'a>(&'a self) -> i32 {
        self.raw.minTexelGatherOffset.into()
    }

    pub fn max_texel_gather_offset<'a>(&'a self) -> u32 {
        self.raw.maxTexelGatherOffset.into()
    }

    pub fn min_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.minInterpolationOffset.into()
    }

    pub fn max_interpolation_offset<'a>(&'a self) -> f32 {
        self.raw.maxInterpolationOffset.into()
    }

    pub fn sub_pixel_interpolation_offset_bits<'a>(&'a self) -> u32 {
        self.raw.subPixelInterpolationOffsetBits.into()
    }

    pub fn max_framebuffer_width<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferWidth.into()
    }

    pub fn max_framebuffer_height<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferHeight.into()
    }

    pub fn max_framebuffer_layers<'a>(&'a self) -> u32 {
        self.raw.maxFramebufferLayers.into()
    }

    pub fn framebuffer_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferColorSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_color_sample_counts: error converting flags")
    }

    pub fn framebuffer_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferDepthSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_depth_sample_counts: error converting flags")
    }

    pub fn framebuffer_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferStencilSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_stencil_sample_counts: error converting flags")
    }

    pub fn framebuffer_no_attachments_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.framebufferNoAttachmentsSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_no_attachments_sample_counts: error converting flags")
    }

    pub fn max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.maxColorAttachments.into()
    }

    pub fn sampled_image_color_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageColorSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_color_sample_counts: error converting flags")
    }

    pub fn sampled_image_integer_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageIntegerSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_integer_sample_counts: error converting flags")
    }

    pub fn sampled_image_depth_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageDepthSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_depth_sample_counts: error converting flags")
    }

    pub fn sampled_image_stencil_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.sampledImageStencilSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_stencil_sample_counts: error converting flags")
    }

    pub fn storage_image_sample_counts<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.storageImageSampleCounts)
            .expect("PhysicalDeviceLimits::storage_image_sample_counts: error converting flags")
    }

    pub fn max_sample_mask_words<'a>(&'a self) -> u32 {
        self.raw.maxSampleMaskWords.into()
    }

    pub fn timestamp_compute_and_graphics<'a>(&'a self) -> bool {
        self.raw.timestampComputeAndGraphics != 0
    }

    pub fn timestamp_period<'a>(&'a self) -> f32 {
        self.raw.timestampPeriod.into()
    }

    pub fn max_clip_distances<'a>(&'a self) -> u32 {
        self.raw.maxClipDistances.into()
    }

    pub fn max_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCullDistances.into()
    }

    pub fn max_combined_clip_and_cull_distances<'a>(&'a self) -> u32 {
        self.raw.maxCombinedClipAndCullDistances.into()
    }

    pub fn discrete_queue_priorities<'a>(&'a self) -> u32 {
        self.raw.discreteQueuePriorities.into()
    }

    pub fn point_size_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.pointSizeRange as *const _, 2 as usize) }
    }

    pub fn line_width_range<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.lineWidthRange as *const _, 2 as usize) }
    }

    pub fn point_size_granularity<'a>(&'a self) -> f32 {
        self.raw.pointSizeGranularity.into()
    }

    pub fn line_width_granularity<'a>(&'a self) -> f32 {
        self.raw.lineWidthGranularity.into()
    }

    pub fn strict_lines<'a>(&'a self) -> bool {
        self.raw.strictLines != 0
    }

    pub fn standard_sample_locations<'a>(&'a self) -> bool {
        self.raw.standardSampleLocations != 0
    }

    pub fn optimal_buffer_copy_offset_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyOffsetAlignment.into()
    }

    pub fn optimal_buffer_copy_row_pitch_alignment<'a>(&'a self) -> u64 {
        self.raw.optimalBufferCopyRowPitchAlignment.into()
    }

    pub fn non_coherent_atom_size<'a>(&'a self) -> u64 {
        self.raw.nonCoherentAtomSize.into()
    }

    pub fn set_max_image_dimension_1d<'m>(&mut self, max_image_dimension_1d: u32) {
        self.raw.maxImageDimension1D = max_image_dimension_1d.into();
    }

    pub fn set_max_image_dimension_2d<'m>(&mut self, max_image_dimension_2d: u32) {
        self.raw.maxImageDimension2D = max_image_dimension_2d.into();
    }

    pub fn set_max_image_dimension_3d<'m>(&mut self, max_image_dimension_3d: u32) {
        self.raw.maxImageDimension3D = max_image_dimension_3d.into();
    }

    pub fn set_max_image_dimension_cube<'m>(&mut self, max_image_dimension_cube: u32) {
        self.raw.maxImageDimensionCube = max_image_dimension_cube.into();
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_max_texel_buffer_elements<'m>(&mut self, max_texel_buffer_elements: u32) {
        self.raw.maxTexelBufferElements = max_texel_buffer_elements.into();
    }

    pub fn set_max_uniform_buffer_range<'m>(&mut self, max_uniform_buffer_range: u32) {
        self.raw.maxUniformBufferRange = max_uniform_buffer_range.into();
    }

    pub fn set_max_storage_buffer_range<'m>(&mut self, max_storage_buffer_range: u32) {
        self.raw.maxStorageBufferRange = max_storage_buffer_range.into();
    }

    pub fn set_max_push_constants_size<'m>(&mut self, max_push_constants_size: u32) {
        self.raw.maxPushConstantsSize = max_push_constants_size.into();
    }

    pub fn set_max_memory_allocation_count<'m>(&mut self, max_memory_allocation_count: u32) {
        self.raw.maxMemoryAllocationCount = max_memory_allocation_count.into();
    }

    pub fn set_max_sampler_allocation_count<'m>(&mut self, max_sampler_allocation_count: u32) {
        self.raw.maxSamplerAllocationCount = max_sampler_allocation_count.into();
    }

    pub fn set_buffer_image_granularity<'m>(&mut self, buffer_image_granularity: u64) {
        self.raw.bufferImageGranularity = buffer_image_granularity.into();
    }

    pub fn set_sparse_address_space_size<'m>(&mut self, sparse_address_space_size: u64) {
        self.raw.sparseAddressSpaceSize = sparse_address_space_size.into();
    }

    pub fn set_max_bound_descriptor_sets<'m>(&mut self, max_bound_descriptor_sets: u32) {
        self.raw.maxBoundDescriptorSets = max_bound_descriptor_sets.into();
    }

    pub fn set_max_per_stage_descriptor_samplers<'m>(&mut self, max_per_stage_descriptor_samplers: u32) {
        self.raw.maxPerStageDescriptorSamplers = max_per_stage_descriptor_samplers.into();
    }

    pub fn set_max_per_stage_descriptor_uniform_buffers<'m>(&mut self, max_per_stage_descriptor_uniform_buffers: u32) {
        self.raw.maxPerStageDescriptorUniformBuffers = max_per_stage_descriptor_uniform_buffers.into();
    }

    pub fn set_max_per_stage_descriptor_storage_buffers<'m>(&mut self, max_per_stage_descriptor_storage_buffers: u32) {
        self.raw.maxPerStageDescriptorStorageBuffers = max_per_stage_descriptor_storage_buffers.into();
    }

    pub fn set_max_per_stage_descriptor_sampled_images<'m>(&mut self, max_per_stage_descriptor_sampled_images: u32) {
        self.raw.maxPerStageDescriptorSampledImages = max_per_stage_descriptor_sampled_images.into();
    }

    pub fn set_max_per_stage_descriptor_storage_images<'m>(&mut self, max_per_stage_descriptor_storage_images: u32) {
        self.raw.maxPerStageDescriptorStorageImages = max_per_stage_descriptor_storage_images.into();
    }

    pub fn set_max_per_stage_descriptor_input_attachments<'m>(&mut self, max_per_stage_descriptor_input_attachments: u32) {
        self.raw.maxPerStageDescriptorInputAttachments = max_per_stage_descriptor_input_attachments.into();
    }

    pub fn set_max_per_stage_resources<'m>(&mut self, max_per_stage_resources: u32) {
        self.raw.maxPerStageResources = max_per_stage_resources.into();
    }

    pub fn set_max_descriptor_set_samplers<'m>(&mut self, max_descriptor_set_samplers: u32) {
        self.raw.maxDescriptorSetSamplers = max_descriptor_set_samplers.into();
    }

    pub fn set_max_descriptor_set_uniform_buffers<'m>(&mut self, max_descriptor_set_uniform_buffers: u32) {
        self.raw.maxDescriptorSetUniformBuffers = max_descriptor_set_uniform_buffers.into();
    }

    pub fn set_max_descriptor_set_uniform_buffers_dynamic<'m>(&mut self, max_descriptor_set_uniform_buffers_dynamic: u32) {
        self.raw.maxDescriptorSetUniformBuffersDynamic = max_descriptor_set_uniform_buffers_dynamic.into();
    }

    pub fn set_max_descriptor_set_storage_buffers<'m>(&mut self, max_descriptor_set_storage_buffers: u32) {
        self.raw.maxDescriptorSetStorageBuffers = max_descriptor_set_storage_buffers.into();
    }

    pub fn set_max_descriptor_set_storage_buffers_dynamic<'m>(&mut self, max_descriptor_set_storage_buffers_dynamic: u32) {
        self.raw.maxDescriptorSetStorageBuffersDynamic = max_descriptor_set_storage_buffers_dynamic.into();
    }

    pub fn set_max_descriptor_set_sampled_images<'m>(&mut self, max_descriptor_set_sampled_images: u32) {
        self.raw.maxDescriptorSetSampledImages = max_descriptor_set_sampled_images.into();
    }

    pub fn set_max_descriptor_set_storage_images<'m>(&mut self, max_descriptor_set_storage_images: u32) {
        self.raw.maxDescriptorSetStorageImages = max_descriptor_set_storage_images.into();
    }

    pub fn set_max_descriptor_set_input_attachments<'m>(&mut self, max_descriptor_set_input_attachments: u32) {
        self.raw.maxDescriptorSetInputAttachments = max_descriptor_set_input_attachments.into();
    }

    pub fn set_max_vertex_input_attributes<'m>(&mut self, max_vertex_input_attributes: u32) {
        self.raw.maxVertexInputAttributes = max_vertex_input_attributes.into();
    }

    pub fn set_max_vertex_input_bindings<'m>(&mut self, max_vertex_input_bindings: u32) {
        self.raw.maxVertexInputBindings = max_vertex_input_bindings.into();
    }

    pub fn set_max_vertex_input_attribute_offset<'m>(&mut self, max_vertex_input_attribute_offset: u32) {
        self.raw.maxVertexInputAttributeOffset = max_vertex_input_attribute_offset.into();
    }

    pub fn set_max_vertex_input_binding_stride<'m>(&mut self, max_vertex_input_binding_stride: u32) {
        self.raw.maxVertexInputBindingStride = max_vertex_input_binding_stride.into();
    }

    pub fn set_max_vertex_output_components<'m>(&mut self, max_vertex_output_components: u32) {
        self.raw.maxVertexOutputComponents = max_vertex_output_components.into();
    }

    pub fn set_max_tessellation_generation_level<'m>(&mut self, max_tessellation_generation_level: u32) {
        self.raw.maxTessellationGenerationLevel = max_tessellation_generation_level.into();
    }

    pub fn set_max_tessellation_patch_size<'m>(&mut self, max_tessellation_patch_size: u32) {
        self.raw.maxTessellationPatchSize = max_tessellation_patch_size.into();
    }

    pub fn set_max_tessellation_control_per_vertex_input_components<'m>(&mut self, max_tessellation_control_per_vertex_input_components: u32) {
        self.raw.maxTessellationControlPerVertexInputComponents = max_tessellation_control_per_vertex_input_components.into();
    }

    pub fn set_max_tessellation_control_per_vertex_output_components<'m>(&mut self, max_tessellation_control_per_vertex_output_components: u32) {
        self.raw.maxTessellationControlPerVertexOutputComponents = max_tessellation_control_per_vertex_output_components.into();
    }

    pub fn set_max_tessellation_control_per_patch_output_components<'m>(&mut self, max_tessellation_control_per_patch_output_components: u32) {
        self.raw.maxTessellationControlPerPatchOutputComponents = max_tessellation_control_per_patch_output_components.into();
    }

    pub fn set_max_tessellation_control_total_output_components<'m>(&mut self, max_tessellation_control_total_output_components: u32) {
        self.raw.maxTessellationControlTotalOutputComponents = max_tessellation_control_total_output_components.into();
    }

    pub fn set_max_tessellation_evaluation_input_components<'m>(&mut self, max_tessellation_evaluation_input_components: u32) {
        self.raw.maxTessellationEvaluationInputComponents = max_tessellation_evaluation_input_components.into();
    }

    pub fn set_max_tessellation_evaluation_output_components<'m>(&mut self, max_tessellation_evaluation_output_components: u32) {
        self.raw.maxTessellationEvaluationOutputComponents = max_tessellation_evaluation_output_components.into();
    }

    pub fn set_max_geometry_shader_invocations<'m>(&mut self, max_geometry_shader_invocations: u32) {
        self.raw.maxGeometryShaderInvocations = max_geometry_shader_invocations.into();
    }

    pub fn set_max_geometry_input_components<'m>(&mut self, max_geometry_input_components: u32) {
        self.raw.maxGeometryInputComponents = max_geometry_input_components.into();
    }

    pub fn set_max_geometry_output_components<'m>(&mut self, max_geometry_output_components: u32) {
        self.raw.maxGeometryOutputComponents = max_geometry_output_components.into();
    }

    pub fn set_max_geometry_output_vertices<'m>(&mut self, max_geometry_output_vertices: u32) {
        self.raw.maxGeometryOutputVertices = max_geometry_output_vertices.into();
    }

    pub fn set_max_geometry_total_output_components<'m>(&mut self, max_geometry_total_output_components: u32) {
        self.raw.maxGeometryTotalOutputComponents = max_geometry_total_output_components.into();
    }

    pub fn set_max_fragment_input_components<'m>(&mut self, max_fragment_input_components: u32) {
        self.raw.maxFragmentInputComponents = max_fragment_input_components.into();
    }

    pub fn set_max_fragment_output_attachments<'m>(&mut self, max_fragment_output_attachments: u32) {
        self.raw.maxFragmentOutputAttachments = max_fragment_output_attachments.into();
    }

    pub fn set_max_fragment_dual_src_attachments<'m>(&mut self, max_fragment_dual_src_attachments: u32) {
        self.raw.maxFragmentDualSrcAttachments = max_fragment_dual_src_attachments.into();
    }

    pub fn set_max_fragment_combined_output_resources<'m>(&mut self, max_fragment_combined_output_resources: u32) {
        self.raw.maxFragmentCombinedOutputResources = max_fragment_combined_output_resources.into();
    }

    pub fn set_max_compute_shared_memory_size<'m>(&mut self, max_compute_shared_memory_size: u32) {
        self.raw.maxComputeSharedMemorySize = max_compute_shared_memory_size.into();
    }

    pub fn set_max_compute_work_group_count<'m>(&mut self, max_compute_work_group_count: [u32; 3]) {
        self.raw.maxComputeWorkGroupCount = max_compute_work_group_count;
    }

    pub fn set_max_compute_work_group_invocations<'m>(&mut self, max_compute_work_group_invocations: u32) {
        self.raw.maxComputeWorkGroupInvocations = max_compute_work_group_invocations.into();
    }

    pub fn set_max_compute_work_group_size<'m>(&mut self, max_compute_work_group_size: [u32; 3]) {
        self.raw.maxComputeWorkGroupSize = max_compute_work_group_size;
    }

    pub fn set_sub_pixel_precision_bits<'m>(&mut self, sub_pixel_precision_bits: u32) {
        self.raw.subPixelPrecisionBits = sub_pixel_precision_bits.into();
    }

    pub fn set_sub_texel_precision_bits<'m>(&mut self, sub_texel_precision_bits: u32) {
        self.raw.subTexelPrecisionBits = sub_texel_precision_bits.into();
    }

    pub fn set_mipmap_precision_bits<'m>(&mut self, mipmap_precision_bits: u32) {
        self.raw.mipmapPrecisionBits = mipmap_precision_bits.into();
    }

    pub fn set_max_draw_indexed_index_value<'m>(&mut self, max_draw_indexed_index_value: u32) {
        self.raw.maxDrawIndexedIndexValue = max_draw_indexed_index_value.into();
    }

    pub fn set_max_draw_indirect_count<'m>(&mut self, max_draw_indirect_count: u32) {
        self.raw.maxDrawIndirectCount = max_draw_indirect_count.into();
    }

    pub fn set_max_sampler_lod_bias<'m>(&mut self, max_sampler_lod_bias: f32) {
        self.raw.maxSamplerLodBias = max_sampler_lod_bias.into();
    }

    pub fn set_max_sampler_anisotropy<'m>(&mut self, max_sampler_anisotropy: f32) {
        self.raw.maxSamplerAnisotropy = max_sampler_anisotropy.into();
    }

    pub fn set_max_viewports<'m>(&mut self, max_viewports: u32) {
        self.raw.maxViewports = max_viewports.into();
    }

    pub fn set_max_viewport_dimensions<'m>(&mut self, max_viewport_dimensions: [u32; 2]) {
        self.raw.maxViewportDimensions = max_viewport_dimensions;
    }

    pub fn set_viewport_bounds_range<'m>(&mut self, viewport_bounds_range: [f32; 2]) {
        self.raw.viewportBoundsRange = viewport_bounds_range;
    }

    pub fn set_viewport_sub_pixel_bits<'m>(&mut self, viewport_sub_pixel_bits: u32) {
        self.raw.viewportSubPixelBits = viewport_sub_pixel_bits.into();
    }

    pub fn set_min_memory_map_alignment<'m>(&mut self, min_memory_map_alignment: usize) {
        self.raw.minMemoryMapAlignment = min_memory_map_alignment.into();
    }

    pub fn set_min_texel_buffer_offset_alignment<'m>(&mut self, min_texel_buffer_offset_alignment: u64) {
        self.raw.minTexelBufferOffsetAlignment = min_texel_buffer_offset_alignment.into();
    }

    pub fn set_min_uniform_buffer_offset_alignment<'m>(&mut self, min_uniform_buffer_offset_alignment: u64) {
        self.raw.minUniformBufferOffsetAlignment = min_uniform_buffer_offset_alignment.into();
    }

    pub fn set_min_storage_buffer_offset_alignment<'m>(&mut self, min_storage_buffer_offset_alignment: u64) {
        self.raw.minStorageBufferOffsetAlignment = min_storage_buffer_offset_alignment.into();
    }

    pub fn set_min_texel_offset<'m>(&mut self, min_texel_offset: i32) {
        self.raw.minTexelOffset = min_texel_offset.into();
    }

    pub fn set_max_texel_offset<'m>(&mut self, max_texel_offset: u32) {
        self.raw.maxTexelOffset = max_texel_offset.into();
    }

    pub fn set_min_texel_gather_offset<'m>(&mut self, min_texel_gather_offset: i32) {
        self.raw.minTexelGatherOffset = min_texel_gather_offset.into();
    }

    pub fn set_max_texel_gather_offset<'m>(&mut self, max_texel_gather_offset: u32) {
        self.raw.maxTexelGatherOffset = max_texel_gather_offset.into();
    }

    pub fn set_min_interpolation_offset<'m>(&mut self, min_interpolation_offset: f32) {
        self.raw.minInterpolationOffset = min_interpolation_offset.into();
    }

    pub fn set_max_interpolation_offset<'m>(&mut self, max_interpolation_offset: f32) {
        self.raw.maxInterpolationOffset = max_interpolation_offset.into();
    }

    pub fn set_sub_pixel_interpolation_offset_bits<'m>(&mut self, sub_pixel_interpolation_offset_bits: u32) {
        self.raw.subPixelInterpolationOffsetBits = sub_pixel_interpolation_offset_bits.into();
    }

    pub fn set_max_framebuffer_width<'m>(&mut self, max_framebuffer_width: u32) {
        self.raw.maxFramebufferWidth = max_framebuffer_width.into();
    }

    pub fn set_max_framebuffer_height<'m>(&mut self, max_framebuffer_height: u32) {
        self.raw.maxFramebufferHeight = max_framebuffer_height.into();
    }

    pub fn set_max_framebuffer_layers<'m>(&mut self, max_framebuffer_layers: u32) {
        self.raw.maxFramebufferLayers = max_framebuffer_layers.into();
    }

    pub fn set_framebuffer_color_sample_counts<'m>(&mut self, framebuffer_color_sample_counts: SampleCountFlags) {
        self.raw.framebufferColorSampleCounts = framebuffer_color_sample_counts.bits();
    }

    pub fn set_framebuffer_depth_sample_counts<'m>(&mut self, framebuffer_depth_sample_counts: SampleCountFlags) {
        self.raw.framebufferDepthSampleCounts = framebuffer_depth_sample_counts.bits();
    }

    pub fn set_framebuffer_stencil_sample_counts<'m>(&mut self, framebuffer_stencil_sample_counts: SampleCountFlags) {
        self.raw.framebufferStencilSampleCounts = framebuffer_stencil_sample_counts.bits();
    }

    pub fn set_framebuffer_no_attachments_sample_counts<'m>(&mut self, framebuffer_no_attachments_sample_counts: SampleCountFlags) {
        self.raw.framebufferNoAttachmentsSampleCounts = framebuffer_no_attachments_sample_counts.bits();
    }

    pub fn set_max_color_attachments<'m>(&mut self, max_color_attachments: u32) {
        self.raw.maxColorAttachments = max_color_attachments.into();
    }

    pub fn set_sampled_image_color_sample_counts<'m>(&mut self, sampled_image_color_sample_counts: SampleCountFlags) {
        self.raw.sampledImageColorSampleCounts = sampled_image_color_sample_counts.bits();
    }

    pub fn set_sampled_image_integer_sample_counts<'m>(&mut self, sampled_image_integer_sample_counts: SampleCountFlags) {
        self.raw.sampledImageIntegerSampleCounts = sampled_image_integer_sample_counts.bits();
    }

    pub fn set_sampled_image_depth_sample_counts<'m>(&mut self, sampled_image_depth_sample_counts: SampleCountFlags) {
        self.raw.sampledImageDepthSampleCounts = sampled_image_depth_sample_counts.bits();
    }

    pub fn set_sampled_image_stencil_sample_counts<'m>(&mut self, sampled_image_stencil_sample_counts: SampleCountFlags) {
        self.raw.sampledImageStencilSampleCounts = sampled_image_stencil_sample_counts.bits();
    }

    pub fn set_storage_image_sample_counts<'m>(&mut self, storage_image_sample_counts: SampleCountFlags) {
        self.raw.storageImageSampleCounts = storage_image_sample_counts.bits();
    }

    pub fn set_max_sample_mask_words<'m>(&mut self, max_sample_mask_words: u32) {
        self.raw.maxSampleMaskWords = max_sample_mask_words.into();
    }

    pub fn set_timestamp_compute_and_graphics<'m>(&mut self, timestamp_compute_and_graphics: bool) {
        self.raw.timestampComputeAndGraphics = timestamp_compute_and_graphics as u32;
    }

    pub fn set_timestamp_period<'m>(&mut self, timestamp_period: f32) {
        self.raw.timestampPeriod = timestamp_period.into();
    }

    pub fn set_max_clip_distances<'m>(&mut self, max_clip_distances: u32) {
        self.raw.maxClipDistances = max_clip_distances.into();
    }

    pub fn set_max_cull_distances<'m>(&mut self, max_cull_distances: u32) {
        self.raw.maxCullDistances = max_cull_distances.into();
    }

    pub fn set_max_combined_clip_and_cull_distances<'m>(&mut self, max_combined_clip_and_cull_distances: u32) {
        self.raw.maxCombinedClipAndCullDistances = max_combined_clip_and_cull_distances.into();
    }

    pub fn set_discrete_queue_priorities<'m>(&mut self, discrete_queue_priorities: u32) {
        self.raw.discreteQueuePriorities = discrete_queue_priorities.into();
    }

    pub fn set_point_size_range<'m>(&mut self, point_size_range: [f32; 2]) {
        self.raw.pointSizeRange = point_size_range;
    }

    pub fn set_line_width_range<'m>(&mut self, line_width_range: [f32; 2]) {
        self.raw.lineWidthRange = line_width_range;
    }

    pub fn set_point_size_granularity<'m>(&mut self, point_size_granularity: f32) {
        self.raw.pointSizeGranularity = point_size_granularity.into();
    }

    pub fn set_line_width_granularity<'m>(&mut self, line_width_granularity: f32) {
        self.raw.lineWidthGranularity = line_width_granularity.into();
    }

    pub fn set_strict_lines<'m>(&mut self, strict_lines: bool) {
        self.raw.strictLines = strict_lines as u32;
    }

    pub fn set_standard_sample_locations<'m>(&mut self, standard_sample_locations: bool) {
        self.raw.standardSampleLocations = standard_sample_locations as u32;
    }

    pub fn set_optimal_buffer_copy_offset_alignment<'m>(&mut self, optimal_buffer_copy_offset_alignment: u64) {
        self.raw.optimalBufferCopyOffsetAlignment = optimal_buffer_copy_offset_alignment.into();
    }

    pub fn set_optimal_buffer_copy_row_pitch_alignment<'m>(&mut self, optimal_buffer_copy_row_pitch_alignment: u64) {
        self.raw.optimalBufferCopyRowPitchAlignment = optimal_buffer_copy_row_pitch_alignment.into();
    }

    pub fn set_non_coherent_atom_size<'m>(&mut self, non_coherent_atom_size: u64) {
        self.raw.nonCoherentAtomSize = non_coherent_atom_size.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceLimits {
        &self.raw
    }
}

impl From<PhysicalDeviceLimits> for vks::VkPhysicalDeviceLimits {
    fn from(f: PhysicalDeviceLimits) -> vks::VkPhysicalDeviceLimits {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceLimits`.
///
/// compute stage limits
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceLimitsFlags: u32 {
        const FLAG_MAXIMAGEDIMENSION1D			 = 0b1;
        const FLAG_MAXIMAGEDIMENSION2D			 = 0b10;
        const FLAG_MAXIMAGEDIMENSION3D			 = 0b100;
        const FLAG_MAXIMAGEDIMENSIONCUBE			 = 0b1000;
        const FLAG_MAXIMAGEARRAYLAYERS			 = 0b10000;
        const FLAG_MAXTEXELBUFFERELEMENTS			 = 0b100000;
        const FLAG_MAXUNIFORMBUFFERRANGE			 = 0b1000000;
        const FLAG_MAXSTORAGEBUFFERRANGE			 = 0b10000000;
        const FLAG_MAXPUSHCONSTANTSSIZE			 = 0b100000000;
        const FLAG_MAXMEMORYALLOCATIONCOUNT			 = 0b1000000000;
        const FLAG_MAXSAMPLERALLOCATIONCOUNT			 = 0b10000000000;
        const FLAG_BUFFERIMAGEGRANULARITY			 = 0b100000000000;
        const FLAG_SPARSEADDRESSSPACESIZE			 = 0b1000000000000;
        const FLAG_MAXBOUNDDESCRIPTORSETS			 = 0b10000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORSAMPLERS			 = 0b100000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORUNIFORMBUFFERS			 = 0b1000000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORSTORAGEBUFFERS			 = 0b10000000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORSAMPLEDIMAGES			 = 0b100000000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORSTORAGEIMAGES			 = 0b1000000000000000000;
        const FLAG_MAXPERSTAGEDESCRIPTORINPUTATTACHMENTS			 = 0b10000000000000000000;
        const FLAG_MAXPERSTAGERESOURCES			 = 0b100000000000000000000;
        const FLAG_MAXDESCRIPTORSETSAMPLERS			 = 0b1000000000000000000000;
        const FLAG_MAXDESCRIPTORSETUNIFORMBUFFERS			 = 0b10000000000000000000000;
        const FLAG_MAXDESCRIPTORSETUNIFORMBUFFERSDYNAMIC			 = 0b100000000000000000000000;
        const FLAG_MAXDESCRIPTORSETSTORAGEBUFFERS			 = 0b1000000000000000000000000;
        const FLAG_MAXDESCRIPTORSETSTORAGEBUFFERSDYNAMIC			 = 0b10000000000000000000000000;
        const FLAG_MAXDESCRIPTORSETSAMPLEDIMAGES			 = 0b100000000000000000000000000;
        const FLAG_MAXDESCRIPTORSETSTORAGEIMAGES			 = 0b1000000000000000000000000000;
        const FLAG_MAXDESCRIPTORSETINPUTATTACHMENTS			 = 0b10000000000000000000000000000;
        const FLAG_MAXVERTEXINPUTATTRIBUTES			 = 0b100000000000000000000000000000;
        const FLAG_MAXVERTEXINPUTBINDINGS			 = 0b1000000000000000000000000000000;
        const FLAG_MAXVERTEXINPUTATTRIBUTEOFFSET			 = 0b10000000000000000000000000000000;
        const FLAG_MAXVERTEXINPUTBINDINGSTRIDE			 = 0b0;
        const FLAG_MAXVERTEXOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONGENERATIONLEVEL			 = 0b0;
        const FLAG_MAXTESSELLATIONPATCHSIZE			 = 0b0;
        const FLAG_MAXTESSELLATIONCONTROLPERVERTEXINPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONCONTROLPERVERTEXOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONCONTROLPERPATCHOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONCONTROLTOTALOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONEVALUATIONINPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXTESSELLATIONEVALUATIONOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXGEOMETRYSHADERINVOCATIONS			 = 0b0;
        const FLAG_MAXGEOMETRYINPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXGEOMETRYOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXGEOMETRYOUTPUTVERTICES			 = 0b0;
        const FLAG_MAXGEOMETRYTOTALOUTPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXFRAGMENTINPUTCOMPONENTS			 = 0b0;
        const FLAG_MAXFRAGMENTOUTPUTATTACHMENTS			 = 0b0;
        const FLAG_MAXFRAGMENTDUALSRCATTACHMENTS			 = 0b0;
        const FLAG_MAXFRAGMENTCOMBINEDOUTPUTRESOURCES			 = 0b0;
        const FLAG_MAXCOMPUTESHAREDMEMORYSIZE			 = 0b0;
        const FLAG_MAXCOMPUTEWORKGROUPCOUNT			 = 0b0;
        const FLAG_MAXCOMPUTEWORKGROUPINVOCATIONS			 = 0b0;
        const FLAG_MAXCOMPUTEWORKGROUPSIZE			 = 0b0;
        const FLAG_SUBPIXELPRECISIONBITS			 = 0b0;
        const FLAG_SUBTEXELPRECISIONBITS			 = 0b0;
        const FLAG_MIPMAPPRECISIONBITS			 = 0b0;
        const FLAG_MAXDRAWINDEXEDINDEXVALUE			 = 0b0;
        const FLAG_MAXDRAWINDIRECTCOUNT			 = 0b0;
        const FLAG_MAXSAMPLERLODBIAS			 = 0b0;
        const FLAG_MAXSAMPLERANISOTROPY			 = 0b0;
        const FLAG_MAXVIEWPORTS			 = 0b0;
        const FLAG_MAXVIEWPORTDIMENSIONS			 = 0b0;
        const FLAG_VIEWPORTBOUNDSRANGE			 = 0b0;
        const FLAG_VIEWPORTSUBPIXELBITS			 = 0b0;
        const FLAG_MINMEMORYMAPALIGNMENT			 = 0b0;
        const FLAG_MINTEXELBUFFEROFFSETALIGNMENT			 = 0b0;
        const FLAG_MINUNIFORMBUFFEROFFSETALIGNMENT			 = 0b0;
        const FLAG_MINSTORAGEBUFFEROFFSETALIGNMENT			 = 0b0;
        const FLAG_MINTEXELOFFSET			 = 0b0;
        const FLAG_MAXTEXELOFFSET			 = 0b0;
        const FLAG_MINTEXELGATHEROFFSET			 = 0b0;
        const FLAG_MAXTEXELGATHEROFFSET			 = 0b0;
        const FLAG_MININTERPOLATIONOFFSET			 = 0b0;
        const FLAG_MAXINTERPOLATIONOFFSET			 = 0b0;
        const FLAG_SUBPIXELINTERPOLATIONOFFSETBITS			 = 0b0;
        const FLAG_MAXFRAMEBUFFERWIDTH			 = 0b0;
        const FLAG_MAXFRAMEBUFFERHEIGHT			 = 0b0;
        const FLAG_MAXFRAMEBUFFERLAYERS			 = 0b0;
        const FLAG_FRAMEBUFFERCOLORSAMPLECOUNTS			 = 0b0;
        const FLAG_FRAMEBUFFERDEPTHSAMPLECOUNTS			 = 0b0;
        const FLAG_FRAMEBUFFERSTENCILSAMPLECOUNTS			 = 0b0;
        const FLAG_FRAMEBUFFERNOATTACHMENTSSAMPLECOUNTS			 = 0b0;
        const FLAG_MAXCOLORATTACHMENTS			 = 0b0;
        const FLAG_SAMPLEDIMAGECOLORSAMPLECOUNTS			 = 0b0;
        const FLAG_SAMPLEDIMAGEINTEGERSAMPLECOUNTS			 = 0b0;
        const FLAG_SAMPLEDIMAGEDEPTHSAMPLECOUNTS			 = 0b0;
        const FLAG_SAMPLEDIMAGESTENCILSAMPLECOUNTS			 = 0b0;
        const FLAG_STORAGEIMAGESAMPLECOUNTS			 = 0b0;
        const FLAG_MAXSAMPLEMASKWORDS			 = 0b0;
        const FLAG_TIMESTAMPCOMPUTEANDGRAPHICS			 = 0b0;
        const FLAG_TIMESTAMPPERIOD			 = 0b0;
        const FLAG_MAXCLIPDISTANCES			 = 0b0;
        const FLAG_MAXCULLDISTANCES			 = 0b0;
        const FLAG_MAXCOMBINEDCLIPANDCULLDISTANCES			 = 0b0;
        const FLAG_DISCRETEQUEUEPRIORITIES			 = 0b0;
        const FLAG_POINTSIZERANGE			 = 0b0;
        const FLAG_LINEWIDTHRANGE			 = 0b0;
        const FLAG_POINTSIZEGRANULARITY			 = 0b0;
        const FLAG_LINEWIDTHGRANULARITY			 = 0b0;
        const FLAG_STRICTLINES			 = 0b0;
        const FLAG_STANDARDSAMPLELOCATIONS			 = 0b0;
        const FLAG_OPTIMALBUFFERCOPYOFFSETALIGNMENT			 = 0b0;
        const FLAG_OPTIMALBUFFERCOPYROWPITCHALIGNMENT			 = 0b0;
        const FLAG_NONCOHERENTATOMSIZE			 = 0b0;
    }
}


/// A builder for `VkPhysicalDeviceLimits`.
///
/// compute stage limits
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceLimitsBuilder {
    raw: vks::VkPhysicalDeviceLimits,
    set_mask: PhysicalDeviceLimitsFlags,
}

impl PhysicalDeviceLimitsBuilder {
    pub fn new() -> PhysicalDeviceLimitsBuilder {
        PhysicalDeviceLimitsBuilder {
            raw: vks::VkPhysicalDeviceLimits::default(),
            set_mask: PhysicalDeviceLimitsFlags::default(),
        }
    }

    pub fn max_image_dimension_1d<'m>(mut self, max_image_dimension_1d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension1D = max_image_dimension_1d.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION1D;
        self
    }

    pub fn max_image_dimension_2d<'m>(mut self, max_image_dimension_2d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension2D = max_image_dimension_2d.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION2D;
        self
    }

    pub fn max_image_dimension_3d<'m>(mut self, max_image_dimension_3d: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimension3D = max_image_dimension_3d.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION3D;
        self
    }

    pub fn max_image_dimension_cube<'m>(mut self, max_image_dimension_cube: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageDimensionCube = max_image_dimension_cube.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSIONCUBE;
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEARRAYLAYERS;
        self
    }

    pub fn max_texel_buffer_elements<'m>(mut self, max_texel_buffer_elements: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelBufferElements = max_texel_buffer_elements.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTEXELBUFFERELEMENTS;
        self
    }

    pub fn max_uniform_buffer_range<'m>(mut self, max_uniform_buffer_range: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxUniformBufferRange = max_uniform_buffer_range.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXUNIFORMBUFFERRANGE;
        self
    }

    pub fn max_storage_buffer_range<'m>(mut self, max_storage_buffer_range: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxStorageBufferRange = max_storage_buffer_range.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXSTORAGEBUFFERRANGE;
        self
    }

    pub fn max_push_constants_size<'m>(mut self, max_push_constants_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPushConstantsSize = max_push_constants_size.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPUSHCONSTANTSSIZE;
        self
    }

    pub fn max_memory_allocation_count<'m>(mut self, max_memory_allocation_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxMemoryAllocationCount = max_memory_allocation_count.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXMEMORYALLOCATIONCOUNT;
        self
    }

    pub fn max_sampler_allocation_count<'m>(mut self, max_sampler_allocation_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerAllocationCount = max_sampler_allocation_count.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERALLOCATIONCOUNT;
        self
    }

    pub fn buffer_image_granularity<'m>(mut self, buffer_image_granularity: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.bufferImageGranularity = buffer_image_granularity.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_BUFFERIMAGEGRANULARITY;
        self
    }

    pub fn sparse_address_space_size<'m>(mut self, sparse_address_space_size: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.sparseAddressSpaceSize = sparse_address_space_size.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SPARSEADDRESSSPACESIZE;
        self
    }

    pub fn max_bound_descriptor_sets<'m>(mut self, max_bound_descriptor_sets: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxBoundDescriptorSets = max_bound_descriptor_sets.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXBOUNDDESCRIPTORSETS;
        self
    }

    pub fn max_per_stage_descriptor_samplers<'m>(mut self, max_per_stage_descriptor_samplers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorSamplers = max_per_stage_descriptor_samplers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLERS;
        self
    }

    pub fn max_per_stage_descriptor_uniform_buffers<'m>(mut self, max_per_stage_descriptor_uniform_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorUniformBuffers = max_per_stage_descriptor_uniform_buffers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORUNIFORMBUFFERS;
        self
    }

    pub fn max_per_stage_descriptor_storage_buffers<'m>(mut self, max_per_stage_descriptor_storage_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorStorageBuffers = max_per_stage_descriptor_storage_buffers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEBUFFERS;
        self
    }

    pub fn max_per_stage_descriptor_sampled_images<'m>(mut self, max_per_stage_descriptor_sampled_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorSampledImages = max_per_stage_descriptor_sampled_images.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLEDIMAGES;
        self
    }

    pub fn max_per_stage_descriptor_storage_images<'m>(mut self, max_per_stage_descriptor_storage_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorStorageImages = max_per_stage_descriptor_storage_images.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEIMAGES;
        self
    }

    pub fn max_per_stage_descriptor_input_attachments<'m>(mut self, max_per_stage_descriptor_input_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageDescriptorInputAttachments = max_per_stage_descriptor_input_attachments.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORINPUTATTACHMENTS;
        self
    }

    pub fn max_per_stage_resources<'m>(mut self, max_per_stage_resources: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxPerStageResources = max_per_stage_resources.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGERESOURCES;
        self
    }

    pub fn max_descriptor_set_samplers<'m>(mut self, max_descriptor_set_samplers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetSamplers = max_descriptor_set_samplers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLERS;
        self
    }

    pub fn max_descriptor_set_uniform_buffers<'m>(mut self, max_descriptor_set_uniform_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetUniformBuffers = max_descriptor_set_uniform_buffers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERS;
        self
    }

    pub fn max_descriptor_set_uniform_buffers_dynamic<'m>(mut self, max_descriptor_set_uniform_buffers_dynamic: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetUniformBuffersDynamic = max_descriptor_set_uniform_buffers_dynamic.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERSDYNAMIC;
        self
    }

    pub fn max_descriptor_set_storage_buffers<'m>(mut self, max_descriptor_set_storage_buffers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageBuffers = max_descriptor_set_storage_buffers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERS;
        self
    }

    pub fn max_descriptor_set_storage_buffers_dynamic<'m>(mut self, max_descriptor_set_storage_buffers_dynamic: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageBuffersDynamic = max_descriptor_set_storage_buffers_dynamic.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERSDYNAMIC;
        self
    }

    pub fn max_descriptor_set_sampled_images<'m>(mut self, max_descriptor_set_sampled_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetSampledImages = max_descriptor_set_sampled_images.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLEDIMAGES;
        self
    }

    pub fn max_descriptor_set_storage_images<'m>(mut self, max_descriptor_set_storage_images: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetStorageImages = max_descriptor_set_storage_images.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEIMAGES;
        self
    }

    pub fn max_descriptor_set_input_attachments<'m>(mut self, max_descriptor_set_input_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDescriptorSetInputAttachments = max_descriptor_set_input_attachments.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETINPUTATTACHMENTS;
        self
    }

    pub fn max_vertex_input_attributes<'m>(mut self, max_vertex_input_attributes: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputAttributes = max_vertex_input_attributes.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTES;
        self
    }

    pub fn max_vertex_input_bindings<'m>(mut self, max_vertex_input_bindings: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputBindings = max_vertex_input_bindings.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGS;
        self
    }

    pub fn max_vertex_input_attribute_offset<'m>(mut self, max_vertex_input_attribute_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputAttributeOffset = max_vertex_input_attribute_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTEOFFSET;
        self
    }

    pub fn max_vertex_input_binding_stride<'m>(mut self, max_vertex_input_binding_stride: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexInputBindingStride = max_vertex_input_binding_stride.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGSTRIDE;
        self
    }

    pub fn max_vertex_output_components<'m>(mut self, max_vertex_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxVertexOutputComponents = max_vertex_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXOUTPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_generation_level<'m>(mut self, max_tessellation_generation_level: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationGenerationLevel = max_tessellation_generation_level.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONGENERATIONLEVEL;
        self
    }

    pub fn max_tessellation_patch_size<'m>(mut self, max_tessellation_patch_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationPatchSize = max_tessellation_patch_size.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONPATCHSIZE;
        self
    }

    pub fn max_tessellation_control_per_vertex_input_components<'m>(mut self, max_tessellation_control_per_vertex_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerVertexInputComponents = max_tessellation_control_per_vertex_input_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXINPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_control_per_vertex_output_components<'m>(mut self, max_tessellation_control_per_vertex_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerVertexOutputComponents = max_tessellation_control_per_vertex_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXOUTPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_control_per_patch_output_components<'m>(mut self, max_tessellation_control_per_patch_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlPerPatchOutputComponents = max_tessellation_control_per_patch_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERPATCHOUTPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_control_total_output_components<'m>(mut self, max_tessellation_control_total_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationControlTotalOutputComponents = max_tessellation_control_total_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLTOTALOUTPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_evaluation_input_components<'m>(mut self, max_tessellation_evaluation_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationEvaluationInputComponents = max_tessellation_evaluation_input_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONINPUTCOMPONENTS;
        self
    }

    pub fn max_tessellation_evaluation_output_components<'m>(mut self, max_tessellation_evaluation_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTessellationEvaluationOutputComponents = max_tessellation_evaluation_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONOUTPUTCOMPONENTS;
        self
    }

    pub fn max_geometry_shader_invocations<'m>(mut self, max_geometry_shader_invocations: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryShaderInvocations = max_geometry_shader_invocations.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYSHADERINVOCATIONS;
        self
    }

    pub fn max_geometry_input_components<'m>(mut self, max_geometry_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryInputComponents = max_geometry_input_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYINPUTCOMPONENTS;
        self
    }

    pub fn max_geometry_output_components<'m>(mut self, max_geometry_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryOutputComponents = max_geometry_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTCOMPONENTS;
        self
    }

    pub fn max_geometry_output_vertices<'m>(mut self, max_geometry_output_vertices: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryOutputVertices = max_geometry_output_vertices.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTVERTICES;
        self
    }

    pub fn max_geometry_total_output_components<'m>(mut self, max_geometry_total_output_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxGeometryTotalOutputComponents = max_geometry_total_output_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYTOTALOUTPUTCOMPONENTS;
        self
    }

    pub fn max_fragment_input_components<'m>(mut self, max_fragment_input_components: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentInputComponents = max_fragment_input_components.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTINPUTCOMPONENTS;
        self
    }

    pub fn max_fragment_output_attachments<'m>(mut self, max_fragment_output_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentOutputAttachments = max_fragment_output_attachments.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTOUTPUTATTACHMENTS;
        self
    }

    pub fn max_fragment_dual_src_attachments<'m>(mut self, max_fragment_dual_src_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentDualSrcAttachments = max_fragment_dual_src_attachments.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTDUALSRCATTACHMENTS;
        self
    }

    pub fn max_fragment_combined_output_resources<'m>(mut self, max_fragment_combined_output_resources: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFragmentCombinedOutputResources = max_fragment_combined_output_resources.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTCOMBINEDOUTPUTRESOURCES;
        self
    }

    pub fn max_compute_shared_memory_size<'m>(mut self, max_compute_shared_memory_size: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeSharedMemorySize = max_compute_shared_memory_size.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTESHAREDMEMORYSIZE;
        self
    }

    pub fn max_compute_work_group_count<'m>(mut self, max_compute_work_group_count: [u32; 3]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupCount = max_compute_work_group_count;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPCOUNT;
        self
    }

    pub fn max_compute_work_group_invocations<'m>(mut self, max_compute_work_group_invocations: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupInvocations = max_compute_work_group_invocations.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPINVOCATIONS;
        self
    }

    pub fn max_compute_work_group_size<'m>(mut self, max_compute_work_group_size: [u32; 3]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxComputeWorkGroupSize = max_compute_work_group_size;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPSIZE;
        self
    }

    pub fn sub_pixel_precision_bits<'m>(mut self, sub_pixel_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subPixelPrecisionBits = sub_pixel_precision_bits.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SUBPIXELPRECISIONBITS;
        self
    }

    pub fn sub_texel_precision_bits<'m>(mut self, sub_texel_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subTexelPrecisionBits = sub_texel_precision_bits.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SUBTEXELPRECISIONBITS;
        self
    }

    pub fn mipmap_precision_bits<'m>(mut self, mipmap_precision_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.mipmapPrecisionBits = mipmap_precision_bits.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MIPMAPPRECISIONBITS;
        self
    }

    pub fn max_draw_indexed_index_value<'m>(mut self, max_draw_indexed_index_value: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDrawIndexedIndexValue = max_draw_indexed_index_value.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDEXEDINDEXVALUE;
        self
    }

    pub fn max_draw_indirect_count<'m>(mut self, max_draw_indirect_count: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxDrawIndirectCount = max_draw_indirect_count.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDIRECTCOUNT;
        self
    }

    pub fn max_sampler_lod_bias<'m>(mut self, max_sampler_lod_bias: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerLodBias = max_sampler_lod_bias.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERLODBIAS;
        self
    }

    pub fn max_sampler_anisotropy<'m>(mut self, max_sampler_anisotropy: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSamplerAnisotropy = max_sampler_anisotropy.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERANISOTROPY;
        self
    }

    pub fn max_viewports<'m>(mut self, max_viewports: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxViewports = max_viewports.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTS;
        self
    }

    pub fn max_viewport_dimensions<'m>(mut self, max_viewport_dimensions: [u32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxViewportDimensions = max_viewport_dimensions;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTDIMENSIONS;
        self
    }

    pub fn viewport_bounds_range<'m>(mut self, viewport_bounds_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.viewportBoundsRange = viewport_bounds_range;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_VIEWPORTBOUNDSRANGE;
        self
    }

    pub fn viewport_sub_pixel_bits<'m>(mut self, viewport_sub_pixel_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.viewportSubPixelBits = viewport_sub_pixel_bits.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_VIEWPORTSUBPIXELBITS;
        self
    }

    pub fn min_memory_map_alignment<'m>(mut self, min_memory_map_alignment: usize) -> PhysicalDeviceLimitsBuilder {
        self.raw.minMemoryMapAlignment = min_memory_map_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINMEMORYMAPALIGNMENT;
        self
    }

    pub fn min_texel_buffer_offset_alignment<'m>(mut self, min_texel_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelBufferOffsetAlignment = min_texel_buffer_offset_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINTEXELBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn min_uniform_buffer_offset_alignment<'m>(mut self, min_uniform_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minUniformBufferOffsetAlignment = min_uniform_buffer_offset_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINUNIFORMBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn min_storage_buffer_offset_alignment<'m>(mut self, min_storage_buffer_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.minStorageBufferOffsetAlignment = min_storage_buffer_offset_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINSTORAGEBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn min_texel_offset<'m>(mut self, min_texel_offset: i32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelOffset = min_texel_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINTEXELOFFSET;
        self
    }

    pub fn max_texel_offset<'m>(mut self, max_texel_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelOffset = max_texel_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTEXELOFFSET;
        self
    }

    pub fn min_texel_gather_offset<'m>(mut self, min_texel_gather_offset: i32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minTexelGatherOffset = min_texel_gather_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MINTEXELGATHEROFFSET;
        self
    }

    pub fn max_texel_gather_offset<'m>(mut self, max_texel_gather_offset: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxTexelGatherOffset = max_texel_gather_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXTEXELGATHEROFFSET;
        self
    }

    pub fn min_interpolation_offset<'m>(mut self, min_interpolation_offset: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.minInterpolationOffset = min_interpolation_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MININTERPOLATIONOFFSET;
        self
    }

    pub fn max_interpolation_offset<'m>(mut self, max_interpolation_offset: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxInterpolationOffset = max_interpolation_offset.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXINTERPOLATIONOFFSET;
        self
    }

    pub fn sub_pixel_interpolation_offset_bits<'m>(mut self, sub_pixel_interpolation_offset_bits: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.subPixelInterpolationOffsetBits = sub_pixel_interpolation_offset_bits.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SUBPIXELINTERPOLATIONOFFSETBITS;
        self
    }

    pub fn max_framebuffer_width<'m>(mut self, max_framebuffer_width: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferWidth = max_framebuffer_width.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERWIDTH;
        self
    }

    pub fn max_framebuffer_height<'m>(mut self, max_framebuffer_height: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferHeight = max_framebuffer_height.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERHEIGHT;
        self
    }

    pub fn max_framebuffer_layers<'m>(mut self, max_framebuffer_layers: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxFramebufferLayers = max_framebuffer_layers.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERLAYERS;
        self
    }

    pub fn framebuffer_color_sample_counts<'m>(mut self, framebuffer_color_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferColorSampleCounts = framebuffer_color_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERCOLORSAMPLECOUNTS;
        self
    }

    pub fn framebuffer_depth_sample_counts<'m>(mut self, framebuffer_depth_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferDepthSampleCounts = framebuffer_depth_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERDEPTHSAMPLECOUNTS;
        self
    }

    pub fn framebuffer_stencil_sample_counts<'m>(mut self, framebuffer_stencil_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferStencilSampleCounts = framebuffer_stencil_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERSTENCILSAMPLECOUNTS;
        self
    }

    pub fn framebuffer_no_attachments_sample_counts<'m>(mut self, framebuffer_no_attachments_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.framebufferNoAttachmentsSampleCounts = framebuffer_no_attachments_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERNOATTACHMENTSSAMPLECOUNTS;
        self
    }

    pub fn max_color_attachments<'m>(mut self, max_color_attachments: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxColorAttachments = max_color_attachments.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOLORATTACHMENTS;
        self
    }

    pub fn sampled_image_color_sample_counts<'m>(mut self, sampled_image_color_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageColorSampleCounts = sampled_image_color_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGECOLORSAMPLECOUNTS;
        self
    }

    pub fn sampled_image_integer_sample_counts<'m>(mut self, sampled_image_integer_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageIntegerSampleCounts = sampled_image_integer_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEINTEGERSAMPLECOUNTS;
        self
    }

    pub fn sampled_image_depth_sample_counts<'m>(mut self, sampled_image_depth_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageDepthSampleCounts = sampled_image_depth_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEDEPTHSAMPLECOUNTS;
        self
    }

    pub fn sampled_image_stencil_sample_counts<'m>(mut self, sampled_image_stencil_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.sampledImageStencilSampleCounts = sampled_image_stencil_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGESTENCILSAMPLECOUNTS;
        self
    }

    pub fn storage_image_sample_counts<'m>(mut self, storage_image_sample_counts: SampleCountFlags) -> PhysicalDeviceLimitsBuilder {
        self.raw.storageImageSampleCounts = storage_image_sample_counts.bits();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_STORAGEIMAGESAMPLECOUNTS;
        self
    }

    pub fn max_sample_mask_words<'m>(mut self, max_sample_mask_words: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxSampleMaskWords = max_sample_mask_words.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLEMASKWORDS;
        self
    }

    pub fn timestamp_compute_and_graphics<'m>(mut self, timestamp_compute_and_graphics: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.timestampComputeAndGraphics = timestamp_compute_and_graphics as u32;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPCOMPUTEANDGRAPHICS;
        self
    }

    pub fn timestamp_period<'m>(mut self, timestamp_period: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.timestampPeriod = timestamp_period.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPPERIOD;
        self
    }

    pub fn max_clip_distances<'m>(mut self, max_clip_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxClipDistances = max_clip_distances.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCLIPDISTANCES;
        self
    }

    pub fn max_cull_distances<'m>(mut self, max_cull_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxCullDistances = max_cull_distances.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCULLDISTANCES;
        self
    }

    pub fn max_combined_clip_and_cull_distances<'m>(mut self, max_combined_clip_and_cull_distances: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.maxCombinedClipAndCullDistances = max_combined_clip_and_cull_distances.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_MAXCOMBINEDCLIPANDCULLDISTANCES;
        self
    }

    pub fn discrete_queue_priorities<'m>(mut self, discrete_queue_priorities: u32) -> PhysicalDeviceLimitsBuilder {
        self.raw.discreteQueuePriorities = discrete_queue_priorities.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_DISCRETEQUEUEPRIORITIES;
        self
    }

    pub fn point_size_range<'m>(mut self, point_size_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.pointSizeRange = point_size_range;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_POINTSIZERANGE;
        self
    }

    pub fn line_width_range<'m>(mut self, line_width_range: [f32; 2]) -> PhysicalDeviceLimitsBuilder {
        self.raw.lineWidthRange = line_width_range;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHRANGE;
        self
    }

    pub fn point_size_granularity<'m>(mut self, point_size_granularity: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.pointSizeGranularity = point_size_granularity.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_POINTSIZEGRANULARITY;
        self
    }

    pub fn line_width_granularity<'m>(mut self, line_width_granularity: f32) -> PhysicalDeviceLimitsBuilder {
        self.raw.lineWidthGranularity = line_width_granularity.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHGRANULARITY;
        self
    }

    pub fn strict_lines<'m>(mut self, strict_lines: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.strictLines = strict_lines as u32;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_STRICTLINES;
        self
    }

    pub fn standard_sample_locations<'m>(mut self, standard_sample_locations: bool) -> PhysicalDeviceLimitsBuilder {
        self.raw.standardSampleLocations = standard_sample_locations as u32;
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_STANDARDSAMPLELOCATIONS;
        self
    }

    pub fn optimal_buffer_copy_offset_alignment<'m>(mut self, optimal_buffer_copy_offset_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.optimalBufferCopyOffsetAlignment = optimal_buffer_copy_offset_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYOFFSETALIGNMENT;
        self
    }

    pub fn optimal_buffer_copy_row_pitch_alignment<'m>(mut self, optimal_buffer_copy_row_pitch_alignment: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.optimalBufferCopyRowPitchAlignment = optimal_buffer_copy_row_pitch_alignment.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYROWPITCHALIGNMENT;
        self
    }

    pub fn non_coherent_atom_size<'m>(mut self, non_coherent_atom_size: u64) -> PhysicalDeviceLimitsBuilder {
        self.raw.nonCoherentAtomSize = non_coherent_atom_size.into();
        self.set_mask |= PhysicalDeviceLimitsFlags::FLAG_NONCOHERENTATOMSIZE;
        self
    }

    pub fn get_max_image_dimension_1d<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION1D != PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION1D { return None }
        Some( self.raw.maxImageDimension1D.into() )
    }

    pub fn get_max_image_dimension_2d<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION2D != PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION2D { return None }
        Some( self.raw.maxImageDimension2D.into() )
    }

    pub fn get_max_image_dimension_3d<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION3D != PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSION3D { return None }
        Some( self.raw.maxImageDimension3D.into() )
    }

    pub fn get_max_image_dimension_cube<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSIONCUBE != PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEDIMENSIONCUBE { return None }
        Some( self.raw.maxImageDimensionCube.into() )
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEARRAYLAYERS != PhysicalDeviceLimitsFlags::FLAG_MAXIMAGEARRAYLAYERS { return None }
        Some( self.raw.maxImageArrayLayers.into() )
    }

    pub fn get_max_texel_buffer_elements<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTEXELBUFFERELEMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTEXELBUFFERELEMENTS { return None }
        Some( self.raw.maxTexelBufferElements.into() )
    }

    pub fn get_max_uniform_buffer_range<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXUNIFORMBUFFERRANGE != PhysicalDeviceLimitsFlags::FLAG_MAXUNIFORMBUFFERRANGE { return None }
        Some( self.raw.maxUniformBufferRange.into() )
    }

    pub fn get_max_storage_buffer_range<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXSTORAGEBUFFERRANGE != PhysicalDeviceLimitsFlags::FLAG_MAXSTORAGEBUFFERRANGE { return None }
        Some( self.raw.maxStorageBufferRange.into() )
    }

    pub fn get_max_push_constants_size<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPUSHCONSTANTSSIZE != PhysicalDeviceLimitsFlags::FLAG_MAXPUSHCONSTANTSSIZE { return None }
        Some( self.raw.maxPushConstantsSize.into() )
    }

    pub fn get_max_memory_allocation_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXMEMORYALLOCATIONCOUNT != PhysicalDeviceLimitsFlags::FLAG_MAXMEMORYALLOCATIONCOUNT { return None }
        Some( self.raw.maxMemoryAllocationCount.into() )
    }

    pub fn get_max_sampler_allocation_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERALLOCATIONCOUNT != PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERALLOCATIONCOUNT { return None }
        Some( self.raw.maxSamplerAllocationCount.into() )
    }

    pub fn get_buffer_image_granularity<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_BUFFERIMAGEGRANULARITY != PhysicalDeviceLimitsFlags::FLAG_BUFFERIMAGEGRANULARITY { return None }
        Some( self.raw.bufferImageGranularity.into() )
    }

    pub fn get_sparse_address_space_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SPARSEADDRESSSPACESIZE != PhysicalDeviceLimitsFlags::FLAG_SPARSEADDRESSSPACESIZE { return None }
        Some( self.raw.sparseAddressSpaceSize.into() )
    }

    pub fn get_max_bound_descriptor_sets<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXBOUNDDESCRIPTORSETS != PhysicalDeviceLimitsFlags::FLAG_MAXBOUNDDESCRIPTORSETS { return None }
        Some( self.raw.maxBoundDescriptorSets.into() )
    }

    pub fn get_max_per_stage_descriptor_samplers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLERS != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLERS { return None }
        Some( self.raw.maxPerStageDescriptorSamplers.into() )
    }

    pub fn get_max_per_stage_descriptor_uniform_buffers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORUNIFORMBUFFERS != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORUNIFORMBUFFERS { return None }
        Some( self.raw.maxPerStageDescriptorUniformBuffers.into() )
    }

    pub fn get_max_per_stage_descriptor_storage_buffers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEBUFFERS != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEBUFFERS { return None }
        Some( self.raw.maxPerStageDescriptorStorageBuffers.into() )
    }

    pub fn get_max_per_stage_descriptor_sampled_images<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLEDIMAGES != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSAMPLEDIMAGES { return None }
        Some( self.raw.maxPerStageDescriptorSampledImages.into() )
    }

    pub fn get_max_per_stage_descriptor_storage_images<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEIMAGES != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORSTORAGEIMAGES { return None }
        Some( self.raw.maxPerStageDescriptorStorageImages.into() )
    }

    pub fn get_max_per_stage_descriptor_input_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORINPUTATTACHMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGEDESCRIPTORINPUTATTACHMENTS { return None }
        Some( self.raw.maxPerStageDescriptorInputAttachments.into() )
    }

    pub fn get_max_per_stage_resources<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGERESOURCES != PhysicalDeviceLimitsFlags::FLAG_MAXPERSTAGERESOURCES { return None }
        Some( self.raw.maxPerStageResources.into() )
    }

    pub fn get_max_descriptor_set_samplers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLERS != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLERS { return None }
        Some( self.raw.maxDescriptorSetSamplers.into() )
    }

    pub fn get_max_descriptor_set_uniform_buffers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERS != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERS { return None }
        Some( self.raw.maxDescriptorSetUniformBuffers.into() )
    }

    pub fn get_max_descriptor_set_uniform_buffers_dynamic<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERSDYNAMIC != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETUNIFORMBUFFERSDYNAMIC { return None }
        Some( self.raw.maxDescriptorSetUniformBuffersDynamic.into() )
    }

    pub fn get_max_descriptor_set_storage_buffers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERS != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERS { return None }
        Some( self.raw.maxDescriptorSetStorageBuffers.into() )
    }

    pub fn get_max_descriptor_set_storage_buffers_dynamic<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERSDYNAMIC != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEBUFFERSDYNAMIC { return None }
        Some( self.raw.maxDescriptorSetStorageBuffersDynamic.into() )
    }

    pub fn get_max_descriptor_set_sampled_images<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLEDIMAGES != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSAMPLEDIMAGES { return None }
        Some( self.raw.maxDescriptorSetSampledImages.into() )
    }

    pub fn get_max_descriptor_set_storage_images<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEIMAGES != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETSTORAGEIMAGES { return None }
        Some( self.raw.maxDescriptorSetStorageImages.into() )
    }

    pub fn get_max_descriptor_set_input_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETINPUTATTACHMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXDESCRIPTORSETINPUTATTACHMENTS { return None }
        Some( self.raw.maxDescriptorSetInputAttachments.into() )
    }

    pub fn get_max_vertex_input_attributes<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTES != PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTES { return None }
        Some( self.raw.maxVertexInputAttributes.into() )
    }

    pub fn get_max_vertex_input_bindings<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGS != PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGS { return None }
        Some( self.raw.maxVertexInputBindings.into() )
    }

    pub fn get_max_vertex_input_attribute_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTEOFFSET != PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTATTRIBUTEOFFSET { return None }
        Some( self.raw.maxVertexInputAttributeOffset.into() )
    }

    pub fn get_max_vertex_input_binding_stride<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGSTRIDE != PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXINPUTBINDINGSTRIDE { return None }
        Some( self.raw.maxVertexInputBindingStride.into() )
    }

    pub fn get_max_vertex_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXVERTEXOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxVertexOutputComponents.into() )
    }

    pub fn get_max_tessellation_generation_level<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONGENERATIONLEVEL != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONGENERATIONLEVEL { return None }
        Some( self.raw.maxTessellationGenerationLevel.into() )
    }

    pub fn get_max_tessellation_patch_size<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONPATCHSIZE != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONPATCHSIZE { return None }
        Some( self.raw.maxTessellationPatchSize.into() )
    }

    pub fn get_max_tessellation_control_per_vertex_input_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXINPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXINPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationControlPerVertexInputComponents.into() )
    }

    pub fn get_max_tessellation_control_per_vertex_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERVERTEXOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationControlPerVertexOutputComponents.into() )
    }

    pub fn get_max_tessellation_control_per_patch_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERPATCHOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLPERPATCHOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationControlPerPatchOutputComponents.into() )
    }

    pub fn get_max_tessellation_control_total_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLTOTALOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONCONTROLTOTALOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationControlTotalOutputComponents.into() )
    }

    pub fn get_max_tessellation_evaluation_input_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONINPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONINPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationEvaluationInputComponents.into() )
    }

    pub fn get_max_tessellation_evaluation_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXTESSELLATIONEVALUATIONOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxTessellationEvaluationOutputComponents.into() )
    }

    pub fn get_max_geometry_shader_invocations<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYSHADERINVOCATIONS != PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYSHADERINVOCATIONS { return None }
        Some( self.raw.maxGeometryShaderInvocations.into() )
    }

    pub fn get_max_geometry_input_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYINPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYINPUTCOMPONENTS { return None }
        Some( self.raw.maxGeometryInputComponents.into() )
    }

    pub fn get_max_geometry_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxGeometryOutputComponents.into() )
    }

    pub fn get_max_geometry_output_vertices<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTVERTICES != PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYOUTPUTVERTICES { return None }
        Some( self.raw.maxGeometryOutputVertices.into() )
    }

    pub fn get_max_geometry_total_output_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYTOTALOUTPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXGEOMETRYTOTALOUTPUTCOMPONENTS { return None }
        Some( self.raw.maxGeometryTotalOutputComponents.into() )
    }

    pub fn get_max_fragment_input_components<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTINPUTCOMPONENTS != PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTINPUTCOMPONENTS { return None }
        Some( self.raw.maxFragmentInputComponents.into() )
    }

    pub fn get_max_fragment_output_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTOUTPUTATTACHMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTOUTPUTATTACHMENTS { return None }
        Some( self.raw.maxFragmentOutputAttachments.into() )
    }

    pub fn get_max_fragment_dual_src_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTDUALSRCATTACHMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTDUALSRCATTACHMENTS { return None }
        Some( self.raw.maxFragmentDualSrcAttachments.into() )
    }

    pub fn get_max_fragment_combined_output_resources<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTCOMBINEDOUTPUTRESOURCES != PhysicalDeviceLimitsFlags::FLAG_MAXFRAGMENTCOMBINEDOUTPUTRESOURCES { return None }
        Some( self.raw.maxFragmentCombinedOutputResources.into() )
    }

    pub fn get_max_compute_shared_memory_size<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTESHAREDMEMORYSIZE != PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTESHAREDMEMORYSIZE { return None }
        Some( self.raw.maxComputeSharedMemorySize.into() )
    }

    pub fn get_max_compute_work_group_count<'a>(&'a self) -> Option<&[u32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPCOUNT != PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPCOUNT { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupCount as *const _, 3 as usize) } )
    }

    pub fn get_max_compute_work_group_invocations<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPINVOCATIONS != PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPINVOCATIONS { return None }
        Some( self.raw.maxComputeWorkGroupInvocations.into() )
    }

    pub fn get_max_compute_work_group_size<'a>(&'a self) -> Option<&[u32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPSIZE != PhysicalDeviceLimitsFlags::FLAG_MAXCOMPUTEWORKGROUPSIZE { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.maxComputeWorkGroupSize as *const _, 3 as usize) } )
    }

    pub fn get_sub_pixel_precision_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SUBPIXELPRECISIONBITS != PhysicalDeviceLimitsFlags::FLAG_SUBPIXELPRECISIONBITS { return None }
        Some( self.raw.subPixelPrecisionBits.into() )
    }

    pub fn get_sub_texel_precision_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SUBTEXELPRECISIONBITS != PhysicalDeviceLimitsFlags::FLAG_SUBTEXELPRECISIONBITS { return None }
        Some( self.raw.subTexelPrecisionBits.into() )
    }

    pub fn get_mipmap_precision_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MIPMAPPRECISIONBITS != PhysicalDeviceLimitsFlags::FLAG_MIPMAPPRECISIONBITS { return None }
        Some( self.raw.mipmapPrecisionBits.into() )
    }

    pub fn get_max_draw_indexed_index_value<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDEXEDINDEXVALUE != PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDEXEDINDEXVALUE { return None }
        Some( self.raw.maxDrawIndexedIndexValue.into() )
    }

    pub fn get_max_draw_indirect_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDIRECTCOUNT != PhysicalDeviceLimitsFlags::FLAG_MAXDRAWINDIRECTCOUNT { return None }
        Some( self.raw.maxDrawIndirectCount.into() )
    }

    pub fn get_max_sampler_lod_bias<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERLODBIAS != PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERLODBIAS { return None }
        Some( self.raw.maxSamplerLodBias.into() )
    }

    pub fn get_max_sampler_anisotropy<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERANISOTROPY != PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLERANISOTROPY { return None }
        Some( self.raw.maxSamplerAnisotropy.into() )
    }

    pub fn get_max_viewports<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTS != PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTS { return None }
        Some( self.raw.maxViewports.into() )
    }

    pub fn get_max_viewport_dimensions<'a>(&'a self) -> Option<&[u32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTDIMENSIONS != PhysicalDeviceLimitsFlags::FLAG_MAXVIEWPORTDIMENSIONS { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.maxViewportDimensions as *const _, 2 as usize) } )
    }

    pub fn get_viewport_bounds_range<'a>(&'a self) -> Option<&[f32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_VIEWPORTBOUNDSRANGE != PhysicalDeviceLimitsFlags::FLAG_VIEWPORTBOUNDSRANGE { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.viewportBoundsRange as *const _, 2 as usize) } )
    }

    pub fn get_viewport_sub_pixel_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_VIEWPORTSUBPIXELBITS != PhysicalDeviceLimitsFlags::FLAG_VIEWPORTSUBPIXELBITS { return None }
        Some( self.raw.viewportSubPixelBits.into() )
    }

    pub fn get_min_memory_map_alignment<'a>(&'a self) -> Option<usize> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINMEMORYMAPALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_MINMEMORYMAPALIGNMENT { return None }
        Some( self.raw.minMemoryMapAlignment.into() )
    }

    pub fn get_min_texel_buffer_offset_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINTEXELBUFFEROFFSETALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_MINTEXELBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minTexelBufferOffsetAlignment.into() )
    }

    pub fn get_min_uniform_buffer_offset_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINUNIFORMBUFFEROFFSETALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_MINUNIFORMBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minUniformBufferOffsetAlignment.into() )
    }

    pub fn get_min_storage_buffer_offset_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINSTORAGEBUFFEROFFSETALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_MINSTORAGEBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minStorageBufferOffsetAlignment.into() )
    }

    pub fn get_min_texel_offset<'a>(&'a self) -> Option<i32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINTEXELOFFSET != PhysicalDeviceLimitsFlags::FLAG_MINTEXELOFFSET { return None }
        Some( self.raw.minTexelOffset.into() )
    }

    pub fn get_max_texel_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTEXELOFFSET != PhysicalDeviceLimitsFlags::FLAG_MAXTEXELOFFSET { return None }
        Some( self.raw.maxTexelOffset.into() )
    }

    pub fn get_min_texel_gather_offset<'a>(&'a self) -> Option<i32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MINTEXELGATHEROFFSET != PhysicalDeviceLimitsFlags::FLAG_MINTEXELGATHEROFFSET { return None }
        Some( self.raw.minTexelGatherOffset.into() )
    }

    pub fn get_max_texel_gather_offset<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXTEXELGATHEROFFSET != PhysicalDeviceLimitsFlags::FLAG_MAXTEXELGATHEROFFSET { return None }
        Some( self.raw.maxTexelGatherOffset.into() )
    }

    pub fn get_min_interpolation_offset<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MININTERPOLATIONOFFSET != PhysicalDeviceLimitsFlags::FLAG_MININTERPOLATIONOFFSET { return None }
        Some( self.raw.minInterpolationOffset.into() )
    }

    pub fn get_max_interpolation_offset<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXINTERPOLATIONOFFSET != PhysicalDeviceLimitsFlags::FLAG_MAXINTERPOLATIONOFFSET { return None }
        Some( self.raw.maxInterpolationOffset.into() )
    }

    pub fn get_sub_pixel_interpolation_offset_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SUBPIXELINTERPOLATIONOFFSETBITS != PhysicalDeviceLimitsFlags::FLAG_SUBPIXELINTERPOLATIONOFFSETBITS { return None }
        Some( self.raw.subPixelInterpolationOffsetBits.into() )
    }

    pub fn get_max_framebuffer_width<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERWIDTH != PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERWIDTH { return None }
        Some( self.raw.maxFramebufferWidth.into() )
    }

    pub fn get_max_framebuffer_height<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERHEIGHT != PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERHEIGHT { return None }
        Some( self.raw.maxFramebufferHeight.into() )
    }

    pub fn get_max_framebuffer_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERLAYERS != PhysicalDeviceLimitsFlags::FLAG_MAXFRAMEBUFFERLAYERS { return None }
        Some( self.raw.maxFramebufferLayers.into() )
    }

    pub fn get_framebuffer_color_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERCOLORSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERCOLORSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.framebufferColorSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_color_sample_counts: error converting flags") )
    }

    pub fn get_framebuffer_depth_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERDEPTHSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERDEPTHSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.framebufferDepthSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_depth_sample_counts: error converting flags") )
    }

    pub fn get_framebuffer_stencil_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERSTENCILSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERSTENCILSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.framebufferStencilSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_stencil_sample_counts: error converting flags") )
    }

    pub fn get_framebuffer_no_attachments_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERNOATTACHMENTSSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_FRAMEBUFFERNOATTACHMENTSSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.framebufferNoAttachmentsSampleCounts)
            .expect("PhysicalDeviceLimits::framebuffer_no_attachments_sample_counts: error converting flags") )
    }

    pub fn get_max_color_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOLORATTACHMENTS != PhysicalDeviceLimitsFlags::FLAG_MAXCOLORATTACHMENTS { return None }
        Some( self.raw.maxColorAttachments.into() )
    }

    pub fn get_sampled_image_color_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGECOLORSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGECOLORSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.sampledImageColorSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_color_sample_counts: error converting flags") )
    }

    pub fn get_sampled_image_integer_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEINTEGERSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEINTEGERSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.sampledImageIntegerSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_integer_sample_counts: error converting flags") )
    }

    pub fn get_sampled_image_depth_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEDEPTHSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGEDEPTHSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.sampledImageDepthSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_depth_sample_counts: error converting flags") )
    }

    pub fn get_sampled_image_stencil_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGESTENCILSAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_SAMPLEDIMAGESTENCILSAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.sampledImageStencilSampleCounts)
            .expect("PhysicalDeviceLimits::sampled_image_stencil_sample_counts: error converting flags") )
    }

    pub fn get_storage_image_sample_counts<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_STORAGEIMAGESAMPLECOUNTS != PhysicalDeviceLimitsFlags::FLAG_STORAGEIMAGESAMPLECOUNTS { return None }
        Some( SampleCountFlags::from_bits(self.raw.storageImageSampleCounts)
            .expect("PhysicalDeviceLimits::storage_image_sample_counts: error converting flags") )
    }

    pub fn get_max_sample_mask_words<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLEMASKWORDS != PhysicalDeviceLimitsFlags::FLAG_MAXSAMPLEMASKWORDS { return None }
        Some( self.raw.maxSampleMaskWords.into() )
    }

    pub fn get_timestamp_compute_and_graphics<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPCOMPUTEANDGRAPHICS != PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPCOMPUTEANDGRAPHICS { return None }
        Some( self.raw.timestampComputeAndGraphics != 0 )
    }

    pub fn get_timestamp_period<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPPERIOD != PhysicalDeviceLimitsFlags::FLAG_TIMESTAMPPERIOD { return None }
        Some( self.raw.timestampPeriod.into() )
    }

    pub fn get_max_clip_distances<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCLIPDISTANCES != PhysicalDeviceLimitsFlags::FLAG_MAXCLIPDISTANCES { return None }
        Some( self.raw.maxClipDistances.into() )
    }

    pub fn get_max_cull_distances<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCULLDISTANCES != PhysicalDeviceLimitsFlags::FLAG_MAXCULLDISTANCES { return None }
        Some( self.raw.maxCullDistances.into() )
    }

    pub fn get_max_combined_clip_and_cull_distances<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_MAXCOMBINEDCLIPANDCULLDISTANCES != PhysicalDeviceLimitsFlags::FLAG_MAXCOMBINEDCLIPANDCULLDISTANCES { return None }
        Some( self.raw.maxCombinedClipAndCullDistances.into() )
    }

    pub fn get_discrete_queue_priorities<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_DISCRETEQUEUEPRIORITIES != PhysicalDeviceLimitsFlags::FLAG_DISCRETEQUEUEPRIORITIES { return None }
        Some( self.raw.discreteQueuePriorities.into() )
    }

    pub fn get_point_size_range<'a>(&'a self) -> Option<&[f32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_POINTSIZERANGE != PhysicalDeviceLimitsFlags::FLAG_POINTSIZERANGE { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.pointSizeRange as *const _, 2 as usize) } )
    }

    pub fn get_line_width_range<'a>(&'a self) -> Option<&[f32]> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHRANGE != PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHRANGE { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.lineWidthRange as *const _, 2 as usize) } )
    }

    pub fn get_point_size_granularity<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_POINTSIZEGRANULARITY != PhysicalDeviceLimitsFlags::FLAG_POINTSIZEGRANULARITY { return None }
        Some( self.raw.pointSizeGranularity.into() )
    }

    pub fn get_line_width_granularity<'a>(&'a self) -> Option<f32> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHGRANULARITY != PhysicalDeviceLimitsFlags::FLAG_LINEWIDTHGRANULARITY { return None }
        Some( self.raw.lineWidthGranularity.into() )
    }

    pub fn get_strict_lines<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_STRICTLINES != PhysicalDeviceLimitsFlags::FLAG_STRICTLINES { return None }
        Some( self.raw.strictLines != 0 )
    }

    pub fn get_standard_sample_locations<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_STANDARDSAMPLELOCATIONS != PhysicalDeviceLimitsFlags::FLAG_STANDARDSAMPLELOCATIONS { return None }
        Some( self.raw.standardSampleLocations != 0 )
    }

    pub fn get_optimal_buffer_copy_offset_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYOFFSETALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYOFFSETALIGNMENT { return None }
        Some( self.raw.optimalBufferCopyOffsetAlignment.into() )
    }

    pub fn get_optimal_buffer_copy_row_pitch_alignment<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYROWPITCHALIGNMENT != PhysicalDeviceLimitsFlags::FLAG_OPTIMALBUFFERCOPYROWPITCHALIGNMENT { return None }
        Some( self.raw.optimalBufferCopyRowPitchAlignment.into() )
    }

    pub fn get_non_coherent_atom_size<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PhysicalDeviceLimitsFlags::FLAG_NONCOHERENTATOMSIZE != PhysicalDeviceLimitsFlags::FLAG_NONCOHERENTATOMSIZE { return None }
        Some( self.raw.nonCoherentAtomSize.into() )
    }

    pub fn build(self) -> PhysicalDeviceLimits {
        PhysicalDeviceLimits {
            raw: self.raw,
        }
    }
}


/// A `VkSemaphoreCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreCreateInfo<'s> {
    raw: vks::VkSemaphoreCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreCreateInfo<'s> {
    pub fn builder<'b>() -> SemaphoreCreateInfoBuilder<'b> {
        SemaphoreCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreCreateInfo) -> SemaphoreCreateInfo<'s> {
        SemaphoreCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SemaphoreCreateFlags {
        SemaphoreCreateFlags::from_bits(self.raw.flags)
            .expect("SemaphoreCreateInfo::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreCreateInfo {
        &self.raw
    }
}

impl<'s> From<SemaphoreCreateInfo<'s>> for vks::VkSemaphoreCreateInfo {
    fn from(f: SemaphoreCreateInfo<'s>) -> vks::VkSemaphoreCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkSemaphoreCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SemaphoreCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
    }
}


/// A builder for `VkSemaphoreCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreCreateInfoBuilder<'b> {
    raw: vks::VkSemaphoreCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SemaphoreCreateInfoFlags,
}

impl<'b> SemaphoreCreateInfoBuilder<'b> {
    pub fn new() -> SemaphoreCreateInfoBuilder<'b> {
        SemaphoreCreateInfoBuilder {
            raw: vks::VkSemaphoreCreateInfo::default(),
            _p: PhantomData,
            set_mask: SemaphoreCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SemaphoreCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreCreateFlags) -> SemaphoreCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= SemaphoreCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SemaphoreCreateInfoFlags::FLAG_PNEXT != SemaphoreCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SemaphoreCreateFlags> {
        if self.set_mask & SemaphoreCreateInfoFlags::FLAG_FLAGS != SemaphoreCreateInfoFlags::FLAG_FLAGS { return None }
        Some( SemaphoreCreateFlags::from_bits(self.raw.flags)
            .expect("SemaphoreCreateInfo::flags: error converting flags") )
    }

    pub fn build(self) -> SemaphoreCreateInfo<'b> {
        SemaphoreCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueryPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueryPoolCreateInfo<'s> {
    raw: vks::VkQueryPoolCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> QueryPoolCreateInfo<'s> {
    pub fn builder<'b>() -> QueryPoolCreateInfoBuilder<'b> {
        QueryPoolCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueryPoolCreateInfo) -> QueryPoolCreateInfo<'s> {
        QueryPoolCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> QueryPoolCreateFlags {
        QueryPoolCreateFlags::from_bits(self.raw.flags)
            .expect("QueryPoolCreateInfo::flags: error converting flags")
    }

    pub fn query_type<'a>(&'a self) -> QueryType {
        self.raw.queryType.into()
    }

    pub fn query_count<'a>(&'a self) -> u32 {
        self.raw.queryCount.into()
    }

    pub fn pipeline_statistics<'a>(&'a self) -> QueryPipelineStatisticFlags {
        QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("QueryPoolCreateInfo::pipeline_statistics: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: QueryPoolCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_query_type<'m>(&mut self, query_type: QueryType) {
        self.raw.queryType = query_type.into();
    }

    pub fn set_query_count<'m>(&mut self, query_count: u32) {
        self.raw.queryCount = query_count.into();
    }

    pub fn set_pipeline_statistics<'m>(&mut self, pipeline_statistics: QueryPipelineStatisticFlags) {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
    }

    pub fn as_raw(&self) -> &vks::VkQueryPoolCreateInfo {
        &self.raw
    }
}

impl<'s> From<QueryPoolCreateInfo<'s>> for vks::VkQueryPoolCreateInfo {
    fn from(f: QueryPoolCreateInfo<'s>) -> vks::VkQueryPoolCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkQueryPoolCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct QueryPoolCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_QUERYTYPE			 = 0b1000;
        const FLAG_QUERYCOUNT			 = 0b10000;
        const FLAG_PIPELINESTATISTICS			 = 0b100000;
    }
}


/// A builder for `VkQueryPoolCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueryPoolCreateInfoBuilder<'b> {
    raw: vks::VkQueryPoolCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: QueryPoolCreateInfoFlags,
}

impl<'b> QueryPoolCreateInfoBuilder<'b> {
    pub fn new() -> QueryPoolCreateInfoBuilder<'b> {
        QueryPoolCreateInfoBuilder {
            raw: vks::VkQueryPoolCreateInfo::default(),
            _p: PhantomData,
            set_mask: QueryPoolCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= QueryPoolCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: QueryPoolCreateFlags) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= QueryPoolCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn query_type<'m>(mut self, query_type: QueryType) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.queryType = query_type.into();
        self.set_mask |= QueryPoolCreateInfoFlags::FLAG_QUERYTYPE;
        self
    }

    pub fn query_count<'m>(mut self, query_count: u32) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.queryCount = query_count.into();
        self.set_mask |= QueryPoolCreateInfoFlags::FLAG_QUERYCOUNT;
        self
    }

    pub fn pipeline_statistics<'m>(mut self, pipeline_statistics: QueryPipelineStatisticFlags) -> QueryPoolCreateInfoBuilder<'b> {
        self.raw.pipelineStatistics = pipeline_statistics.bits();
        self.set_mask |= QueryPoolCreateInfoFlags::FLAG_PIPELINESTATISTICS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & QueryPoolCreateInfoFlags::FLAG_PNEXT != QueryPoolCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<QueryPoolCreateFlags> {
        if self.set_mask & QueryPoolCreateInfoFlags::FLAG_FLAGS != QueryPoolCreateInfoFlags::FLAG_FLAGS { return None }
        Some( QueryPoolCreateFlags::from_bits(self.raw.flags)
            .expect("QueryPoolCreateInfo::flags: error converting flags") )
    }

    pub fn get_query_type<'a>(&'a self) -> Option<QueryType> {
        if self.set_mask & QueryPoolCreateInfoFlags::FLAG_QUERYTYPE != QueryPoolCreateInfoFlags::FLAG_QUERYTYPE { return None }
        Some( self.raw.queryType.into() )
    }

    pub fn get_query_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & QueryPoolCreateInfoFlags::FLAG_QUERYCOUNT != QueryPoolCreateInfoFlags::FLAG_QUERYCOUNT { return None }
        Some( self.raw.queryCount.into() )
    }

    pub fn get_pipeline_statistics<'a>(&'a self) -> Option<QueryPipelineStatisticFlags> {
        if self.set_mask & QueryPoolCreateInfoFlags::FLAG_PIPELINESTATISTICS != QueryPoolCreateInfoFlags::FLAG_PIPELINESTATISTICS { return None }
        Some( QueryPipelineStatisticFlags::from_bits(self.raw.pipelineStatistics)
            .expect("QueryPoolCreateInfo::pipeline_statistics: error converting flags") )
    }

    pub fn build(self) -> QueryPoolCreateInfo<'b> {
        QueryPoolCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFramebufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FramebufferCreateInfo<'s> {
    raw: vks::VkFramebufferCreateInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> FramebufferCreateInfo<'s> {
    pub fn builder<'b>() -> FramebufferCreateInfoBuilder<'b> {
        FramebufferCreateInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFramebufferCreateInfo) -> FramebufferCreateInfo<'s> {
        FramebufferCreateInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> FramebufferCreateFlags {
        FramebufferCreateFlags::from_bits(self.raw.flags)
            .expect("FramebufferCreateInfo::flags: error converting flags")
    }

    pub fn render_pass<'a>(&'a self) -> vks::VkRenderPass {
        self.raw.renderPass
    }

    pub fn attachments<'a>(&'a self) -> &'a [vks::VkImageView] {
        unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) }
    }

    pub fn width<'a>(&'a self) -> u32 {
        self.raw.width.into()
    }

    pub fn height<'a>(&'a self) -> u32 {
        self.raw.height.into()
    }

    pub fn layers<'a>(&'a self) -> u32 {
        self.raw.layers.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: FramebufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_render_pass<'m, H>(&mut self, render_pass: H)
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
    }

    pub fn set_attachments<'m, 'a>(&mut self, attachments: &'a [ImageViewHandle])
            where 'a: 's {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `FramebufferCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkImageView;
    }

    pub fn set_width<'m>(&mut self, width: u32) {
        self.raw.width = width.into();
    }

    pub fn set_height<'m>(&mut self, height: u32) {
        self.raw.height = height.into();
    }

    pub fn set_layers<'m>(&mut self, layers: u32) {
        self.raw.layers = layers.into();
    }

    pub fn as_raw(&self) -> &vks::VkFramebufferCreateInfo {
        &self.raw
    }
}

impl<'s> From<FramebufferCreateInfo<'s>> for vks::VkFramebufferCreateInfo {
    fn from(f: FramebufferCreateInfo<'s>) -> vks::VkFramebufferCreateInfo {
        f.raw
    }
}


/// Bitflags for `VkFramebufferCreateInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FramebufferCreateInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_RENDERPASS			 = 0b1000;
        const FLAG_ATTACHMENTCOUNT			 = 0b10000;
        const FLAG_PATTACHMENTS			 = 0b100000;
        const FLAG_WIDTH			 = 0b1000000;
        const FLAG_HEIGHT			 = 0b10000000;
        const FLAG_LAYERS			 = 0b100000000;
    }
}


/// A builder for `VkFramebufferCreateInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FramebufferCreateInfoBuilder<'b> {
    raw: vks::VkFramebufferCreateInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: FramebufferCreateInfoFlags,
}

impl<'b> FramebufferCreateInfoBuilder<'b> {
    pub fn new() -> FramebufferCreateInfoBuilder<'b> {
        FramebufferCreateInfoBuilder {
            raw: vks::VkFramebufferCreateInfo::default(),
            _p: PhantomData,
            set_mask: FramebufferCreateInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: FramebufferCreateFlags) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_FLAGS;
        self
    }

    pub fn render_pass<'m, H>(mut self, render_pass: H) -> FramebufferCreateInfoBuilder<'b>
            where H: Handle<Target=RenderPassHandle> {
        self.raw.renderPass = render_pass.handle().0;
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_RENDERPASS;
        self
    }

    pub fn attachments<'m, 'a>(mut self, attachments: &'a [ImageViewHandle]) -> FramebufferCreateInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.attachmentCount == 0 || self.raw.attachmentCount == attachments.len() as _, 
            "count inconsistency found when specifying `FramebufferCreateInfo::attachments`.");
        self.raw.attachmentCount = attachments.len() as _;
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_ATTACHMENTCOUNT;
        self.raw.pAttachments = attachments.as_ptr() as *const vks::VkImageView;
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_PATTACHMENTS;
        self
    }

    pub fn width<'m>(mut self, width: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.width = width.into();
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_WIDTH;
        self
    }

    pub fn height<'m>(mut self, height: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.height = height.into();
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_HEIGHT;
        self
    }

    pub fn layers<'m>(mut self, layers: u32) -> FramebufferCreateInfoBuilder<'b> {
        self.raw.layers = layers.into();
        self.set_mask |= FramebufferCreateInfoFlags::FLAG_LAYERS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_PNEXT != FramebufferCreateInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<FramebufferCreateFlags> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_FLAGS != FramebufferCreateInfoFlags::FLAG_FLAGS { return None }
        Some( FramebufferCreateFlags::from_bits(self.raw.flags)
            .expect("FramebufferCreateInfo::flags: error converting flags") )
    }

    pub fn get_render_pass<'a>(&'a self) -> Option<vks::VkRenderPass> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_RENDERPASS != FramebufferCreateInfoFlags::FLAG_RENDERPASS { return None }
        Some( self.raw.renderPass )
    }

    pub fn get_attachments<'a>(&'a self) -> Option<&'a [vks::VkImageView]> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_PATTACHMENTS != FramebufferCreateInfoFlags::FLAG_PATTACHMENTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAttachments as *const _, self.raw.attachmentCount as usize) } )
    }

    pub fn get_width<'a>(&'a self) -> Option<u32> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_WIDTH != FramebufferCreateInfoFlags::FLAG_WIDTH { return None }
        Some( self.raw.width.into() )
    }

    pub fn get_height<'a>(&'a self) -> Option<u32> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_HEIGHT != FramebufferCreateInfoFlags::FLAG_HEIGHT { return None }
        Some( self.raw.height.into() )
    }

    pub fn get_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & FramebufferCreateInfoFlags::FLAG_LAYERS != FramebufferCreateInfoFlags::FLAG_LAYERS { return None }
        Some( self.raw.layers.into() )
    }

    pub fn build(self) -> FramebufferCreateInfo<'b> {
        FramebufferCreateInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDrawIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DrawIndirectCommand {
    raw: vks::VkDrawIndirectCommand,
}

impl DrawIndirectCommand {
    pub fn builder() -> DrawIndirectCommandBuilder {
        DrawIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDrawIndirectCommand) -> DrawIndirectCommand {
        DrawIndirectCommand { raw, }
    }

    pub fn vertex_count<'a>(&'a self) -> u32 {
        self.raw.vertexCount.into()
    }

    pub fn instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn first_vertex<'a>(&'a self) -> u32 {
        self.raw.firstVertex.into()
    }

    pub fn first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn set_vertex_count<'m>(&mut self, vertex_count: u32) {
        self.raw.vertexCount = vertex_count.into();
    }

    pub fn set_instance_count<'m>(&mut self, instance_count: u32) {
        self.raw.instanceCount = instance_count.into();
    }

    pub fn set_first_vertex<'m>(&mut self, first_vertex: u32) {
        self.raw.firstVertex = first_vertex.into();
    }

    pub fn set_first_instance<'m>(&mut self, first_instance: u32) {
        self.raw.firstInstance = first_instance.into();
    }

    pub fn as_raw(&self) -> &vks::VkDrawIndirectCommand {
        &self.raw
    }
}

impl From<DrawIndirectCommand> for vks::VkDrawIndirectCommand {
    fn from(f: DrawIndirectCommand) -> vks::VkDrawIndirectCommand {
        f.raw
    }
}


/// Bitflags for `VkDrawIndirectCommand`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DrawIndirectCommandFlags: u32 {
        const FLAG_VERTEXCOUNT			 = 0b1;
        const FLAG_INSTANCECOUNT			 = 0b10;
        const FLAG_FIRSTVERTEX			 = 0b100;
        const FLAG_FIRSTINSTANCE			 = 0b1000;
    }
}


/// A builder for `VkDrawIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DrawIndirectCommandBuilder {
    raw: vks::VkDrawIndirectCommand,
    set_mask: DrawIndirectCommandFlags,
}

impl DrawIndirectCommandBuilder {
    pub fn new() -> DrawIndirectCommandBuilder {
        DrawIndirectCommandBuilder {
            raw: vks::VkDrawIndirectCommand::default(),
            set_mask: DrawIndirectCommandFlags::default(),
        }
    }

    pub fn vertex_count<'m>(mut self, vertex_count: u32) -> DrawIndirectCommandBuilder {
        self.raw.vertexCount = vertex_count.into();
        self.set_mask |= DrawIndirectCommandFlags::FLAG_VERTEXCOUNT;
        self
    }

    pub fn instance_count<'m>(mut self, instance_count: u32) -> DrawIndirectCommandBuilder {
        self.raw.instanceCount = instance_count.into();
        self.set_mask |= DrawIndirectCommandFlags::FLAG_INSTANCECOUNT;
        self
    }

    pub fn first_vertex<'m>(mut self, first_vertex: u32) -> DrawIndirectCommandBuilder {
        self.raw.firstVertex = first_vertex.into();
        self.set_mask |= DrawIndirectCommandFlags::FLAG_FIRSTVERTEX;
        self
    }

    pub fn first_instance<'m>(mut self, first_instance: u32) -> DrawIndirectCommandBuilder {
        self.raw.firstInstance = first_instance.into();
        self.set_mask |= DrawIndirectCommandFlags::FLAG_FIRSTINSTANCE;
        self
    }

    pub fn get_vertex_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndirectCommandFlags::FLAG_VERTEXCOUNT != DrawIndirectCommandFlags::FLAG_VERTEXCOUNT { return None }
        Some( self.raw.vertexCount.into() )
    }

    pub fn get_instance_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndirectCommandFlags::FLAG_INSTANCECOUNT != DrawIndirectCommandFlags::FLAG_INSTANCECOUNT { return None }
        Some( self.raw.instanceCount.into() )
    }

    pub fn get_first_vertex<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndirectCommandFlags::FLAG_FIRSTVERTEX != DrawIndirectCommandFlags::FLAG_FIRSTVERTEX { return None }
        Some( self.raw.firstVertex.into() )
    }

    pub fn get_first_instance<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndirectCommandFlags::FLAG_FIRSTINSTANCE != DrawIndirectCommandFlags::FLAG_FIRSTINSTANCE { return None }
        Some( self.raw.firstInstance.into() )
    }

    pub fn build(self) -> DrawIndirectCommand {
        DrawIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkDrawIndexedIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DrawIndexedIndirectCommand {
    raw: vks::VkDrawIndexedIndirectCommand,
}

impl DrawIndexedIndirectCommand {
    pub fn builder() -> DrawIndexedIndirectCommandBuilder {
        DrawIndexedIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDrawIndexedIndirectCommand) -> DrawIndexedIndirectCommand {
        DrawIndexedIndirectCommand { raw, }
    }

    pub fn index_count<'a>(&'a self) -> u32 {
        self.raw.indexCount.into()
    }

    pub fn instance_count<'a>(&'a self) -> u32 {
        self.raw.instanceCount.into()
    }

    pub fn first_index<'a>(&'a self) -> u32 {
        self.raw.firstIndex.into()
    }

    pub fn vertex_offset<'a>(&'a self) -> i32 {
        self.raw.vertexOffset.into()
    }

    pub fn first_instance<'a>(&'a self) -> u32 {
        self.raw.firstInstance.into()
    }

    pub fn set_index_count<'m>(&mut self, index_count: u32) {
        self.raw.indexCount = index_count.into();
    }

    pub fn set_instance_count<'m>(&mut self, instance_count: u32) {
        self.raw.instanceCount = instance_count.into();
    }

    pub fn set_first_index<'m>(&mut self, first_index: u32) {
        self.raw.firstIndex = first_index.into();
    }

    pub fn set_vertex_offset<'m>(&mut self, vertex_offset: i32) {
        self.raw.vertexOffset = vertex_offset.into();
    }

    pub fn set_first_instance<'m>(&mut self, first_instance: u32) {
        self.raw.firstInstance = first_instance.into();
    }

    pub fn as_raw(&self) -> &vks::VkDrawIndexedIndirectCommand {
        &self.raw
    }
}

impl From<DrawIndexedIndirectCommand> for vks::VkDrawIndexedIndirectCommand {
    fn from(f: DrawIndexedIndirectCommand) -> vks::VkDrawIndexedIndirectCommand {
        f.raw
    }
}


/// Bitflags for `VkDrawIndexedIndirectCommand`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DrawIndexedIndirectCommandFlags: u32 {
        const FLAG_INDEXCOUNT			 = 0b1;
        const FLAG_INSTANCECOUNT			 = 0b10;
        const FLAG_FIRSTINDEX			 = 0b100;
        const FLAG_VERTEXOFFSET			 = 0b1000;
        const FLAG_FIRSTINSTANCE			 = 0b10000;
    }
}


/// A builder for `VkDrawIndexedIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DrawIndexedIndirectCommandBuilder {
    raw: vks::VkDrawIndexedIndirectCommand,
    set_mask: DrawIndexedIndirectCommandFlags,
}

impl DrawIndexedIndirectCommandBuilder {
    pub fn new() -> DrawIndexedIndirectCommandBuilder {
        DrawIndexedIndirectCommandBuilder {
            raw: vks::VkDrawIndexedIndirectCommand::default(),
            set_mask: DrawIndexedIndirectCommandFlags::default(),
        }
    }

    pub fn index_count<'m>(mut self, index_count: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.indexCount = index_count.into();
        self.set_mask |= DrawIndexedIndirectCommandFlags::FLAG_INDEXCOUNT;
        self
    }

    pub fn instance_count<'m>(mut self, instance_count: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.instanceCount = instance_count.into();
        self.set_mask |= DrawIndexedIndirectCommandFlags::FLAG_INSTANCECOUNT;
        self
    }

    pub fn first_index<'m>(mut self, first_index: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.firstIndex = first_index.into();
        self.set_mask |= DrawIndexedIndirectCommandFlags::FLAG_FIRSTINDEX;
        self
    }

    pub fn vertex_offset<'m>(mut self, vertex_offset: i32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.vertexOffset = vertex_offset.into();
        self.set_mask |= DrawIndexedIndirectCommandFlags::FLAG_VERTEXOFFSET;
        self
    }

    pub fn first_instance<'m>(mut self, first_instance: u32) -> DrawIndexedIndirectCommandBuilder {
        self.raw.firstInstance = first_instance.into();
        self.set_mask |= DrawIndexedIndirectCommandFlags::FLAG_FIRSTINSTANCE;
        self
    }

    pub fn get_index_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndexedIndirectCommandFlags::FLAG_INDEXCOUNT != DrawIndexedIndirectCommandFlags::FLAG_INDEXCOUNT { return None }
        Some( self.raw.indexCount.into() )
    }

    pub fn get_instance_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndexedIndirectCommandFlags::FLAG_INSTANCECOUNT != DrawIndexedIndirectCommandFlags::FLAG_INSTANCECOUNT { return None }
        Some( self.raw.instanceCount.into() )
    }

    pub fn get_first_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndexedIndirectCommandFlags::FLAG_FIRSTINDEX != DrawIndexedIndirectCommandFlags::FLAG_FIRSTINDEX { return None }
        Some( self.raw.firstIndex.into() )
    }

    pub fn get_vertex_offset<'a>(&'a self) -> Option<i32> {
        if self.set_mask & DrawIndexedIndirectCommandFlags::FLAG_VERTEXOFFSET != DrawIndexedIndirectCommandFlags::FLAG_VERTEXOFFSET { return None }
        Some( self.raw.vertexOffset.into() )
    }

    pub fn get_first_instance<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DrawIndexedIndirectCommandFlags::FLAG_FIRSTINSTANCE != DrawIndexedIndirectCommandFlags::FLAG_FIRSTINSTANCE { return None }
        Some( self.raw.firstInstance.into() )
    }

    pub fn build(self) -> DrawIndexedIndirectCommand {
        DrawIndexedIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkDispatchIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DispatchIndirectCommand {
    raw: vks::VkDispatchIndirectCommand,
}

impl DispatchIndirectCommand {
    pub fn builder() -> DispatchIndirectCommandBuilder {
        DispatchIndirectCommandBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDispatchIndirectCommand) -> DispatchIndirectCommand {
        DispatchIndirectCommand { raw, }
    }

    pub fn x<'a>(&'a self) -> u32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> u32 {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> u32 {
        self.raw.z.into()
    }

    pub fn set_x<'m>(&mut self, x: u32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: u32) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: u32) {
        self.raw.z = z.into();
    }

    pub fn as_raw(&self) -> &vks::VkDispatchIndirectCommand {
        &self.raw
    }
}

impl From<DispatchIndirectCommand> for vks::VkDispatchIndirectCommand {
    fn from(f: DispatchIndirectCommand) -> vks::VkDispatchIndirectCommand {
        f.raw
    }
}


/// Bitflags for `VkDispatchIndirectCommand`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DispatchIndirectCommandFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
        const FLAG_Z			 = 0b100;
    }
}


/// A builder for `VkDispatchIndirectCommand`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DispatchIndirectCommandBuilder {
    raw: vks::VkDispatchIndirectCommand,
    set_mask: DispatchIndirectCommandFlags,
}

impl DispatchIndirectCommandBuilder {
    pub fn new() -> DispatchIndirectCommandBuilder {
        DispatchIndirectCommandBuilder {
            raw: vks::VkDispatchIndirectCommand::default(),
            set_mask: DispatchIndirectCommandFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: u32) -> DispatchIndirectCommandBuilder {
        self.raw.x = x.into();
        self.set_mask |= DispatchIndirectCommandFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: u32) -> DispatchIndirectCommandBuilder {
        self.raw.y = y.into();
        self.set_mask |= DispatchIndirectCommandFlags::FLAG_Y;
        self
    }

    pub fn z<'m>(mut self, z: u32) -> DispatchIndirectCommandBuilder {
        self.raw.z = z.into();
        self.set_mask |= DispatchIndirectCommandFlags::FLAG_Z;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DispatchIndirectCommandFlags::FLAG_X != DispatchIndirectCommandFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DispatchIndirectCommandFlags::FLAG_Y != DispatchIndirectCommandFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn get_z<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DispatchIndirectCommandFlags::FLAG_Z != DispatchIndirectCommandFlags::FLAG_Z { return None }
        Some( self.raw.z.into() )
    }

    pub fn build(self) -> DispatchIndirectCommand {
        DispatchIndirectCommand {
            raw: self.raw,
        }
    }
}


/// A `VkSubmitInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SubmitInfo<'s> {
    raw: vks::VkSubmitInfo,
    _p: PhantomData<&'s ()>,
}

impl<'s> SubmitInfo<'s> {
    pub fn builder<'b>() -> SubmitInfoBuilder<'b> {
        SubmitInfoBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSubmitInfo) -> SubmitInfo<'s> {
        SubmitInfo { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn wait_dst_stage_mask<'a>(&'a self) -> &'a PipelineStageFlags {
        unsafe { &*(self.raw.pWaitDstStageMask as *const _) }
    }

    pub fn command_buffers<'a>(&'a self) -> &'a [vks::VkCommandBuffer] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBuffers as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn signal_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_wait_dst_stage_mask<'m, 'a>(&mut self, wait_dst_stage_mask: &'a PipelineStageFlags) {
        self.raw.pWaitDstStageMask = wait_dst_stage_mask as *const PipelineStageFlags as *const _;
    }

    pub fn set_command_buffers<'m, 'a>(&mut self, command_buffers: &'a [CommandBufferHandle])
            where 'a: 's {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffers.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::command_buffers`.");
        self.raw.commandBufferCount = command_buffers.len() as _;
        self.raw.pCommandBuffers = command_buffers.as_ptr() as *const vks::VkCommandBuffer;
    }

    pub fn set_signal_semaphores<'m, 'a>(&mut self, signal_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn as_raw(&self) -> &vks::VkSubmitInfo {
        &self.raw
    }
}

impl<'s> From<SubmitInfo<'s>> for vks::VkSubmitInfo {
    fn from(f: SubmitInfo<'s>) -> vks::VkSubmitInfo {
        f.raw
    }
}


/// Bitflags for `VkSubmitInfo`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SubmitInfoFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_WAITSEMAPHORECOUNT			 = 0b100;
        const FLAG_PWAITSEMAPHORES			 = 0b1000;
        const FLAG_PWAITDSTSTAGEMASK			 = 0b10000;
        const FLAG_COMMANDBUFFERCOUNT			 = 0b100000;
        const FLAG_PCOMMANDBUFFERS			 = 0b1000000;
        const FLAG_SIGNALSEMAPHORECOUNT			 = 0b10000000;
        const FLAG_PSIGNALSEMAPHORES			 = 0b100000000;
    }
}


/// A builder for `VkSubmitInfo`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SubmitInfoBuilder<'b> {
    raw: vks::VkSubmitInfo,
    _p: PhantomData<&'b ()>, 
    set_mask: SubmitInfoFlags,
}

impl<'b> SubmitInfoBuilder<'b> {
    pub fn new() -> SubmitInfoBuilder<'b> {
        SubmitInfoBuilder {
            raw: vks::VkSubmitInfo::default(),
            _p: PhantomData,
            set_mask: SubmitInfoFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SubmitInfoBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SubmitInfoFlags::FLAG_PNEXT;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.set_mask |= SubmitInfoFlags::FLAG_WAITSEMAPHORECOUNT;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self.set_mask |= SubmitInfoFlags::FLAG_PWAITSEMAPHORES;
        self
    }

    pub fn wait_dst_stage_mask<'m, 'a>(mut self, wait_dst_stage_mask: &'a PipelineStageFlags) -> SubmitInfoBuilder<'b> {
        self.raw.pWaitDstStageMask = wait_dst_stage_mask as *const PipelineStageFlags as *const _;
        self.set_mask |= SubmitInfoFlags::FLAG_PWAITDSTSTAGEMASK;
        self
    }

    pub fn command_buffers<'m, 'a>(mut self, command_buffers: &'a [CommandBufferHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffers.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::command_buffers`.");
        self.raw.commandBufferCount = command_buffers.len() as _;
        self.set_mask |= SubmitInfoFlags::FLAG_COMMANDBUFFERCOUNT;
        self.raw.pCommandBuffers = command_buffers.as_ptr() as *const vks::VkCommandBuffer;
        self.set_mask |= SubmitInfoFlags::FLAG_PCOMMANDBUFFERS;
        self
    }

    pub fn signal_semaphores<'m, 'a>(mut self, signal_semaphores: &'a [SemaphoreHandle]) -> SubmitInfoBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphores.len() as _, 
            "count inconsistency found when specifying `SubmitInfo::signal_semaphores`.");
        self.raw.signalSemaphoreCount = signal_semaphores.len() as _;
        self.set_mask |= SubmitInfoFlags::FLAG_SIGNALSEMAPHORECOUNT;
        self.raw.pSignalSemaphores = signal_semaphores.as_ptr() as *const vks::VkSemaphore;
        self.set_mask |= SubmitInfoFlags::FLAG_PSIGNALSEMAPHORES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SubmitInfoFlags::FLAG_PNEXT != SubmitInfoFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> Option<&'a [vks::VkSemaphore]> {
        if self.set_mask & SubmitInfoFlags::FLAG_PWAITSEMAPHORES != SubmitInfoFlags::FLAG_PWAITSEMAPHORES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) } )
    }

    pub fn get_wait_dst_stage_mask<'a>(&'a self) -> Option<&'a PipelineStageFlags> {
        if self.set_mask & SubmitInfoFlags::FLAG_PWAITDSTSTAGEMASK != SubmitInfoFlags::FLAG_PWAITDSTSTAGEMASK { return None }
        Some( unsafe { &*(self.raw.pWaitDstStageMask as *const _) } )
    }

    pub fn get_command_buffers<'a>(&'a self) -> Option<&'a [vks::VkCommandBuffer]> {
        if self.set_mask & SubmitInfoFlags::FLAG_PCOMMANDBUFFERS != SubmitInfoFlags::FLAG_PCOMMANDBUFFERS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pCommandBuffers as *const _, self.raw.commandBufferCount as usize) } )
    }

    pub fn get_signal_semaphores<'a>(&'a self) -> Option<&'a [vks::VkSemaphore]> {
        if self.set_mask & SubmitInfoFlags::FLAG_PSIGNALSEMAPHORES != SubmitInfoFlags::FLAG_PSIGNALSEMAPHORES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSignalSemaphores as *const _, self.raw.signalSemaphoreCount as usize) } )
    }

    pub fn build(self) -> SubmitInfo<'b> {
        SubmitInfo {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPropertiesKhr<'s> {
    raw: vks::VkDisplayPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPropertiesKhr<'s> {
    pub fn builder<'b>() -> DisplayPropertiesKhrBuilder<'b> {
        DisplayPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPropertiesKHR) -> DisplayPropertiesKhr<'s> {
        DisplayPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.display
    }

    pub fn display_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.displayName) }
    }

    pub fn physical_dimensions<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.physicalDimensions as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn physical_dimensions_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalDimensions as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn physical_resolution<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.physicalResolution as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn physical_resolution_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.physicalResolution as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("DisplayPropertiesKhr::supported_transforms: error converting flags")
    }

    pub fn plane_reorder_possible<'a>(&'a self) -> bool {
        self.raw.planeReorderPossible != 0
    }

    pub fn persistent_content<'a>(&'a self) -> bool {
        self.raw.persistentContent != 0
    }

    pub fn set_display<'m, H>(&mut self, display: H)
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.display = display.handle().0;
    }

    pub fn set_display_name<'m, 'a>(&mut self, display_name: &'a CStr)
            where 'a: 's {
        self.raw.displayName = display_name.as_ptr();
    }

    pub fn set_physical_dimensions<'m>(&mut self, physical_dimensions: Extent2d) {
        self.raw.physicalDimensions = physical_dimensions.raw;
    }

    pub fn set_physical_resolution<'m>(&mut self, physical_resolution: Extent2d) {
        self.raw.physicalResolution = physical_resolution.raw;
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_plane_reorder_possible<'m>(&mut self, plane_reorder_possible: bool) {
        self.raw.planeReorderPossible = plane_reorder_possible as u32;
    }

    pub fn set_persistent_content<'m>(&mut self, persistent_content: bool) {
        self.raw.persistentContent = persistent_content as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<DisplayPropertiesKhr<'s>> for vks::VkDisplayPropertiesKHR {
    fn from(f: DisplayPropertiesKhr<'s>) -> vks::VkDisplayPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayPropertiesKhrFlags: u32 {
        const FLAG_DISPLAY			 = 0b1;
        const FLAG_DISPLAYNAME			 = 0b10;
        const FLAG_PHYSICALDIMENSIONS			 = 0b100;
        const FLAG_PHYSICALRESOLUTION			 = 0b1000;
        const FLAG_SUPPORTEDTRANSFORMS			 = 0b10000;
        const FLAG_PLANEREORDERPOSSIBLE			 = 0b100000;
        const FLAG_PERSISTENTCONTENT			 = 0b1000000;
    }
}


/// A builder for `VkDisplayPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPropertiesKhrBuilder<'b> {
    raw: vks::VkDisplayPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplayPropertiesKhrFlags,
}

impl<'b> DisplayPropertiesKhrBuilder<'b> {
    pub fn new() -> DisplayPropertiesKhrBuilder<'b> {
        DisplayPropertiesKhrBuilder {
            raw: vks::VkDisplayPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: DisplayPropertiesKhrFlags::default(),
        }
    }

    pub fn display<'m, H>(mut self, display: H) -> DisplayPropertiesKhrBuilder<'b>
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.display = display.handle().0;
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_DISPLAY;
        self
    }

    pub fn display_name<'m, 'a>(mut self, display_name: &'a CStr) -> DisplayPropertiesKhrBuilder<'b>
            where 'a: 'b {
        self.raw.displayName = display_name.as_ptr();
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_DISPLAYNAME;
        self
    }

    pub fn physical_dimensions<'m>(mut self, physical_dimensions: Extent2d) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.physicalDimensions = physical_dimensions.raw;
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_PHYSICALDIMENSIONS;
        self
    }

    pub fn physical_resolution<'m>(mut self, physical_resolution: Extent2d) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.physicalResolution = physical_resolution.raw;
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_PHYSICALRESOLUTION;
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.supportedTransforms = supported_transforms.bits();
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS;
        self
    }

    pub fn plane_reorder_possible<'m>(mut self, plane_reorder_possible: bool) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.planeReorderPossible = plane_reorder_possible as u32;
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_PLANEREORDERPOSSIBLE;
        self
    }

    pub fn persistent_content<'m>(mut self, persistent_content: bool) -> DisplayPropertiesKhrBuilder<'b> {
        self.raw.persistentContent = persistent_content as u32;
        self.set_mask |= DisplayPropertiesKhrFlags::FLAG_PERSISTENTCONTENT;
        self
    }

    pub fn get_display<'a>(&'a self) -> Option<vks::VkDisplayKHR> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_DISPLAY != DisplayPropertiesKhrFlags::FLAG_DISPLAY { return None }
        Some( self.raw.display )
    }

    pub fn get_display_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_DISPLAYNAME != DisplayPropertiesKhrFlags::FLAG_DISPLAYNAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.displayName) } )
    }

    pub fn get_physical_dimensions<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PHYSICALDIMENSIONS != DisplayPropertiesKhrFlags::FLAG_PHYSICALDIMENSIONS { return None }
        Some(  unsafe { &*(&self.raw.physicalDimensions as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_physical_dimensions_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PHYSICALDIMENSIONS != DisplayPropertiesKhrFlags::FLAG_PHYSICALDIMENSIONS { return None }
        Some( unsafe { &mut *(&mut self.raw.physicalDimensions as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_physical_resolution<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PHYSICALRESOLUTION != DisplayPropertiesKhrFlags::FLAG_PHYSICALRESOLUTION { return None }
        Some(  unsafe { &*(&self.raw.physicalResolution as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_physical_resolution_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PHYSICALRESOLUTION != DisplayPropertiesKhrFlags::FLAG_PHYSICALRESOLUTION { return None }
        Some( unsafe { &mut *(&mut self.raw.physicalResolution as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_supported_transforms<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS != DisplayPropertiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("DisplayPropertiesKhr::supported_transforms: error converting flags") )
    }

    pub fn get_plane_reorder_possible<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PLANEREORDERPOSSIBLE != DisplayPropertiesKhrFlags::FLAG_PLANEREORDERPOSSIBLE { return None }
        Some( self.raw.planeReorderPossible != 0 )
    }

    pub fn get_persistent_content<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DisplayPropertiesKhrFlags::FLAG_PERSISTENTCONTENT != DisplayPropertiesKhrFlags::FLAG_PERSISTENTCONTENT { return None }
        Some( self.raw.persistentContent != 0 )
    }

    pub fn build(self) -> DisplayPropertiesKhr<'b> {
        DisplayPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPlanePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPlanePropertiesKhr {
    raw: vks::VkDisplayPlanePropertiesKHR,
}

impl DisplayPlanePropertiesKhr {
    pub fn builder() -> DisplayPlanePropertiesKhrBuilder {
        DisplayPlanePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPlanePropertiesKHR) -> DisplayPlanePropertiesKhr {
        DisplayPlanePropertiesKhr { raw, }
    }

    pub fn current_display<'a>(&'a self) -> vks::VkDisplayKHR {
        self.raw.currentDisplay
    }

    pub fn current_stack_index<'a>(&'a self) -> u32 {
        self.raw.currentStackIndex.into()
    }

    pub fn set_current_display<'m, H>(&mut self, current_display: H)
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.currentDisplay = current_display.handle().0;
    }

    pub fn set_current_stack_index<'m>(&mut self, current_stack_index: u32) {
        self.raw.currentStackIndex = current_stack_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPlanePropertiesKHR {
        &self.raw
    }
}

impl From<DisplayPlanePropertiesKhr> for vks::VkDisplayPlanePropertiesKHR {
    fn from(f: DisplayPlanePropertiesKhr) -> vks::VkDisplayPlanePropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayPlanePropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayPlanePropertiesKhrFlags: u32 {
        const FLAG_CURRENTDISPLAY			 = 0b1;
        const FLAG_CURRENTSTACKINDEX			 = 0b10;
    }
}


/// A builder for `VkDisplayPlanePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPlanePropertiesKhrBuilder {
    raw: vks::VkDisplayPlanePropertiesKHR,
    set_mask: DisplayPlanePropertiesKhrFlags,
}

impl DisplayPlanePropertiesKhrBuilder {
    pub fn new() -> DisplayPlanePropertiesKhrBuilder {
        DisplayPlanePropertiesKhrBuilder {
            raw: vks::VkDisplayPlanePropertiesKHR::default(),
            set_mask: DisplayPlanePropertiesKhrFlags::default(),
        }
    }

    pub fn current_display<'m, H>(mut self, current_display: H) -> DisplayPlanePropertiesKhrBuilder
            where H: Handle<Target=DisplayKhrHandle> {
        self.raw.currentDisplay = current_display.handle().0;
        self.set_mask |= DisplayPlanePropertiesKhrFlags::FLAG_CURRENTDISPLAY;
        self
    }

    pub fn current_stack_index<'m>(mut self, current_stack_index: u32) -> DisplayPlanePropertiesKhrBuilder {
        self.raw.currentStackIndex = current_stack_index.into();
        self.set_mask |= DisplayPlanePropertiesKhrFlags::FLAG_CURRENTSTACKINDEX;
        self
    }

    pub fn get_current_display<'a>(&'a self) -> Option<vks::VkDisplayKHR> {
        if self.set_mask & DisplayPlanePropertiesKhrFlags::FLAG_CURRENTDISPLAY != DisplayPlanePropertiesKhrFlags::FLAG_CURRENTDISPLAY { return None }
        Some( self.raw.currentDisplay )
    }

    pub fn get_current_stack_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DisplayPlanePropertiesKhrFlags::FLAG_CURRENTSTACKINDEX != DisplayPlanePropertiesKhrFlags::FLAG_CURRENTSTACKINDEX { return None }
        Some( self.raw.currentStackIndex.into() )
    }

    pub fn build(self) -> DisplayPlanePropertiesKhr {
        DisplayPlanePropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModeParametersKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModeParametersKhr {
    raw: vks::VkDisplayModeParametersKHR,
}

impl DisplayModeParametersKhr {
    pub fn builder() -> DisplayModeParametersKhrBuilder {
        DisplayModeParametersKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModeParametersKHR) -> DisplayModeParametersKhr {
        DisplayModeParametersKhr { raw, }
    }

    pub fn visible_region<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.visibleRegion as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn visible_region_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.visibleRegion as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn refresh_rate<'a>(&'a self) -> u32 {
        self.raw.refreshRate.into()
    }

    pub fn set_visible_region<'m>(&mut self, visible_region: Extent2d) {
        self.raw.visibleRegion = visible_region.raw;
    }

    pub fn set_refresh_rate<'m>(&mut self, refresh_rate: u32) {
        self.raw.refreshRate = refresh_rate.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModeParametersKHR {
        &self.raw
    }
}

impl From<DisplayModeParametersKhr> for vks::VkDisplayModeParametersKHR {
    fn from(f: DisplayModeParametersKhr) -> vks::VkDisplayModeParametersKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayModeParametersKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayModeParametersKhrFlags: u32 {
        const FLAG_VISIBLEREGION			 = 0b1;
        const FLAG_REFRESHRATE			 = 0b10;
    }
}


/// A builder for `VkDisplayModeParametersKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModeParametersKhrBuilder {
    raw: vks::VkDisplayModeParametersKHR,
    set_mask: DisplayModeParametersKhrFlags,
}

impl DisplayModeParametersKhrBuilder {
    pub fn new() -> DisplayModeParametersKhrBuilder {
        DisplayModeParametersKhrBuilder {
            raw: vks::VkDisplayModeParametersKHR::default(),
            set_mask: DisplayModeParametersKhrFlags::default(),
        }
    }

    pub fn visible_region<'m>(mut self, visible_region: Extent2d) -> DisplayModeParametersKhrBuilder {
        self.raw.visibleRegion = visible_region.raw;
        self.set_mask |= DisplayModeParametersKhrFlags::FLAG_VISIBLEREGION;
        self
    }

    pub fn refresh_rate<'m>(mut self, refresh_rate: u32) -> DisplayModeParametersKhrBuilder {
        self.raw.refreshRate = refresh_rate.into();
        self.set_mask |= DisplayModeParametersKhrFlags::FLAG_REFRESHRATE;
        self
    }

    pub fn get_visible_region<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayModeParametersKhrFlags::FLAG_VISIBLEREGION != DisplayModeParametersKhrFlags::FLAG_VISIBLEREGION { return None }
        Some(  unsafe { &*(&self.raw.visibleRegion as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_visible_region_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayModeParametersKhrFlags::FLAG_VISIBLEREGION != DisplayModeParametersKhrFlags::FLAG_VISIBLEREGION { return None }
        Some( unsafe { &mut *(&mut self.raw.visibleRegion as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_refresh_rate<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DisplayModeParametersKhrFlags::FLAG_REFRESHRATE != DisplayModeParametersKhrFlags::FLAG_REFRESHRATE { return None }
        Some( self.raw.refreshRate.into() )
    }

    pub fn build(self) -> DisplayModeParametersKhr {
        DisplayModeParametersKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModePropertiesKhr {
    raw: vks::VkDisplayModePropertiesKHR,
}

impl DisplayModePropertiesKhr {
    pub fn builder() -> DisplayModePropertiesKhrBuilder {
        DisplayModePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModePropertiesKHR) -> DisplayModePropertiesKhr {
        DisplayModePropertiesKhr { raw, }
    }

    pub fn display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
         unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub fn set_display_mode<'m, H>(&mut self, display_mode: H)
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
    }

    pub fn set_parameters<'m>(&mut self, parameters: DisplayModeParametersKhr) {
        self.raw.parameters = parameters.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModePropertiesKHR {
        &self.raw
    }
}

impl From<DisplayModePropertiesKhr> for vks::VkDisplayModePropertiesKHR {
    fn from(f: DisplayModePropertiesKhr) -> vks::VkDisplayModePropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayModePropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayModePropertiesKhrFlags: u32 {
        const FLAG_DISPLAYMODE			 = 0b1;
        const FLAG_PARAMETERS			 = 0b10;
    }
}


/// A builder for `VkDisplayModePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModePropertiesKhrBuilder {
    raw: vks::VkDisplayModePropertiesKHR,
    set_mask: DisplayModePropertiesKhrFlags,
}

impl DisplayModePropertiesKhrBuilder {
    pub fn new() -> DisplayModePropertiesKhrBuilder {
        DisplayModePropertiesKhrBuilder {
            raw: vks::VkDisplayModePropertiesKHR::default(),
            set_mask: DisplayModePropertiesKhrFlags::default(),
        }
    }

    pub fn display_mode<'m, H>(mut self, display_mode: H) -> DisplayModePropertiesKhrBuilder
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
        self.set_mask |= DisplayModePropertiesKhrFlags::FLAG_DISPLAYMODE;
        self
    }

    pub fn parameters<'m>(mut self, parameters: DisplayModeParametersKhr) -> DisplayModePropertiesKhrBuilder {
        self.raw.parameters = parameters.raw;
        self.set_mask |= DisplayModePropertiesKhrFlags::FLAG_PARAMETERS;
        self
    }

    pub fn get_display_mode<'a>(&'a self) -> Option<vks::VkDisplayModeKHR> {
        if self.set_mask & DisplayModePropertiesKhrFlags::FLAG_DISPLAYMODE != DisplayModePropertiesKhrFlags::FLAG_DISPLAYMODE { return None }
        Some( self.raw.displayMode )
    }

    pub fn get_parameters<'a>(&'a self) -> Option<&'a DisplayModeParametersKhr> {
        if self.set_mask & DisplayModePropertiesKhrFlags::FLAG_PARAMETERS != DisplayModePropertiesKhrFlags::FLAG_PARAMETERS { return None }
        Some(  unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) } )
    }

    pub fn get_parameters_mut<'a>(&'a mut self) -> Option<&'a mut DisplayModeParametersKhr> {
        if self.set_mask & DisplayModePropertiesKhrFlags::FLAG_PARAMETERS != DisplayModePropertiesKhrFlags::FLAG_PARAMETERS { return None }
        Some( unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) } )
    }

    pub fn build(self) -> DisplayModePropertiesKhr {
        DisplayModePropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplayModeCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayModeCreateInfoKhr<'s> {
    raw: vks::VkDisplayModeCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayModeCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DisplayModeCreateInfoKhrBuilder<'b> {
        DisplayModeCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayModeCreateInfoKHR) -> DisplayModeCreateInfoKhr<'s> {
        DisplayModeCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DisplayModeCreateFlagsKhr {
        DisplayModeCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplayModeCreateInfoKhr::flags: error converting flags")
    }

    pub fn parameters<'a>(&'a self) -> &'a DisplayModeParametersKhr {
         unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) }
    }

    pub fn parameters_mut<'a>(&'a mut self) -> &'a mut DisplayModeParametersKhr {
        unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DisplayModeCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_parameters<'m>(&mut self, parameters: DisplayModeParametersKhr) {
        self.raw.parameters = parameters.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayModeCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplayModeCreateInfoKhr<'s>> for vks::VkDisplayModeCreateInfoKHR {
    fn from(f: DisplayModeCreateInfoKhr<'s>) -> vks::VkDisplayModeCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayModeCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayModeCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PARAMETERS			 = 0b1000;
    }
}


/// A builder for `VkDisplayModeCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayModeCreateInfoKhrBuilder<'b> {
    raw: vks::VkDisplayModeCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplayModeCreateInfoKhrFlags,
}

impl<'b> DisplayModeCreateInfoKhrBuilder<'b> {
    pub fn new() -> DisplayModeCreateInfoKhrBuilder<'b> {
        DisplayModeCreateInfoKhrBuilder {
            raw: vks::VkDisplayModeCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: DisplayModeCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DisplayModeCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DisplayModeCreateFlagsKhr) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DisplayModeCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn parameters<'m>(mut self, parameters: DisplayModeParametersKhr) -> DisplayModeCreateInfoKhrBuilder<'b> {
        self.raw.parameters = parameters.raw;
        self.set_mask |= DisplayModeCreateInfoKhrFlags::FLAG_PARAMETERS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DisplayModeCreateInfoKhrFlags::FLAG_PNEXT != DisplayModeCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DisplayModeCreateFlagsKhr> {
        if self.set_mask & DisplayModeCreateInfoKhrFlags::FLAG_FLAGS != DisplayModeCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( DisplayModeCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplayModeCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_parameters<'a>(&'a self) -> Option<&'a DisplayModeParametersKhr> {
        if self.set_mask & DisplayModeCreateInfoKhrFlags::FLAG_PARAMETERS != DisplayModeCreateInfoKhrFlags::FLAG_PARAMETERS { return None }
        Some(  unsafe { &*(&self.raw.parameters as *const vks::VkDisplayModeParametersKHR as *const DisplayModeParametersKhr) } )
    }

    pub fn get_parameters_mut<'a>(&'a mut self) -> Option<&'a mut DisplayModeParametersKhr> {
        if self.set_mask & DisplayModeCreateInfoKhrFlags::FLAG_PARAMETERS != DisplayModeCreateInfoKhrFlags::FLAG_PARAMETERS { return None }
        Some( unsafe { &mut *(&mut self.raw.parameters as *mut  vks::VkDisplayModeParametersKHR as *mut DisplayModeParametersKhr) } )
    }

    pub fn build(self) -> DisplayModeCreateInfoKhr<'b> {
        DisplayModeCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPlaneCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPlaneCapabilitiesKhr {
    raw: vks::VkDisplayPlaneCapabilitiesKHR,
}

impl DisplayPlaneCapabilitiesKhr {
    pub fn builder() -> DisplayPlaneCapabilitiesKhrBuilder {
        DisplayPlaneCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPlaneCapabilitiesKHR) -> DisplayPlaneCapabilitiesKhr {
        DisplayPlaneCapabilitiesKhr { raw, }
    }

    pub fn supported_alpha<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.supportedAlpha)
            .expect("DisplayPlaneCapabilitiesKhr::supported_alpha: error converting flags")
    }

    pub fn min_src_position<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.minSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn min_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn max_src_position<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.maxSrcPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn max_src_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn min_src_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.minSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_src_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.maxSrcExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_src_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_dst_position<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.minDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn min_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.minDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn max_dst_position<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.maxDstPosition as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn max_dst_position_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.maxDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn min_dst_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.minDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_dst_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.maxDstExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_dst_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn set_supported_alpha<'m>(&mut self, supported_alpha: DisplayPlaneAlphaFlagsKhr) {
        self.raw.supportedAlpha = supported_alpha.bits();
    }

    pub fn set_min_src_position<'m>(&mut self, min_src_position: Offset2d) {
        self.raw.minSrcPosition = min_src_position.raw;
    }

    pub fn set_max_src_position<'m>(&mut self, max_src_position: Offset2d) {
        self.raw.maxSrcPosition = max_src_position.raw;
    }

    pub fn set_min_src_extent<'m>(&mut self, min_src_extent: Extent2d) {
        self.raw.minSrcExtent = min_src_extent.raw;
    }

    pub fn set_max_src_extent<'m>(&mut self, max_src_extent: Extent2d) {
        self.raw.maxSrcExtent = max_src_extent.raw;
    }

    pub fn set_min_dst_position<'m>(&mut self, min_dst_position: Offset2d) {
        self.raw.minDstPosition = min_dst_position.raw;
    }

    pub fn set_max_dst_position<'m>(&mut self, max_dst_position: Offset2d) {
        self.raw.maxDstPosition = max_dst_position.raw;
    }

    pub fn set_min_dst_extent<'m>(&mut self, min_dst_extent: Extent2d) {
        self.raw.minDstExtent = min_dst_extent.raw;
    }

    pub fn set_max_dst_extent<'m>(&mut self, max_dst_extent: Extent2d) {
        self.raw.maxDstExtent = max_dst_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPlaneCapabilitiesKHR {
        &self.raw
    }
}

impl From<DisplayPlaneCapabilitiesKhr> for vks::VkDisplayPlaneCapabilitiesKHR {
    fn from(f: DisplayPlaneCapabilitiesKhr) -> vks::VkDisplayPlaneCapabilitiesKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayPlaneCapabilitiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayPlaneCapabilitiesKhrFlags: u32 {
        const FLAG_SUPPORTEDALPHA			 = 0b1;
        const FLAG_MINSRCPOSITION			 = 0b10;
        const FLAG_MAXSRCPOSITION			 = 0b100;
        const FLAG_MINSRCEXTENT			 = 0b1000;
        const FLAG_MAXSRCEXTENT			 = 0b10000;
        const FLAG_MINDSTPOSITION			 = 0b100000;
        const FLAG_MAXDSTPOSITION			 = 0b1000000;
        const FLAG_MINDSTEXTENT			 = 0b10000000;
        const FLAG_MAXDSTEXTENT			 = 0b100000000;
    }
}


/// A builder for `VkDisplayPlaneCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPlaneCapabilitiesKhrBuilder {
    raw: vks::VkDisplayPlaneCapabilitiesKHR,
    set_mask: DisplayPlaneCapabilitiesKhrFlags,
}

impl DisplayPlaneCapabilitiesKhrBuilder {
    pub fn new() -> DisplayPlaneCapabilitiesKhrBuilder {
        DisplayPlaneCapabilitiesKhrBuilder {
            raw: vks::VkDisplayPlaneCapabilitiesKHR::default(),
            set_mask: DisplayPlaneCapabilitiesKhrFlags::default(),
        }
    }

    pub fn supported_alpha<'m>(mut self, supported_alpha: DisplayPlaneAlphaFlagsKhr) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.supportedAlpha = supported_alpha.bits();
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_SUPPORTEDALPHA;
        self
    }

    pub fn min_src_position<'m>(mut self, min_src_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minSrcPosition = min_src_position.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCPOSITION;
        self
    }

    pub fn max_src_position<'m>(mut self, max_src_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxSrcPosition = max_src_position.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCPOSITION;
        self
    }

    pub fn min_src_extent<'m>(mut self, min_src_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minSrcExtent = min_src_extent.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCEXTENT;
        self
    }

    pub fn max_src_extent<'m>(mut self, max_src_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxSrcExtent = max_src_extent.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCEXTENT;
        self
    }

    pub fn min_dst_position<'m>(mut self, min_dst_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minDstPosition = min_dst_position.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTPOSITION;
        self
    }

    pub fn max_dst_position<'m>(mut self, max_dst_position: Offset2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxDstPosition = max_dst_position.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTPOSITION;
        self
    }

    pub fn min_dst_extent<'m>(mut self, min_dst_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.minDstExtent = min_dst_extent.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTEXTENT;
        self
    }

    pub fn max_dst_extent<'m>(mut self, max_dst_extent: Extent2d) -> DisplayPlaneCapabilitiesKhrBuilder {
        self.raw.maxDstExtent = max_dst_extent.raw;
        self.set_mask |= DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTEXTENT;
        self
    }

    pub fn get_supported_alpha<'a>(&'a self) -> Option<DisplayPlaneAlphaFlagsKhr> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_SUPPORTEDALPHA != DisplayPlaneCapabilitiesKhrFlags::FLAG_SUPPORTEDALPHA { return None }
        Some( DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.supportedAlpha)
            .expect("DisplayPlaneCapabilitiesKhr::supported_alpha: error converting flags") )
    }

    pub fn get_min_src_position<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCPOSITION { return None }
        Some(  unsafe { &*(&self.raw.minSrcPosition as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_min_src_position_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCPOSITION { return None }
        Some( unsafe { &mut *(&mut self.raw.minSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_max_src_position<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCPOSITION { return None }
        Some(  unsafe { &*(&self.raw.maxSrcPosition as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_max_src_position_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCPOSITION { return None }
        Some( unsafe { &mut *(&mut self.raw.maxSrcPosition as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_min_src_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCEXTENT { return None }
        Some(  unsafe { &*(&self.raw.minSrcExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_min_src_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINSRCEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.minSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_src_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCEXTENT { return None }
        Some(  unsafe { &*(&self.raw.maxSrcExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_max_src_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXSRCEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.maxSrcExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_min_dst_position<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTPOSITION { return None }
        Some(  unsafe { &*(&self.raw.minDstPosition as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_min_dst_position_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTPOSITION { return None }
        Some( unsafe { &mut *(&mut self.raw.minDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_max_dst_position<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTPOSITION { return None }
        Some(  unsafe { &*(&self.raw.maxDstPosition as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_max_dst_position_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTPOSITION != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTPOSITION { return None }
        Some( unsafe { &mut *(&mut self.raw.maxDstPosition as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_min_dst_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTEXTENT { return None }
        Some(  unsafe { &*(&self.raw.minDstExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_min_dst_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MINDSTEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.minDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_dst_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTEXTENT { return None }
        Some(  unsafe { &*(&self.raw.maxDstExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_max_dst_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTEXTENT != DisplayPlaneCapabilitiesKhrFlags::FLAG_MAXDSTEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.maxDstExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn build(self) -> DisplayPlaneCapabilitiesKhr {
        DisplayPlaneCapabilitiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDisplaySurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplaySurfaceCreateInfoKhr<'s> {
    raw: vks::VkDisplaySurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplaySurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        DisplaySurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplaySurfaceCreateInfoKHR) -> DisplaySurfaceCreateInfoKhr<'s> {
        DisplaySurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DisplaySurfaceCreateFlagsKhr {
        DisplaySurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplaySurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn display_mode<'a>(&'a self) -> vks::VkDisplayModeKHR {
        self.raw.displayMode
    }

    pub fn plane_index<'a>(&'a self) -> u32 {
        self.raw.planeIndex.into()
    }

    pub fn plane_stack_index<'a>(&'a self) -> u32 {
        self.raw.planeStackIndex.into()
    }

    pub fn transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.transform)
            .expect("DisplaySurfaceCreateInfoKhr::transform: error converting flags")
    }

    pub fn global_alpha<'a>(&'a self) -> f32 {
        self.raw.globalAlpha.into()
    }

    pub fn alpha_mode<'a>(&'a self) -> DisplayPlaneAlphaFlagsKhr {
        DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.alphaMode)
            .expect("DisplaySurfaceCreateInfoKhr::alpha_mode: error converting flags")
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DisplaySurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_display_mode<'m, H>(&mut self, display_mode: H)
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
    }

    pub fn set_plane_index<'m>(&mut self, plane_index: u32) {
        self.raw.planeIndex = plane_index.into();
    }

    pub fn set_plane_stack_index<'m>(&mut self, plane_stack_index: u32) {
        self.raw.planeStackIndex = plane_stack_index.into();
    }

    pub fn set_transform<'m>(&mut self, transform: SurfaceTransformFlagsKhr) {
        self.raw.transform = transform.bits();
    }

    pub fn set_global_alpha<'m>(&mut self, global_alpha: f32) {
        self.raw.globalAlpha = global_alpha.into();
    }

    pub fn set_alpha_mode<'m>(&mut self, alpha_mode: DisplayPlaneAlphaFlagsKhr) {
        self.raw.alphaMode = alpha_mode.bits();
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent2d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn as_raw(&self) -> &vks::VkDisplaySurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplaySurfaceCreateInfoKhr<'s>> for vks::VkDisplaySurfaceCreateInfoKHR {
    fn from(f: DisplaySurfaceCreateInfoKhr<'s>) -> vks::VkDisplaySurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplaySurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplaySurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DISPLAYMODE			 = 0b1000;
        const FLAG_PLANEINDEX			 = 0b10000;
        const FLAG_PLANESTACKINDEX			 = 0b100000;
        const FLAG_TRANSFORM			 = 0b1000000;
        const FLAG_GLOBALALPHA			 = 0b10000000;
        const FLAG_ALPHAMODE			 = 0b100000000;
        const FLAG_IMAGEEXTENT			 = 0b1000000000;
    }
}


/// A builder for `VkDisplaySurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplaySurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkDisplaySurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplaySurfaceCreateInfoKhrFlags,
}

impl<'b> DisplaySurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        DisplaySurfaceCreateInfoKhrBuilder {
            raw: vks::VkDisplaySurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: DisplaySurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DisplaySurfaceCreateFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn display_mode<'m, H>(mut self, display_mode: H) -> DisplaySurfaceCreateInfoKhrBuilder<'b>
            where H: Handle<Target=DisplayModeKhrHandle> {
        self.raw.displayMode = display_mode.handle().0;
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_DISPLAYMODE;
        self
    }

    pub fn plane_index<'m>(mut self, plane_index: u32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.planeIndex = plane_index.into();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANEINDEX;
        self
    }

    pub fn plane_stack_index<'m>(mut self, plane_stack_index: u32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.planeStackIndex = plane_stack_index.into();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANESTACKINDEX;
        self
    }

    pub fn transform<'m>(mut self, transform: SurfaceTransformFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.transform = transform.bits();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_TRANSFORM;
        self
    }

    pub fn global_alpha<'m>(mut self, global_alpha: f32) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.globalAlpha = global_alpha.into();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_GLOBALALPHA;
        self
    }

    pub fn alpha_mode<'m>(mut self, alpha_mode: DisplayPlaneAlphaFlagsKhr) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.alphaMode = alpha_mode.bits();
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_ALPHAMODE;
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent2d) -> DisplaySurfaceCreateInfoKhrBuilder<'b> {
        self.raw.imageExtent = image_extent.raw;
        self.set_mask |= DisplaySurfaceCreateInfoKhrFlags::FLAG_IMAGEEXTENT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_PNEXT != DisplaySurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DisplaySurfaceCreateFlagsKhr> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_FLAGS != DisplaySurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( DisplaySurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DisplaySurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_display_mode<'a>(&'a self) -> Option<vks::VkDisplayModeKHR> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_DISPLAYMODE != DisplaySurfaceCreateInfoKhrFlags::FLAG_DISPLAYMODE { return None }
        Some( self.raw.displayMode )
    }

    pub fn get_plane_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANEINDEX != DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANEINDEX { return None }
        Some( self.raw.planeIndex.into() )
    }

    pub fn get_plane_stack_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANESTACKINDEX != DisplaySurfaceCreateInfoKhrFlags::FLAG_PLANESTACKINDEX { return None }
        Some( self.raw.planeStackIndex.into() )
    }

    pub fn get_transform<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_TRANSFORM != DisplaySurfaceCreateInfoKhrFlags::FLAG_TRANSFORM { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.transform)
            .expect("DisplaySurfaceCreateInfoKhr::transform: error converting flags") )
    }

    pub fn get_global_alpha<'a>(&'a self) -> Option<f32> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_GLOBALALPHA != DisplaySurfaceCreateInfoKhrFlags::FLAG_GLOBALALPHA { return None }
        Some( self.raw.globalAlpha.into() )
    }

    pub fn get_alpha_mode<'a>(&'a self) -> Option<DisplayPlaneAlphaFlagsKhr> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_ALPHAMODE != DisplaySurfaceCreateInfoKhrFlags::FLAG_ALPHAMODE { return None }
        Some( DisplayPlaneAlphaFlagsKhr::from_bits(self.raw.alphaMode)
            .expect("DisplaySurfaceCreateInfoKhr::alpha_mode: error converting flags") )
    }

    pub fn get_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_IMAGEEXTENT != DisplaySurfaceCreateInfoKhrFlags::FLAG_IMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & DisplaySurfaceCreateInfoKhrFlags::FLAG_IMAGEEXTENT != DisplaySurfaceCreateInfoKhrFlags::FLAG_IMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn build(self) -> DisplaySurfaceCreateInfoKhr<'b> {
        DisplaySurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPresentInfoKhr<'s> {
    raw: vks::VkDisplayPresentInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPresentInfoKhr<'s> {
    pub fn builder<'b>() -> DisplayPresentInfoKhrBuilder<'b> {
        DisplayPresentInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPresentInfoKHR) -> DisplayPresentInfoKhr<'s> {
        DisplayPresentInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_rect<'a>(&'a self) -> &'a Rect2d {
         unsafe { &*(&self.raw.srcRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn src_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.srcRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn dst_rect<'a>(&'a self) -> &'a Rect2d {
         unsafe { &*(&self.raw.dstRect as *const vks::VkRect2D as *const Rect2d) }
    }

    pub fn dst_rect_mut<'a>(&'a mut self) -> &'a mut Rect2d {
        unsafe { &mut *(&mut self.raw.dstRect as *mut  vks::VkRect2D as *mut Rect2d) }
    }

    pub fn persistent<'a>(&'a self) -> bool {
        self.raw.persistent != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_rect<'m>(&mut self, src_rect: Rect2d) {
        self.raw.srcRect = src_rect.raw;
    }

    pub fn set_dst_rect<'m>(&mut self, dst_rect: Rect2d) {
        self.raw.dstRect = dst_rect.raw;
    }

    pub fn set_persistent<'m>(&mut self, persistent: bool) {
        self.raw.persistent = persistent as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPresentInfoKHR {
        &self.raw
    }
}

impl<'s> From<DisplayPresentInfoKhr<'s>> for vks::VkDisplayPresentInfoKHR {
    fn from(f: DisplayPresentInfoKhr<'s>) -> vks::VkDisplayPresentInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkDisplayPresentInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayPresentInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCRECT			 = 0b100;
        const FLAG_DSTRECT			 = 0b1000;
        const FLAG_PERSISTENT			 = 0b10000;
    }
}


/// A builder for `VkDisplayPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPresentInfoKhrBuilder<'b> {
    raw: vks::VkDisplayPresentInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplayPresentInfoKhrFlags,
}

impl<'b> DisplayPresentInfoKhrBuilder<'b> {
    pub fn new() -> DisplayPresentInfoKhrBuilder<'b> {
        DisplayPresentInfoKhrBuilder {
            raw: vks::VkDisplayPresentInfoKHR::default(),
            _p: PhantomData,
            set_mask: DisplayPresentInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DisplayPresentInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn src_rect<'m>(mut self, src_rect: Rect2d) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.srcRect = src_rect.raw;
        self.set_mask |= DisplayPresentInfoKhrFlags::FLAG_SRCRECT;
        self
    }

    pub fn dst_rect<'m>(mut self, dst_rect: Rect2d) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.dstRect = dst_rect.raw;
        self.set_mask |= DisplayPresentInfoKhrFlags::FLAG_DSTRECT;
        self
    }

    pub fn persistent<'m>(mut self, persistent: bool) -> DisplayPresentInfoKhrBuilder<'b> {
        self.raw.persistent = persistent as u32;
        self.set_mask |= DisplayPresentInfoKhrFlags::FLAG_PERSISTENT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_PNEXT != DisplayPresentInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_rect<'a>(&'a self) -> Option<&'a Rect2d> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_SRCRECT != DisplayPresentInfoKhrFlags::FLAG_SRCRECT { return None }
        Some(  unsafe { &*(&self.raw.srcRect as *const vks::VkRect2D as *const Rect2d) } )
    }

    pub fn get_src_rect_mut<'a>(&'a mut self) -> Option<&'a mut Rect2d> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_SRCRECT != DisplayPresentInfoKhrFlags::FLAG_SRCRECT { return None }
        Some( unsafe { &mut *(&mut self.raw.srcRect as *mut  vks::VkRect2D as *mut Rect2d) } )
    }

    pub fn get_dst_rect<'a>(&'a self) -> Option<&'a Rect2d> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_DSTRECT != DisplayPresentInfoKhrFlags::FLAG_DSTRECT { return None }
        Some(  unsafe { &*(&self.raw.dstRect as *const vks::VkRect2D as *const Rect2d) } )
    }

    pub fn get_dst_rect_mut<'a>(&'a mut self) -> Option<&'a mut Rect2d> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_DSTRECT != DisplayPresentInfoKhrFlags::FLAG_DSTRECT { return None }
        Some( unsafe { &mut *(&mut self.raw.dstRect as *mut  vks::VkRect2D as *mut Rect2d) } )
    }

    pub fn get_persistent<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DisplayPresentInfoKhrFlags::FLAG_PERSISTENT != DisplayPresentInfoKhrFlags::FLAG_PERSISTENT { return None }
        Some( self.raw.persistent != 0 )
    }

    pub fn build(self) -> DisplayPresentInfoKhr<'b> {
        DisplayPresentInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilitiesKhr {
    raw: vks::VkSurfaceCapabilitiesKHR,
}

impl SurfaceCapabilitiesKhr {
    pub fn builder() -> SurfaceCapabilitiesKhrBuilder {
        SurfaceCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilitiesKHR) -> SurfaceCapabilitiesKhr {
        SurfaceCapabilitiesKhr { raw, }
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn current_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilitiesKhr::supported_transforms: error converting flags")
    }

    pub fn current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilitiesKhr::current_transform: error converting flags")
    }

    pub fn supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilitiesKhr::supported_composite_alpha: error converting flags")
    }

    pub fn supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilitiesKhr::supported_usage_flags: error converting flags")
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_max_image_count<'m>(&mut self, max_image_count: u32) {
        self.raw.maxImageCount = max_image_count.into();
    }

    pub fn set_current_extent<'m>(&mut self, current_extent: Extent2d) {
        self.raw.currentExtent = current_extent.raw;
    }

    pub fn set_min_image_extent<'m>(&mut self, min_image_extent: Extent2d) {
        self.raw.minImageExtent = min_image_extent.raw;
    }

    pub fn set_max_image_extent<'m>(&mut self, max_image_extent: Extent2d) {
        self.raw.maxImageExtent = max_image_extent.raw;
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_current_transform<'m>(&mut self, current_transform: SurfaceTransformFlagsKhr) {
        self.raw.currentTransform = current_transform.bits();
    }

    pub fn set_supported_composite_alpha<'m>(&mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
    }

    pub fn set_supported_usage_flags<'m>(&mut self, supported_usage_flags: ImageUsageFlags) {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilitiesKHR {
        &self.raw
    }
}

impl From<SurfaceCapabilitiesKhr> for vks::VkSurfaceCapabilitiesKHR {
    fn from(f: SurfaceCapabilitiesKhr) -> vks::VkSurfaceCapabilitiesKHR {
        f.raw
    }
}


/// Bitflags for `VkSurfaceCapabilitiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SurfaceCapabilitiesKhrFlags: u32 {
        const FLAG_MINIMAGECOUNT			 = 0b1;
        const FLAG_MAXIMAGECOUNT			 = 0b10;
        const FLAG_CURRENTEXTENT			 = 0b100;
        const FLAG_MINIMAGEEXTENT			 = 0b1000;
        const FLAG_MAXIMAGEEXTENT			 = 0b10000;
        const FLAG_MAXIMAGEARRAYLAYERS			 = 0b100000;
        const FLAG_SUPPORTEDTRANSFORMS			 = 0b1000000;
        const FLAG_CURRENTTRANSFORM			 = 0b10000000;
        const FLAG_SUPPORTEDCOMPOSITEALPHA			 = 0b100000000;
        const FLAG_SUPPORTEDUSAGEFLAGS			 = 0b1000000000;
    }
}


/// A builder for `VkSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilitiesKhrBuilder {
    raw: vks::VkSurfaceCapabilitiesKHR,
    set_mask: SurfaceCapabilitiesKhrFlags,
}

impl SurfaceCapabilitiesKhrBuilder {
    pub fn new() -> SurfaceCapabilitiesKhrBuilder {
        SurfaceCapabilitiesKhrBuilder {
            raw: vks::VkSurfaceCapabilitiesKHR::default(),
            set_mask: SurfaceCapabilitiesKhrFlags::default(),
        }
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.minImageCount = min_image_count.into();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGECOUNT;
        self
    }

    pub fn max_image_count<'m>(mut self, max_image_count: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageCount = max_image_count.into();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGECOUNT;
        self
    }

    pub fn current_extent<'m>(mut self, current_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.currentExtent = current_extent.raw;
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_CURRENTEXTENT;
        self
    }

    pub fn min_image_extent<'m>(mut self, min_image_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.minImageExtent = min_image_extent.raw;
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGEEXTENT;
        self
    }

    pub fn max_image_extent<'m>(mut self, max_image_extent: Extent2d) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageExtent = max_image_extent.raw;
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEEXTENT;
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEARRAYLAYERS;
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedTransforms = supported_transforms.bits();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS;
        self
    }

    pub fn current_transform<'m>(mut self, current_transform: SurfaceTransformFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.currentTransform = current_transform.bits();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_CURRENTTRANSFORM;
        self
    }

    pub fn supported_composite_alpha<'m>(mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDCOMPOSITEALPHA;
        self
    }

    pub fn supported_usage_flags<'m>(mut self, supported_usage_flags: ImageUsageFlags) -> SurfaceCapabilitiesKhrBuilder {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
        self.set_mask |= SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDUSAGEFLAGS;
        self
    }

    pub fn get_min_image_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGECOUNT != SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGECOUNT { return None }
        Some( self.raw.minImageCount.into() )
    }

    pub fn get_max_image_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGECOUNT != SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGECOUNT { return None }
        Some( self.raw.maxImageCount.into() )
    }

    pub fn get_current_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_CURRENTEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_CURRENTEXTENT { return None }
        Some(  unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_current_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_CURRENTEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_CURRENTEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_min_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGEEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_min_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGEEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_MINIMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_max_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEEXTENT != SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEARRAYLAYERS != SurfaceCapabilitiesKhrFlags::FLAG_MAXIMAGEARRAYLAYERS { return None }
        Some( self.raw.maxImageArrayLayers.into() )
    }

    pub fn get_supported_transforms<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS != SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDTRANSFORMS { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilitiesKhr::supported_transforms: error converting flags") )
    }

    pub fn get_current_transform<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_CURRENTTRANSFORM != SurfaceCapabilitiesKhrFlags::FLAG_CURRENTTRANSFORM { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilitiesKhr::current_transform: error converting flags") )
    }

    pub fn get_supported_composite_alpha<'a>(&'a self) -> Option<CompositeAlphaFlagsKhr> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDCOMPOSITEALPHA != SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDCOMPOSITEALPHA { return None }
        Some( CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilitiesKhr::supported_composite_alpha: error converting flags") )
    }

    pub fn get_supported_usage_flags<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDUSAGEFLAGS != SurfaceCapabilitiesKhrFlags::FLAG_SUPPORTEDUSAGEFLAGS { return None }
        Some( ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilitiesKhr::supported_usage_flags: error converting flags") )
    }

    pub fn build(self) -> SurfaceCapabilitiesKhr {
        SurfaceCapabilitiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkAndroidSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AndroidSurfaceCreateInfoKhr<'s> {
    raw: vks::VkAndroidSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> AndroidSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        AndroidSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAndroidSurfaceCreateInfoKHR) -> AndroidSurfaceCreateInfoKhr<'s> {
        AndroidSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> AndroidSurfaceCreateFlagsKhr {
        AndroidSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("AndroidSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn window<'a>(&'a self) -> *mut ANativeWindow {
        self.raw.window
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: AndroidSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_window<'m>(&mut self, window: *mut ANativeWindow) {
        self.raw.window = window;
    }

    pub fn as_raw(&self) -> &vks::VkAndroidSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<AndroidSurfaceCreateInfoKhr<'s>> for vks::VkAndroidSurfaceCreateInfoKHR {
    fn from(f: AndroidSurfaceCreateInfoKhr<'s>) -> vks::VkAndroidSurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkAndroidSurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct AndroidSurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_WINDOW			 = 0b1000;
    }
}


/// A builder for `VkAndroidSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct AndroidSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkAndroidSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: AndroidSurfaceCreateInfoKhrFlags,
}

impl<'b> AndroidSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        AndroidSurfaceCreateInfoKhrBuilder {
            raw: vks::VkAndroidSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: AndroidSurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= AndroidSurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: AndroidSurfaceCreateFlagsKhr) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= AndroidSurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn window<'m>(mut self, window: *mut ANativeWindow) -> AndroidSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window;
        self.set_mask |= AndroidSurfaceCreateInfoKhrFlags::FLAG_WINDOW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & AndroidSurfaceCreateInfoKhrFlags::FLAG_PNEXT != AndroidSurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<AndroidSurfaceCreateFlagsKhr> {
        if self.set_mask & AndroidSurfaceCreateInfoKhrFlags::FLAG_FLAGS != AndroidSurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( AndroidSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("AndroidSurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_window<'a>(&'a self) -> Option<*mut ANativeWindow> {
        if self.set_mask & AndroidSurfaceCreateInfoKhrFlags::FLAG_WINDOW != AndroidSurfaceCreateInfoKhrFlags::FLAG_WINDOW { return None }
        Some( self.raw.window )
    }

    pub fn build(self) -> AndroidSurfaceCreateInfoKhr<'b> {
        AndroidSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMirSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MirSurfaceCreateInfoKhr<'s> {
    raw: vks::VkMirSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MirSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> MirSurfaceCreateInfoKhrBuilder<'b> {
        MirSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMirSurfaceCreateInfoKHR) -> MirSurfaceCreateInfoKhr<'s> {
        MirSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MirSurfaceCreateFlagsKhr {
        MirSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("MirSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn connection<'a>(&'a self) -> *mut MirConnection {
        self.raw.connection
    }

    pub fn mir_surface<'a>(&'a self) -> *mut MirSurface {
        self.raw.mirSurface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MirSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_connection<'m>(&mut self, connection: *mut MirConnection) {
        self.raw.connection = connection;
    }

    pub unsafe fn set_mir_surface<'m>(&mut self, mir_surface: *mut MirSurface) {
        self.raw.mirSurface = mir_surface;
    }

    pub fn as_raw(&self) -> &vks::VkMirSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<MirSurfaceCreateInfoKhr<'s>> for vks::VkMirSurfaceCreateInfoKHR {
    fn from(f: MirSurfaceCreateInfoKhr<'s>) -> vks::VkMirSurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkMirSurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MirSurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_CONNECTION			 = 0b1000;
        const FLAG_MIRSURFACE			 = 0b10000;
    }
}


/// A builder for `VkMirSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MirSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkMirSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MirSurfaceCreateInfoKhrFlags,
}

impl<'b> MirSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> MirSurfaceCreateInfoKhrBuilder<'b> {
        MirSurfaceCreateInfoKhrBuilder {
            raw: vks::VkMirSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: MirSurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MirSurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: MirSurfaceCreateFlagsKhr) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= MirSurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn connection<'m>(mut self, connection: *mut MirConnection) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.connection = connection;
        self.set_mask |= MirSurfaceCreateInfoKhrFlags::FLAG_CONNECTION;
        self
    }

    pub unsafe fn mir_surface<'m>(mut self, mir_surface: *mut MirSurface) -> MirSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.mirSurface = mir_surface;
        self.set_mask |= MirSurfaceCreateInfoKhrFlags::FLAG_MIRSURFACE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MirSurfaceCreateInfoKhrFlags::FLAG_PNEXT != MirSurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<MirSurfaceCreateFlagsKhr> {
        if self.set_mask & MirSurfaceCreateInfoKhrFlags::FLAG_FLAGS != MirSurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( MirSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("MirSurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_connection<'a>(&'a self) -> Option<*mut MirConnection> {
        if self.set_mask & MirSurfaceCreateInfoKhrFlags::FLAG_CONNECTION != MirSurfaceCreateInfoKhrFlags::FLAG_CONNECTION { return None }
        Some( self.raw.connection )
    }

    pub fn get_mir_surface<'a>(&'a self) -> Option<*mut MirSurface> {
        if self.set_mask & MirSurfaceCreateInfoKhrFlags::FLAG_MIRSURFACE != MirSurfaceCreateInfoKhrFlags::FLAG_MIRSURFACE { return None }
        Some( self.raw.mirSurface )
    }

    pub fn build(self) -> MirSurfaceCreateInfoKhr<'b> {
        MirSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViSurfaceCreateInfoNN`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViSurfaceCreateInfoNn<'s> {
    raw: vks::VkViSurfaceCreateInfoNN,
    _p: PhantomData<&'s ()>,
}

impl<'s> ViSurfaceCreateInfoNn<'s> {
    pub fn builder<'b>() -> ViSurfaceCreateInfoNnBuilder<'b> {
        ViSurfaceCreateInfoNnBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViSurfaceCreateInfoNN) -> ViSurfaceCreateInfoNn<'s> {
        ViSurfaceCreateInfoNn { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> ViSurfaceCreateFlagsNn {
        ViSurfaceCreateFlagsNn::from_bits(self.raw.flags)
            .expect("ViSurfaceCreateInfoNn::flags: error converting flags")
    }

    pub fn window<'a>(&'a self) -> *mut c_void {
        self.raw.window
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: ViSurfaceCreateFlagsNn) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_window<'m>(&mut self, window: *mut c_void) {
        self.raw.window = window;
    }

    pub fn as_raw(&self) -> &vks::VkViSurfaceCreateInfoNN {
        &self.raw
    }
}

impl<'s> From<ViSurfaceCreateInfoNn<'s>> for vks::VkViSurfaceCreateInfoNN {
    fn from(f: ViSurfaceCreateInfoNn<'s>) -> vks::VkViSurfaceCreateInfoNN {
        f.raw
    }
}


/// Bitflags for `VkViSurfaceCreateInfoNN`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ViSurfaceCreateInfoNnFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_WINDOW			 = 0b1000;
    }
}


/// A builder for `VkViSurfaceCreateInfoNN`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViSurfaceCreateInfoNnBuilder<'b> {
    raw: vks::VkViSurfaceCreateInfoNN,
    _p: PhantomData<&'b ()>, 
    set_mask: ViSurfaceCreateInfoNnFlags,
}

impl<'b> ViSurfaceCreateInfoNnBuilder<'b> {
    pub fn new() -> ViSurfaceCreateInfoNnBuilder<'b> {
        ViSurfaceCreateInfoNnBuilder {
            raw: vks::VkViSurfaceCreateInfoNN::default(),
            _p: PhantomData,
            set_mask: ViSurfaceCreateInfoNnFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ViSurfaceCreateInfoNnFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: ViSurfaceCreateFlagsNn) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ViSurfaceCreateInfoNnFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn window<'m>(mut self, window: *mut c_void) -> ViSurfaceCreateInfoNnBuilder<'b> {
        self.raw.window = window;
        self.set_mask |= ViSurfaceCreateInfoNnFlags::FLAG_WINDOW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ViSurfaceCreateInfoNnFlags::FLAG_PNEXT != ViSurfaceCreateInfoNnFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ViSurfaceCreateFlagsNn> {
        if self.set_mask & ViSurfaceCreateInfoNnFlags::FLAG_FLAGS != ViSurfaceCreateInfoNnFlags::FLAG_FLAGS { return None }
        Some( ViSurfaceCreateFlagsNn::from_bits(self.raw.flags)
            .expect("ViSurfaceCreateInfoNn::flags: error converting flags") )
    }

    pub fn get_window<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ViSurfaceCreateInfoNnFlags::FLAG_WINDOW != ViSurfaceCreateInfoNnFlags::FLAG_WINDOW { return None }
        Some( self.raw.window )
    }

    pub fn build(self) -> ViSurfaceCreateInfoNn<'b> {
        ViSurfaceCreateInfoNn {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWaylandSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct WaylandSurfaceCreateInfoKhr<'s> {
    raw: vks::VkWaylandSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> WaylandSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        WaylandSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWaylandSurfaceCreateInfoKHR) -> WaylandSurfaceCreateInfoKhr<'s> {
        WaylandSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> WaylandSurfaceCreateFlagsKhr {
        WaylandSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("WaylandSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn display<'a>(&'a self) -> *mut wl_display {
        self.raw.display
    }

    pub fn surface<'a>(&'a self) -> *mut wl_surface {
        self.raw.surface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: WaylandSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_display<'m>(&mut self, display: *mut wl_display) {
        self.raw.display = display;
    }

    pub unsafe fn set_surface<'m>(&mut self, surface: *mut wl_surface) {
        self.raw.surface = surface;
    }

    pub fn as_raw(&self) -> &vks::VkWaylandSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<WaylandSurfaceCreateInfoKhr<'s>> for vks::VkWaylandSurfaceCreateInfoKHR {
    fn from(f: WaylandSurfaceCreateInfoKhr<'s>) -> vks::VkWaylandSurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkWaylandSurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct WaylandSurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DISPLAY			 = 0b1000;
        const FLAG_SURFACE			 = 0b10000;
    }
}


/// A builder for `VkWaylandSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct WaylandSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkWaylandSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: WaylandSurfaceCreateInfoKhrFlags,
}

impl<'b> WaylandSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        WaylandSurfaceCreateInfoKhrBuilder {
            raw: vks::VkWaylandSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: WaylandSurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= WaylandSurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: WaylandSurfaceCreateFlagsKhr) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= WaylandSurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn display<'m>(mut self, display: *mut wl_display) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.display = display;
        self.set_mask |= WaylandSurfaceCreateInfoKhrFlags::FLAG_DISPLAY;
        self
    }

    pub unsafe fn surface<'m>(mut self, surface: *mut wl_surface) -> WaylandSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.surface = surface;
        self.set_mask |= WaylandSurfaceCreateInfoKhrFlags::FLAG_SURFACE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & WaylandSurfaceCreateInfoKhrFlags::FLAG_PNEXT != WaylandSurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<WaylandSurfaceCreateFlagsKhr> {
        if self.set_mask & WaylandSurfaceCreateInfoKhrFlags::FLAG_FLAGS != WaylandSurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( WaylandSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("WaylandSurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_display<'a>(&'a self) -> Option<*mut wl_display> {
        if self.set_mask & WaylandSurfaceCreateInfoKhrFlags::FLAG_DISPLAY != WaylandSurfaceCreateInfoKhrFlags::FLAG_DISPLAY { return None }
        Some( self.raw.display )
    }

    pub fn get_surface<'a>(&'a self) -> Option<*mut wl_surface> {
        if self.set_mask & WaylandSurfaceCreateInfoKhrFlags::FLAG_SURFACE != WaylandSurfaceCreateInfoKhrFlags::FLAG_SURFACE { return None }
        Some( self.raw.surface )
    }

    pub fn build(self) -> WaylandSurfaceCreateInfoKhr<'b> {
        WaylandSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32SurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32SurfaceCreateInfoKhr<'s> {
    raw: vks::VkWin32SurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32SurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        Win32SurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32SurfaceCreateInfoKHR) -> Win32SurfaceCreateInfoKhr<'s> {
        Win32SurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> Win32SurfaceCreateFlagsKhr {
        Win32SurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("Win32SurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn hinstance<'a>(&'a self) -> HINSTANCE {
        self.raw.hinstance.into()
    }

    pub fn hwnd<'a>(&'a self) -> HWND {
        self.raw.hwnd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: Win32SurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_hinstance<'m>(&mut self, hinstance: HINSTANCE) {
        self.raw.hinstance = hinstance.into();
    }

    pub fn set_hwnd<'m>(&mut self, hwnd: HWND) {
        self.raw.hwnd = hwnd.into();
    }

    pub fn as_raw(&self) -> &vks::VkWin32SurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<Win32SurfaceCreateInfoKhr<'s>> for vks::VkWin32SurfaceCreateInfoKHR {
    fn from(f: Win32SurfaceCreateInfoKhr<'s>) -> vks::VkWin32SurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkWin32SurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Win32SurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_HINSTANCE			 = 0b1000;
        const FLAG_HWND			 = 0b10000;
    }
}


/// A builder for `VkWin32SurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32SurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkWin32SurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: Win32SurfaceCreateInfoKhrFlags,
}

impl<'b> Win32SurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        Win32SurfaceCreateInfoKhrBuilder {
            raw: vks::VkWin32SurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: Win32SurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= Win32SurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: Win32SurfaceCreateFlagsKhr) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= Win32SurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn hinstance<'m>(mut self, hinstance: HINSTANCE) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.hinstance = hinstance.into();
        self.set_mask |= Win32SurfaceCreateInfoKhrFlags::FLAG_HINSTANCE;
        self
    }

    pub fn hwnd<'m>(mut self, hwnd: HWND) -> Win32SurfaceCreateInfoKhrBuilder<'b> {
        self.raw.hwnd = hwnd.into();
        self.set_mask |= Win32SurfaceCreateInfoKhrFlags::FLAG_HWND;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & Win32SurfaceCreateInfoKhrFlags::FLAG_PNEXT != Win32SurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<Win32SurfaceCreateFlagsKhr> {
        if self.set_mask & Win32SurfaceCreateInfoKhrFlags::FLAG_FLAGS != Win32SurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( Win32SurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("Win32SurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_hinstance<'a>(&'a self) -> Option<HINSTANCE> {
        if self.set_mask & Win32SurfaceCreateInfoKhrFlags::FLAG_HINSTANCE != Win32SurfaceCreateInfoKhrFlags::FLAG_HINSTANCE { return None }
        Some( self.raw.hinstance.into() )
    }

    pub fn get_hwnd<'a>(&'a self) -> Option<HWND> {
        if self.set_mask & Win32SurfaceCreateInfoKhrFlags::FLAG_HWND != Win32SurfaceCreateInfoKhrFlags::FLAG_HWND { return None }
        Some( self.raw.hwnd.into() )
    }

    pub fn build(self) -> Win32SurfaceCreateInfoKhr<'b> {
        Win32SurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXlibSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XlibSurfaceCreateInfoKhr<'s> {
    raw: vks::VkXlibSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> XlibSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        XlibSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXlibSurfaceCreateInfoKHR) -> XlibSurfaceCreateInfoKhr<'s> {
        XlibSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> XlibSurfaceCreateFlagsKhr {
        XlibSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XlibSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn dpy<'a>(&'a self) -> *mut Display {
        self.raw.dpy
    }

    pub fn window<'a>(&'a self) -> Window {
        self.raw.window.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: XlibSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_dpy<'m>(&mut self, dpy: *mut Display) {
        self.raw.dpy = dpy;
    }

    pub unsafe fn set_window<'m>(&mut self, window: Window) {
        self.raw.window = window.into();
    }

    pub fn as_raw(&self) -> &vks::VkXlibSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<XlibSurfaceCreateInfoKhr<'s>> for vks::VkXlibSurfaceCreateInfoKHR {
    fn from(f: XlibSurfaceCreateInfoKhr<'s>) -> vks::VkXlibSurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkXlibSurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct XlibSurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DPY			 = 0b1000;
        const FLAG_WINDOW			 = 0b10000;
    }
}


/// A builder for `VkXlibSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct XlibSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkXlibSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: XlibSurfaceCreateInfoKhrFlags,
}

impl<'b> XlibSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        XlibSurfaceCreateInfoKhrBuilder {
            raw: vks::VkXlibSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: XlibSurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= XlibSurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: XlibSurfaceCreateFlagsKhr) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= XlibSurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn dpy<'m>(mut self, dpy: *mut Display) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.dpy = dpy;
        self.set_mask |= XlibSurfaceCreateInfoKhrFlags::FLAG_DPY;
        self
    }

    pub unsafe fn window<'m>(mut self, window: Window) -> XlibSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window.into();
        self.set_mask |= XlibSurfaceCreateInfoKhrFlags::FLAG_WINDOW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & XlibSurfaceCreateInfoKhrFlags::FLAG_PNEXT != XlibSurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<XlibSurfaceCreateFlagsKhr> {
        if self.set_mask & XlibSurfaceCreateInfoKhrFlags::FLAG_FLAGS != XlibSurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( XlibSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XlibSurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_dpy<'a>(&'a self) -> Option<*mut Display> {
        if self.set_mask & XlibSurfaceCreateInfoKhrFlags::FLAG_DPY != XlibSurfaceCreateInfoKhrFlags::FLAG_DPY { return None }
        Some( self.raw.dpy )
    }

    pub fn get_window<'a>(&'a self) -> Option<Window> {
        if self.set_mask & XlibSurfaceCreateInfoKhrFlags::FLAG_WINDOW != XlibSurfaceCreateInfoKhrFlags::FLAG_WINDOW { return None }
        Some( self.raw.window.into() )
    }

    pub fn build(self) -> XlibSurfaceCreateInfoKhr<'b> {
        XlibSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXcbSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XcbSurfaceCreateInfoKhr<'s> {
    raw: vks::VkXcbSurfaceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> XcbSurfaceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        XcbSurfaceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXcbSurfaceCreateInfoKHR) -> XcbSurfaceCreateInfoKhr<'s> {
        XcbSurfaceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> XcbSurfaceCreateFlagsKhr {
        XcbSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XcbSurfaceCreateInfoKhr::flags: error converting flags")
    }

    pub fn connection<'a>(&'a self) -> *mut xcb_connection_t {
        self.raw.connection
    }

    pub fn window<'a>(&'a self) -> xcb_window_t {
        self.raw.window.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: XcbSurfaceCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_connection<'m>(&mut self, connection: *mut xcb_connection_t) {
        self.raw.connection = connection;
    }

    pub unsafe fn set_window<'m>(&mut self, window: xcb_window_t) {
        self.raw.window = window.into();
    }

    pub fn as_raw(&self) -> &vks::VkXcbSurfaceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<XcbSurfaceCreateInfoKhr<'s>> for vks::VkXcbSurfaceCreateInfoKHR {
    fn from(f: XcbSurfaceCreateInfoKhr<'s>) -> vks::VkXcbSurfaceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkXcbSurfaceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct XcbSurfaceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_CONNECTION			 = 0b1000;
        const FLAG_WINDOW			 = 0b10000;
    }
}


/// A builder for `VkXcbSurfaceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct XcbSurfaceCreateInfoKhrBuilder<'b> {
    raw: vks::VkXcbSurfaceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: XcbSurfaceCreateInfoKhrFlags,
}

impl<'b> XcbSurfaceCreateInfoKhrBuilder<'b> {
    pub fn new() -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        XcbSurfaceCreateInfoKhrBuilder {
            raw: vks::VkXcbSurfaceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: XcbSurfaceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= XcbSurfaceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: XcbSurfaceCreateFlagsKhr) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= XcbSurfaceCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn connection<'m>(mut self, connection: *mut xcb_connection_t) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.connection = connection;
        self.set_mask |= XcbSurfaceCreateInfoKhrFlags::FLAG_CONNECTION;
        self
    }

    pub unsafe fn window<'m>(mut self, window: xcb_window_t) -> XcbSurfaceCreateInfoKhrBuilder<'b> {
        self.raw.window = window.into();
        self.set_mask |= XcbSurfaceCreateInfoKhrFlags::FLAG_WINDOW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & XcbSurfaceCreateInfoKhrFlags::FLAG_PNEXT != XcbSurfaceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<XcbSurfaceCreateFlagsKhr> {
        if self.set_mask & XcbSurfaceCreateInfoKhrFlags::FLAG_FLAGS != XcbSurfaceCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( XcbSurfaceCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("XcbSurfaceCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_connection<'a>(&'a self) -> Option<*mut xcb_connection_t> {
        if self.set_mask & XcbSurfaceCreateInfoKhrFlags::FLAG_CONNECTION != XcbSurfaceCreateInfoKhrFlags::FLAG_CONNECTION { return None }
        Some( self.raw.connection )
    }

    pub fn get_window<'a>(&'a self) -> Option<xcb_window_t> {
        if self.set_mask & XcbSurfaceCreateInfoKhrFlags::FLAG_WINDOW != XcbSurfaceCreateInfoKhrFlags::FLAG_WINDOW { return None }
        Some( self.raw.window.into() )
    }

    pub fn build(self) -> XcbSurfaceCreateInfoKhr<'b> {
        XcbSurfaceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceFormatKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceFormatKhr {
    raw: vks::VkSurfaceFormatKHR,
}

impl SurfaceFormatKhr {
    pub fn builder() -> SurfaceFormatKhrBuilder {
        SurfaceFormatKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceFormatKHR) -> SurfaceFormatKhr {
        SurfaceFormatKhr { raw, }
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.colorSpace.into()
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_color_space<'m>(&mut self, color_space: ColorSpaceKhr) {
        self.raw.colorSpace = color_space.into();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceFormatKHR {
        &self.raw
    }
}

impl From<SurfaceFormatKhr> for vks::VkSurfaceFormatKHR {
    fn from(f: SurfaceFormatKhr) -> vks::VkSurfaceFormatKHR {
        f.raw
    }
}


/// Bitflags for `VkSurfaceFormatKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SurfaceFormatKhrFlags: u32 {
        const FLAG_FORMAT			 = 0b1;
        const FLAG_COLORSPACE			 = 0b10;
    }
}


/// A builder for `VkSurfaceFormatKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceFormatKhrBuilder {
    raw: vks::VkSurfaceFormatKHR,
    set_mask: SurfaceFormatKhrFlags,
}

impl SurfaceFormatKhrBuilder {
    pub fn new() -> SurfaceFormatKhrBuilder {
        SurfaceFormatKhrBuilder {
            raw: vks::VkSurfaceFormatKHR::default(),
            set_mask: SurfaceFormatKhrFlags::default(),
        }
    }

    pub fn format<'m>(mut self, format: Format) -> SurfaceFormatKhrBuilder {
        self.raw.format = format.into();
        self.set_mask |= SurfaceFormatKhrFlags::FLAG_FORMAT;
        self
    }

    pub fn color_space<'m>(mut self, color_space: ColorSpaceKhr) -> SurfaceFormatKhrBuilder {
        self.raw.colorSpace = color_space.into();
        self.set_mask |= SurfaceFormatKhrFlags::FLAG_COLORSPACE;
        self
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & SurfaceFormatKhrFlags::FLAG_FORMAT != SurfaceFormatKhrFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_color_space<'a>(&'a self) -> Option<ColorSpaceKhr> {
        if self.set_mask & SurfaceFormatKhrFlags::FLAG_COLORSPACE != SurfaceFormatKhrFlags::FLAG_COLORSPACE { return None }
        Some( self.raw.colorSpace.into() )
    }

    pub fn build(self) -> SurfaceFormatKhr {
        SurfaceFormatKhr {
            raw: self.raw,
        }
    }
}


/// A `VkSwapchainCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SwapchainCreateInfoKhr<'s> {
    raw: vks::VkSwapchainCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SwapchainCreateInfoKhr<'s> {
    pub fn builder<'b>() -> SwapchainCreateInfoKhrBuilder<'b> {
        SwapchainCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSwapchainCreateInfoKHR) -> SwapchainCreateInfoKhr<'s> {
        SwapchainCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> SwapchainCreateFlagsKhr {
        SwapchainCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("SwapchainCreateInfoKhr::flags: error converting flags")
    }

    pub fn surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn image_format<'a>(&'a self) -> Format {
        self.raw.imageFormat.into()
    }

    pub fn image_color_space<'a>(&'a self) -> ColorSpaceKhr {
        self.raw.imageColorSpace.into()
    }

    pub fn image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn image_array_layers<'a>(&'a self) -> u32 {
        self.raw.imageArrayLayers.into()
    }

    pub fn image_usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.imageUsage)
            .expect("SwapchainCreateInfoKhr::image_usage: error converting flags")
    }

    pub fn image_sharing_mode<'a>(&'a self) -> SharingMode {
        self.raw.imageSharingMode.into()
    }

    pub fn queue_family_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) }
    }

    pub fn pre_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.preTransform)
            .expect("SwapchainCreateInfoKhr::pre_transform: error converting flags")
    }

    pub fn composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.compositeAlpha)
            .expect("SwapchainCreateInfoKhr::composite_alpha: error converting flags")
    }

    pub fn present_mode<'a>(&'a self) -> PresentModeKhr {
        self.raw.presentMode.into()
    }

    pub fn clipped<'a>(&'a self) -> bool {
        self.raw.clipped != 0
    }

    pub fn old_swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.oldSwapchain
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: SwapchainCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_surface<'m, H>(&mut self, surface: H)
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_image_format<'m>(&mut self, image_format: Format) {
        self.raw.imageFormat = image_format.into();
    }

    pub fn set_image_color_space<'m>(&mut self, image_color_space: ColorSpaceKhr) {
        self.raw.imageColorSpace = image_color_space.into();
    }

    pub fn set_image_extent<'m>(&mut self, image_extent: Extent2d) {
        self.raw.imageExtent = image_extent.raw;
    }

    pub fn set_image_array_layers<'m>(&mut self, image_array_layers: u32) {
        self.raw.imageArrayLayers = image_array_layers.into();
    }

    pub fn set_image_usage<'m>(&mut self, image_usage: ImageUsageFlags) {
        self.raw.imageUsage = image_usage.bits();
    }

    pub fn set_image_sharing_mode<'m>(&mut self, image_sharing_mode: SharingMode) {
        self.raw.imageSharingMode = image_sharing_mode.into();
    }

    pub fn set_queue_family_indices<'m, 'a>(&mut self, queue_family_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `SwapchainCreateInfoKhr::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_pre_transform<'m>(&mut self, pre_transform: SurfaceTransformFlagsKhr) {
        self.raw.preTransform = pre_transform.bits();
    }

    pub fn set_composite_alpha<'m>(&mut self, composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.compositeAlpha = composite_alpha.bits();
    }

    pub fn set_present_mode<'m>(&mut self, present_mode: PresentModeKhr) {
        self.raw.presentMode = present_mode.into();
    }

    pub fn set_clipped<'m>(&mut self, clipped: bool) {
        self.raw.clipped = clipped as u32;
    }

    pub fn set_old_swapchain<'m, H>(&mut self, old_swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.oldSwapchain = old_swapchain.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkSwapchainCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<SwapchainCreateInfoKhr<'s>> for vks::VkSwapchainCreateInfoKHR {
    fn from(f: SwapchainCreateInfoKhr<'s>) -> vks::VkSwapchainCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkSwapchainCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SwapchainCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_SURFACE			 = 0b1000;
        const FLAG_MINIMAGECOUNT			 = 0b10000;
        const FLAG_IMAGEFORMAT			 = 0b100000;
        const FLAG_IMAGECOLORSPACE			 = 0b1000000;
        const FLAG_IMAGEEXTENT			 = 0b10000000;
        const FLAG_IMAGEARRAYLAYERS			 = 0b100000000;
        const FLAG_IMAGEUSAGE			 = 0b1000000000;
        const FLAG_IMAGESHARINGMODE			 = 0b10000000000;
        const FLAG_QUEUEFAMILYINDEXCOUNT			 = 0b100000000000;
        const FLAG_PQUEUEFAMILYINDICES			 = 0b1000000000000;
        const FLAG_PRETRANSFORM			 = 0b10000000000000;
        const FLAG_COMPOSITEALPHA			 = 0b100000000000000;
        const FLAG_PRESENTMODE			 = 0b1000000000000000;
        const FLAG_CLIPPED			 = 0b10000000000000000;
        const FLAG_OLDSWAPCHAIN			 = 0b100000000000000000;
    }
}


/// A builder for `VkSwapchainCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SwapchainCreateInfoKhrBuilder<'b> {
    raw: vks::VkSwapchainCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SwapchainCreateInfoKhrFlags,
}

impl<'b> SwapchainCreateInfoKhrBuilder<'b> {
    pub fn new() -> SwapchainCreateInfoKhrBuilder<'b> {
        SwapchainCreateInfoKhrBuilder {
            raw: vks::VkSwapchainCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: SwapchainCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: SwapchainCreateFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn surface<'m, H>(mut self, surface: H) -> SwapchainCreateInfoKhrBuilder<'b>
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_SURFACE;
        self
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.minImageCount = min_image_count.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_MINIMAGECOUNT;
        self
    }

    pub fn image_format<'m>(mut self, image_format: Format) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageFormat = image_format.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGEFORMAT;
        self
    }

    pub fn image_color_space<'m>(mut self, image_color_space: ColorSpaceKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageColorSpace = image_color_space.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGECOLORSPACE;
        self
    }

    pub fn image_extent<'m>(mut self, image_extent: Extent2d) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageExtent = image_extent.raw;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGEEXTENT;
        self
    }

    pub fn image_array_layers<'m>(mut self, image_array_layers: u32) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageArrayLayers = image_array_layers.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGEARRAYLAYERS;
        self
    }

    pub fn image_usage<'m>(mut self, image_usage: ImageUsageFlags) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageUsage = image_usage.bits();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGEUSAGE;
        self
    }

    pub fn image_sharing_mode<'m>(mut self, image_sharing_mode: SharingMode) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.imageSharingMode = image_sharing_mode.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_IMAGESHARINGMODE;
        self
    }

    pub fn queue_family_indices<'m, 'a>(mut self, queue_family_indices: &'a [u32]) -> SwapchainCreateInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.queueFamilyIndexCount == 0 || self.raw.queueFamilyIndexCount == queue_family_indices.len() as _, 
            "count inconsistency found when specifying `SwapchainCreateInfoKhr::queue_family_indices`.");
        self.raw.queueFamilyIndexCount = queue_family_indices.len() as _;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_QUEUEFAMILYINDEXCOUNT;
        self.raw.pQueueFamilyIndices = queue_family_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_PQUEUEFAMILYINDICES;
        self
    }

    pub fn pre_transform<'m>(mut self, pre_transform: SurfaceTransformFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.preTransform = pre_transform.bits();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_PRETRANSFORM;
        self
    }

    pub fn composite_alpha<'m>(mut self, composite_alpha: CompositeAlphaFlagsKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.compositeAlpha = composite_alpha.bits();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_COMPOSITEALPHA;
        self
    }

    pub fn present_mode<'m>(mut self, present_mode: PresentModeKhr) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.presentMode = present_mode.into();
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_PRESENTMODE;
        self
    }

    pub fn clipped<'m>(mut self, clipped: bool) -> SwapchainCreateInfoKhrBuilder<'b> {
        self.raw.clipped = clipped as u32;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_CLIPPED;
        self
    }

    pub fn old_swapchain<'m, H>(mut self, old_swapchain: H) -> SwapchainCreateInfoKhrBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.oldSwapchain = old_swapchain.handle().0;
        self.set_mask |= SwapchainCreateInfoKhrFlags::FLAG_OLDSWAPCHAIN;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_PNEXT != SwapchainCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SwapchainCreateFlagsKhr> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_FLAGS != SwapchainCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( SwapchainCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("SwapchainCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_surface<'a>(&'a self) -> Option<vks::VkSurfaceKHR> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_SURFACE != SwapchainCreateInfoKhrFlags::FLAG_SURFACE { return None }
        Some( self.raw.surface )
    }

    pub fn get_min_image_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_MINIMAGECOUNT != SwapchainCreateInfoKhrFlags::FLAG_MINIMAGECOUNT { return None }
        Some( self.raw.minImageCount.into() )
    }

    pub fn get_image_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGEFORMAT != SwapchainCreateInfoKhrFlags::FLAG_IMAGEFORMAT { return None }
        Some( self.raw.imageFormat.into() )
    }

    pub fn get_image_color_space<'a>(&'a self) -> Option<ColorSpaceKhr> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGECOLORSPACE != SwapchainCreateInfoKhrFlags::FLAG_IMAGECOLORSPACE { return None }
        Some( self.raw.imageColorSpace.into() )
    }

    pub fn get_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGEEXTENT != SwapchainCreateInfoKhrFlags::FLAG_IMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.imageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGEEXTENT != SwapchainCreateInfoKhrFlags::FLAG_IMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.imageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_image_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGEARRAYLAYERS != SwapchainCreateInfoKhrFlags::FLAG_IMAGEARRAYLAYERS { return None }
        Some( self.raw.imageArrayLayers.into() )
    }

    pub fn get_image_usage<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGEUSAGE != SwapchainCreateInfoKhrFlags::FLAG_IMAGEUSAGE { return None }
        Some( ImageUsageFlags::from_bits(self.raw.imageUsage)
            .expect("SwapchainCreateInfoKhr::image_usage: error converting flags") )
    }

    pub fn get_image_sharing_mode<'a>(&'a self) -> Option<SharingMode> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_IMAGESHARINGMODE != SwapchainCreateInfoKhrFlags::FLAG_IMAGESHARINGMODE { return None }
        Some( self.raw.imageSharingMode.into() )
    }

    pub fn get_queue_family_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_PQUEUEFAMILYINDICES != SwapchainCreateInfoKhrFlags::FLAG_PQUEUEFAMILYINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pQueueFamilyIndices as *const _, self.raw.queueFamilyIndexCount as usize) } )
    }

    pub fn get_pre_transform<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_PRETRANSFORM != SwapchainCreateInfoKhrFlags::FLAG_PRETRANSFORM { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.preTransform)
            .expect("SwapchainCreateInfoKhr::pre_transform: error converting flags") )
    }

    pub fn get_composite_alpha<'a>(&'a self) -> Option<CompositeAlphaFlagsKhr> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_COMPOSITEALPHA != SwapchainCreateInfoKhrFlags::FLAG_COMPOSITEALPHA { return None }
        Some( CompositeAlphaFlagsKhr::from_bits(self.raw.compositeAlpha)
            .expect("SwapchainCreateInfoKhr::composite_alpha: error converting flags") )
    }

    pub fn get_present_mode<'a>(&'a self) -> Option<PresentModeKhr> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_PRESENTMODE != SwapchainCreateInfoKhrFlags::FLAG_PRESENTMODE { return None }
        Some( self.raw.presentMode.into() )
    }

    pub fn get_clipped<'a>(&'a self) -> Option<bool> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_CLIPPED != SwapchainCreateInfoKhrFlags::FLAG_CLIPPED { return None }
        Some( self.raw.clipped != 0 )
    }

    pub fn get_old_swapchain<'a>(&'a self) -> Option<vks::VkSwapchainKHR> {
        if self.set_mask & SwapchainCreateInfoKhrFlags::FLAG_OLDSWAPCHAIN != SwapchainCreateInfoKhrFlags::FLAG_OLDSWAPCHAIN { return None }
        Some( self.raw.oldSwapchain )
    }

    pub fn build(self) -> SwapchainCreateInfoKhr<'b> {
        SwapchainCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentInfoKhr<'s> {
    raw: vks::VkPresentInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentInfoKhr<'s> {
    pub fn builder<'b>() -> PresentInfoKhrBuilder<'b> {
        PresentInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentInfoKHR) -> PresentInfoKhr<'s> {
        PresentInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphores<'a>(&'a self) -> &'a [vks::VkSemaphore] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn swapchains<'a>(&'a self) -> &'a [vks::VkSwapchainKHR] {
        unsafe { slice::from_raw_parts(self.raw.pSwapchains as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn image_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pImageIndices as *const _, self.raw.swapchainCount as usize) }
    }

    pub fn results<'a>(&'a self) -> &'a [CallResult] {
        unsafe { slice::from_raw_parts(self.raw.pResults as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphores<'m, 'a>(&mut self, wait_semaphores: &'a [SemaphoreHandle])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
    }

    pub fn set_swapchains<'m, 'a>(&mut self, swapchains: &'a [SwapchainKhrHandle])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == swapchains.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::swapchains`.");
        self.raw.swapchainCount = swapchains.len() as _;
        self.raw.pSwapchains = swapchains.as_ptr() as *const vks::VkSwapchainKHR;
    }

    pub fn set_image_indices<'m, 'a>(&mut self, image_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == image_indices.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::image_indices`.");
        self.raw.swapchainCount = image_indices.len() as _;
        self.raw.pImageIndices = image_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_results<'m, 'a>(&mut self, results: &'a mut [CallResult])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == results.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::results`.");
        self.raw.swapchainCount = results.len() as _;
        self.raw.pResults = results.as_mut_ptr() as *mut CallResult as *mut _;
    }

    pub fn as_raw(&self) -> &vks::VkPresentInfoKHR {
        &self.raw
    }
}

impl<'s> From<PresentInfoKhr<'s>> for vks::VkPresentInfoKHR {
    fn from(f: PresentInfoKhr<'s>) -> vks::VkPresentInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkPresentInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PresentInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_WAITSEMAPHORECOUNT			 = 0b100;
        const FLAG_PWAITSEMAPHORES			 = 0b1000;
        const FLAG_SWAPCHAINCOUNT			 = 0b10000;
        const FLAG_PSWAPCHAINS			 = 0b100000;
        const FLAG_PIMAGEINDICES			 = 0b1000000;
        const FLAG_PRESULTS			 = 0b10000000;
    }
}


/// A builder for `VkPresentInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentInfoKhrBuilder<'b> {
    raw: vks::VkPresentInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PresentInfoKhrFlags,
}

impl<'b> PresentInfoKhrBuilder<'b> {
    pub fn new() -> PresentInfoKhrBuilder<'b> {
        PresentInfoKhrBuilder {
            raw: vks::VkPresentInfoKHR::default(),
            _p: PhantomData,
            set_mask: PresentInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PresentInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn wait_semaphores<'m, 'a>(mut self, wait_semaphores: &'a [SemaphoreHandle]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphores.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::wait_semaphores`.");
        self.raw.waitSemaphoreCount = wait_semaphores.len() as _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_WAITSEMAPHORECOUNT;
        self.raw.pWaitSemaphores = wait_semaphores.as_ptr() as *const vks::VkSemaphore;
        self.set_mask |= PresentInfoKhrFlags::FLAG_PWAITSEMAPHORES;
        self
    }

    pub fn swapchains<'m, 'a>(mut self, swapchains: &'a [SwapchainKhrHandle]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == swapchains.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::swapchains`.");
        self.raw.swapchainCount = swapchains.len() as _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_SWAPCHAINCOUNT;
        self.raw.pSwapchains = swapchains.as_ptr() as *const vks::VkSwapchainKHR;
        self.set_mask |= PresentInfoKhrFlags::FLAG_PSWAPCHAINS;
        self
    }

    pub fn image_indices<'m, 'a>(mut self, image_indices: &'a [u32]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == image_indices.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::image_indices`.");
        self.raw.swapchainCount = image_indices.len() as _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_SWAPCHAINCOUNT;
        self.raw.pImageIndices = image_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_PIMAGEINDICES;
        self
    }

    pub fn results<'m, 'a>(mut self, results: &'a mut [CallResult]) -> PresentInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == results.len() as _, 
            "count inconsistency found when specifying `PresentInfoKhr::results`.");
        self.raw.swapchainCount = results.len() as _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_SWAPCHAINCOUNT;
        self.raw.pResults = results.as_mut_ptr() as *mut CallResult as *mut _;
        self.set_mask |= PresentInfoKhrFlags::FLAG_PRESULTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PresentInfoKhrFlags::FLAG_PNEXT != PresentInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_wait_semaphores<'a>(&'a self) -> Option<&'a [vks::VkSemaphore]> {
        if self.set_mask & PresentInfoKhrFlags::FLAG_PWAITSEMAPHORES != PresentInfoKhrFlags::FLAG_PWAITSEMAPHORES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pWaitSemaphores as *const _, self.raw.waitSemaphoreCount as usize) } )
    }

    pub fn get_swapchains<'a>(&'a self) -> Option<&'a [vks::VkSwapchainKHR]> {
        if self.set_mask & PresentInfoKhrFlags::FLAG_PSWAPCHAINS != PresentInfoKhrFlags::FLAG_PSWAPCHAINS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSwapchains as *const _, self.raw.swapchainCount as usize) } )
    }

    pub fn get_image_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & PresentInfoKhrFlags::FLAG_PIMAGEINDICES != PresentInfoKhrFlags::FLAG_PIMAGEINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pImageIndices as *const _, self.raw.swapchainCount as usize) } )
    }

    pub fn get_results<'a>(&'a self) -> Option<&'a [CallResult]> {
        if self.set_mask & PresentInfoKhrFlags::FLAG_PRESULTS != PresentInfoKhrFlags::FLAG_PRESULTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pResults as *const _, self.raw.swapchainCount as usize) } )
    }

    pub fn build(self) -> PresentInfoKhr<'b> {
        PresentInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugReportCallbackCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugReportCallbackCreateInfoExt<'s> {
    raw: vks::VkDebugReportCallbackCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugReportCallbackCreateInfoExt<'s> {
    pub fn builder<'b>() -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        DebugReportCallbackCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugReportCallbackCreateInfoEXT) -> DebugReportCallbackCreateInfoExt<'s> {
        DebugReportCallbackCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DebugReportFlagsExt {
        DebugReportFlagsExt::from_bits(self.raw.flags)
            .expect("DebugReportCallbackCreateInfoExt::flags: error converting flags")
    }

    pub fn pfn_callback<'a>(&'a self) -> PFN_vkDebugReportCallbackEXT {
        self.raw.pfnCallback.into()
    }

    pub fn user_data<'a>(&'a self) -> *mut c_void {
        self.raw.pUserData
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DebugReportFlagsExt) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_pfn_callback<'m>(&mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) {
        self.raw.pfnCallback = pfn_callback.into();
    }

    pub unsafe fn set_user_data<'m>(&mut self, user_data: *mut c_void) {
        self.raw.pUserData = user_data;
    }

    pub fn as_raw(&self) -> &vks::VkDebugReportCallbackCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugReportCallbackCreateInfoExt<'s>> for vks::VkDebugReportCallbackCreateInfoEXT {
    fn from(f: DebugReportCallbackCreateInfoExt<'s>) -> vks::VkDebugReportCallbackCreateInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDebugReportCallbackCreateInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DebugReportCallbackCreateInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PFNCALLBACK			 = 0b1000;
        const FLAG_PUSERDATA			 = 0b10000;
    }
}


/// A builder for `VkDebugReportCallbackCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugReportCallbackCreateInfoExtBuilder<'b> {
    raw: vks::VkDebugReportCallbackCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DebugReportCallbackCreateInfoExtFlags,
}

impl<'b> DebugReportCallbackCreateInfoExtBuilder<'b> {
    pub fn new() -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        DebugReportCallbackCreateInfoExtBuilder {
            raw: vks::VkDebugReportCallbackCreateInfoEXT::default(),
            _p: PhantomData,
            set_mask: DebugReportCallbackCreateInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DebugReportCallbackCreateInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DebugReportFlagsExt) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DebugReportCallbackCreateInfoExtFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn pfn_callback<'m>(mut self, pfn_callback: PFN_vkDebugReportCallbackEXT) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pfnCallback = pfn_callback.into();
        self.set_mask |= DebugReportCallbackCreateInfoExtFlags::FLAG_PFNCALLBACK;
        self
    }

    pub unsafe fn user_data<'m>(mut self, user_data: *mut c_void) -> DebugReportCallbackCreateInfoExtBuilder<'b> {
        self.raw.pUserData = user_data;
        self.set_mask |= DebugReportCallbackCreateInfoExtFlags::FLAG_PUSERDATA;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DebugReportCallbackCreateInfoExtFlags::FLAG_PNEXT != DebugReportCallbackCreateInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DebugReportFlagsExt> {
        if self.set_mask & DebugReportCallbackCreateInfoExtFlags::FLAG_FLAGS != DebugReportCallbackCreateInfoExtFlags::FLAG_FLAGS { return None }
        Some( DebugReportFlagsExt::from_bits(self.raw.flags)
            .expect("DebugReportCallbackCreateInfoExt::flags: error converting flags") )
    }

    pub fn get_pfn_callback<'a>(&'a self) -> Option<PFN_vkDebugReportCallbackEXT> {
        if self.set_mask & DebugReportCallbackCreateInfoExtFlags::FLAG_PFNCALLBACK != DebugReportCallbackCreateInfoExtFlags::FLAG_PFNCALLBACK { return None }
        Some( self.raw.pfnCallback.into() )
    }

    pub fn get_user_data<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & DebugReportCallbackCreateInfoExtFlags::FLAG_PUSERDATA != DebugReportCallbackCreateInfoExtFlags::FLAG_PUSERDATA { return None }
        Some( self.raw.pUserData )
    }

    pub fn build(self) -> DebugReportCallbackCreateInfoExt<'b> {
        DebugReportCallbackCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkValidationFlagsEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ValidationFlagsExt<'s> {
    raw: vks::VkValidationFlagsEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> ValidationFlagsExt<'s> {
    pub fn builder<'b>() -> ValidationFlagsExtBuilder<'b> {
        ValidationFlagsExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkValidationFlagsEXT) -> ValidationFlagsExt<'s> {
        ValidationFlagsExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn disabled_validation_checks<'a>(&'a self) -> &'a [ValidationCheckExt] {
        unsafe { slice::from_raw_parts(self.raw.pDisabledValidationChecks as *const _, self.raw.disabledValidationCheckCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_disabled_validation_checks<'m, 'a>(&mut self, disabled_validation_checks: &'a mut [ValidationCheckExt])
            where 'a: 's {
        assert!(self.raw.disabledValidationCheckCount == 0 || self.raw.disabledValidationCheckCount == disabled_validation_checks.len() as _, 
            "count inconsistency found when specifying `ValidationFlagsExt::disabled_validation_checks`.");
        self.raw.disabledValidationCheckCount = disabled_validation_checks.len() as _;
        self.raw.pDisabledValidationChecks = disabled_validation_checks.as_mut_ptr() as *mut ValidationCheckExt as *mut _;
    }

    pub fn as_raw(&self) -> &vks::VkValidationFlagsEXT {
        &self.raw
    }
}

impl<'s> From<ValidationFlagsExt<'s>> for vks::VkValidationFlagsEXT {
    fn from(f: ValidationFlagsExt<'s>) -> vks::VkValidationFlagsEXT {
        f.raw
    }
}


/// Bitflags for `VkValidationFlagsEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ValidationFlagsExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DISABLEDVALIDATIONCHECKCOUNT			 = 0b100;
        const FLAG_PDISABLEDVALIDATIONCHECKS			 = 0b1000;
    }
}


/// A builder for `VkValidationFlagsEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ValidationFlagsExtBuilder<'b> {
    raw: vks::VkValidationFlagsEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: ValidationFlagsExtFlags,
}

impl<'b> ValidationFlagsExtBuilder<'b> {
    pub fn new() -> ValidationFlagsExtBuilder<'b> {
        ValidationFlagsExtBuilder {
            raw: vks::VkValidationFlagsEXT::default(),
            _p: PhantomData,
            set_mask: ValidationFlagsExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ValidationFlagsExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ValidationFlagsExtFlags::FLAG_PNEXT;
        self
    }

    pub fn disabled_validation_checks<'m, 'a>(mut self, disabled_validation_checks: &'a mut [ValidationCheckExt]) -> ValidationFlagsExtBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.disabledValidationCheckCount == 0 || self.raw.disabledValidationCheckCount == disabled_validation_checks.len() as _, 
            "count inconsistency found when specifying `ValidationFlagsExt::disabled_validation_checks`.");
        self.raw.disabledValidationCheckCount = disabled_validation_checks.len() as _;
        self.set_mask |= ValidationFlagsExtFlags::FLAG_DISABLEDVALIDATIONCHECKCOUNT;
        self.raw.pDisabledValidationChecks = disabled_validation_checks.as_mut_ptr() as *mut ValidationCheckExt as *mut _;
        self.set_mask |= ValidationFlagsExtFlags::FLAG_PDISABLEDVALIDATIONCHECKS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ValidationFlagsExtFlags::FLAG_PNEXT != ValidationFlagsExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_disabled_validation_checks<'a>(&'a self) -> Option<&'a [ValidationCheckExt]> {
        if self.set_mask & ValidationFlagsExtFlags::FLAG_PDISABLEDVALIDATIONCHECKS != ValidationFlagsExtFlags::FLAG_PDISABLEDVALIDATIONCHECKS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pDisabledValidationChecks as *const _, self.raw.disabledValidationCheckCount as usize) } )
    }

    pub fn build(self) -> ValidationFlagsExt<'b> {
        ValidationFlagsExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineRasterizationStateRasterizationOrderAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineRasterizationStateRasterizationOrderAmd<'s> {
    raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineRasterizationStateRasterizationOrderAmd<'s> {
    pub fn builder<'b>() -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        PipelineRasterizationStateRasterizationOrderAmdBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD) -> PipelineRasterizationStateRasterizationOrderAmd<'s> {
        PipelineRasterizationStateRasterizationOrderAmd { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn rasterization_order<'a>(&'a self) -> RasterizationOrderAmd {
        self.raw.rasterizationOrder.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_rasterization_order<'m>(&mut self, rasterization_order: RasterizationOrderAmd) {
        self.raw.rasterizationOrder = rasterization_order.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineRasterizationStateRasterizationOrderAMD {
        &self.raw
    }
}

impl<'s> From<PipelineRasterizationStateRasterizationOrderAmd<'s>> for vks::VkPipelineRasterizationStateRasterizationOrderAMD {
    fn from(f: PipelineRasterizationStateRasterizationOrderAmd<'s>) -> vks::VkPipelineRasterizationStateRasterizationOrderAMD {
        f.raw
    }
}


/// Bitflags for `VkPipelineRasterizationStateRasterizationOrderAMD`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineRasterizationStateRasterizationOrderAmdFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_RASTERIZATIONORDER			 = 0b100;
    }
}


/// A builder for `VkPipelineRasterizationStateRasterizationOrderAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
    raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineRasterizationStateRasterizationOrderAmdFlags,
}

impl<'b> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
    pub fn new() -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        PipelineRasterizationStateRasterizationOrderAmdBuilder {
            raw: vks::VkPipelineRasterizationStateRasterizationOrderAMD::default(),
            _p: PhantomData,
            set_mask: PipelineRasterizationStateRasterizationOrderAmdFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_PNEXT;
        self
    }

    pub fn rasterization_order<'m>(mut self, rasterization_order: RasterizationOrderAmd) -> PipelineRasterizationStateRasterizationOrderAmdBuilder<'b> {
        self.raw.rasterizationOrder = rasterization_order.into();
        self.set_mask |= PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_RASTERIZATIONORDER;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_PNEXT != PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_rasterization_order<'a>(&'a self) -> Option<RasterizationOrderAmd> {
        if self.set_mask & PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_RASTERIZATIONORDER != PipelineRasterizationStateRasterizationOrderAmdFlags::FLAG_RASTERIZATIONORDER { return None }
        Some( self.raw.rasterizationOrder.into() )
    }

    pub fn build(self) -> PipelineRasterizationStateRasterizationOrderAmd<'b> {
        PipelineRasterizationStateRasterizationOrderAmd {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerObjectNameInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerObjectNameInfoExt<'s> {
    raw: vks::VkDebugMarkerObjectNameInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerObjectNameInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        DebugMarkerObjectNameInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerObjectNameInfoEXT) -> DebugMarkerObjectNameInfoExt<'s> {
        DebugMarkerObjectNameInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn object_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pObjectName) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_type<'m>(&mut self, object_type: DebugReportObjectTypeExt) {
        self.raw.objectType = object_type.into();
    }

    pub fn set_object<'m>(&mut self, object: u64) {
        self.raw.object = object.into();
    }

    pub fn set_object_name<'m, 'a>(&mut self, object_name: &'a CStr)
            where 'a: 's {
        self.raw.pObjectName = object_name.as_ptr();
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerObjectNameInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerObjectNameInfoExt<'s>> for vks::VkDebugMarkerObjectNameInfoEXT {
    fn from(f: DebugMarkerObjectNameInfoExt<'s>) -> vks::VkDebugMarkerObjectNameInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDebugMarkerObjectNameInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DebugMarkerObjectNameInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_OBJECTTYPE			 = 0b100;
        const FLAG_OBJECT			 = 0b1000;
        const FLAG_POBJECTNAME			 = 0b10000;
    }
}


/// A builder for `VkDebugMarkerObjectNameInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerObjectNameInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerObjectNameInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DebugMarkerObjectNameInfoExtFlags,
}

impl<'b> DebugMarkerObjectNameInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        DebugMarkerObjectNameInfoExtBuilder {
            raw: vks::VkDebugMarkerObjectNameInfoEXT::default(),
            _p: PhantomData,
            set_mask: DebugMarkerObjectNameInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DebugMarkerObjectNameInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn object_type<'m>(mut self, object_type: DebugReportObjectTypeExt) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.objectType = object_type.into();
        self.set_mask |= DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECTTYPE;
        self
    }

    pub fn object<'m>(mut self, object: u64) -> DebugMarkerObjectNameInfoExtBuilder<'b> {
        self.raw.object = object.into();
        self.set_mask |= DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECT;
        self
    }

    pub fn object_name<'m, 'a>(mut self, object_name: &'a CStr) -> DebugMarkerObjectNameInfoExtBuilder<'b>
            where 'a: 'b {
        self.raw.pObjectName = object_name.as_ptr();
        self.set_mask |= DebugMarkerObjectNameInfoExtFlags::FLAG_POBJECTNAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DebugMarkerObjectNameInfoExtFlags::FLAG_PNEXT != DebugMarkerObjectNameInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_object_type<'a>(&'a self) -> Option<DebugReportObjectTypeExt> {
        if self.set_mask & DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECTTYPE != DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECTTYPE { return None }
        Some( self.raw.objectType.into() )
    }

    pub fn get_object<'a>(&'a self) -> Option<u64> {
        if self.set_mask & DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECT != DebugMarkerObjectNameInfoExtFlags::FLAG_OBJECT { return None }
        Some( self.raw.object.into() )
    }

    pub fn get_object_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & DebugMarkerObjectNameInfoExtFlags::FLAG_POBJECTNAME != DebugMarkerObjectNameInfoExtFlags::FLAG_POBJECTNAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.pObjectName) } )
    }

    pub fn build(self) -> DebugMarkerObjectNameInfoExt<'b> {
        DebugMarkerObjectNameInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerObjectTagInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerObjectTagInfoExt<'s> {
    raw: vks::VkDebugMarkerObjectTagInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerObjectTagInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        DebugMarkerObjectTagInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerObjectTagInfoEXT) -> DebugMarkerObjectTagInfoExt<'s> {
        DebugMarkerObjectTagInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_type<'a>(&'a self) -> DebugReportObjectTypeExt {
        self.raw.objectType.into()
    }

    pub fn object<'a>(&'a self) -> u64 {
        self.raw.object.into()
    }

    pub fn tag_name<'a>(&'a self) -> u64 {
        self.raw.tagName.into()
    }

    pub fn tag_size<'a>(&'a self) -> usize {
        self.raw.tagSize.into()
    }

    pub fn tag<'a>(&'a self) -> *const c_void {
        self.raw.pTag
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_type<'m>(&mut self, object_type: DebugReportObjectTypeExt) {
        self.raw.objectType = object_type.into();
    }

    pub fn set_object<'m>(&mut self, object: u64) {
        self.raw.object = object.into();
    }

    pub fn set_tag_name<'m>(&mut self, tag_name: u64) {
        self.raw.tagName = tag_name.into();
    }

    pub fn set_tag_size<'m>(&mut self, tag_size: usize) {
        self.raw.tagSize = tag_size.into();
    }

    pub unsafe fn set_tag<'m>(&mut self, tag: *const c_void) {
        self.raw.pTag = tag;
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerObjectTagInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerObjectTagInfoExt<'s>> for vks::VkDebugMarkerObjectTagInfoEXT {
    fn from(f: DebugMarkerObjectTagInfoExt<'s>) -> vks::VkDebugMarkerObjectTagInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDebugMarkerObjectTagInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DebugMarkerObjectTagInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_OBJECTTYPE			 = 0b100;
        const FLAG_OBJECT			 = 0b1000;
        const FLAG_TAGNAME			 = 0b10000;
        const FLAG_TAGSIZE			 = 0b100000;
        const FLAG_PTAG			 = 0b1000000;
    }
}


/// A builder for `VkDebugMarkerObjectTagInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerObjectTagInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerObjectTagInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DebugMarkerObjectTagInfoExtFlags,
}

impl<'b> DebugMarkerObjectTagInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        DebugMarkerObjectTagInfoExtBuilder {
            raw: vks::VkDebugMarkerObjectTagInfoEXT::default(),
            _p: PhantomData,
            set_mask: DebugMarkerObjectTagInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn object_type<'m>(mut self, object_type: DebugReportObjectTypeExt) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.objectType = object_type.into();
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECTTYPE;
        self
    }

    pub fn object<'m>(mut self, object: u64) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.object = object.into();
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECT;
        self
    }

    pub fn tag_name<'m>(mut self, tag_name: u64) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.tagName = tag_name.into();
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_TAGNAME;
        self
    }

    pub fn tag_size<'m>(mut self, tag_size: usize) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.tagSize = tag_size.into();
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_TAGSIZE;
        self
    }

    pub unsafe fn tag<'m>(mut self, tag: *const c_void) -> DebugMarkerObjectTagInfoExtBuilder<'b> {
        self.raw.pTag = tag;
        self.set_mask |= DebugMarkerObjectTagInfoExtFlags::FLAG_PTAG;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_PNEXT != DebugMarkerObjectTagInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_object_type<'a>(&'a self) -> Option<DebugReportObjectTypeExt> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECTTYPE != DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECTTYPE { return None }
        Some( self.raw.objectType.into() )
    }

    pub fn get_object<'a>(&'a self) -> Option<u64> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECT != DebugMarkerObjectTagInfoExtFlags::FLAG_OBJECT { return None }
        Some( self.raw.object.into() )
    }

    pub fn get_tag_name<'a>(&'a self) -> Option<u64> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_TAGNAME != DebugMarkerObjectTagInfoExtFlags::FLAG_TAGNAME { return None }
        Some( self.raw.tagName.into() )
    }

    pub fn get_tag_size<'a>(&'a self) -> Option<usize> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_TAGSIZE != DebugMarkerObjectTagInfoExtFlags::FLAG_TAGSIZE { return None }
        Some( self.raw.tagSize.into() )
    }

    pub fn get_tag<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DebugMarkerObjectTagInfoExtFlags::FLAG_PTAG != DebugMarkerObjectTagInfoExtFlags::FLAG_PTAG { return None }
        Some( self.raw.pTag )
    }

    pub fn build(self) -> DebugMarkerObjectTagInfoExt<'b> {
        DebugMarkerObjectTagInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDebugMarkerMarkerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DebugMarkerMarkerInfoExt<'s> {
    raw: vks::VkDebugMarkerMarkerInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DebugMarkerMarkerInfoExt<'s> {
    pub fn builder<'b>() -> DebugMarkerMarkerInfoExtBuilder<'b> {
        DebugMarkerMarkerInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDebugMarkerMarkerInfoEXT) -> DebugMarkerMarkerInfoExt<'s> {
        DebugMarkerMarkerInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn marker_name<'a>(&'a self) -> &'a CStr {
        unsafe { CStr::from_ptr(self.raw.pMarkerName) }
    }

    pub fn color<'a>(&'a self) -> &[f32] {
        unsafe { slice::from_raw_parts(&self.raw.color as *const _, 4 as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_marker_name<'m, 'a>(&mut self, marker_name: &'a CStr)
            where 'a: 's {
        self.raw.pMarkerName = marker_name.as_ptr();
    }

    pub fn set_color<'m>(&mut self, color: [f32; 4]) {
        self.raw.color = color;
    }

    pub fn as_raw(&self) -> &vks::VkDebugMarkerMarkerInfoEXT {
        &self.raw
    }
}

impl<'s> From<DebugMarkerMarkerInfoExt<'s>> for vks::VkDebugMarkerMarkerInfoEXT {
    fn from(f: DebugMarkerMarkerInfoExt<'s>) -> vks::VkDebugMarkerMarkerInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDebugMarkerMarkerInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DebugMarkerMarkerInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PMARKERNAME			 = 0b100;
        const FLAG_COLOR			 = 0b1000;
    }
}


/// A builder for `VkDebugMarkerMarkerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DebugMarkerMarkerInfoExtBuilder<'b> {
    raw: vks::VkDebugMarkerMarkerInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DebugMarkerMarkerInfoExtFlags,
}

impl<'b> DebugMarkerMarkerInfoExtBuilder<'b> {
    pub fn new() -> DebugMarkerMarkerInfoExtBuilder<'b> {
        DebugMarkerMarkerInfoExtBuilder {
            raw: vks::VkDebugMarkerMarkerInfoEXT::default(),
            _p: PhantomData,
            set_mask: DebugMarkerMarkerInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DebugMarkerMarkerInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DebugMarkerMarkerInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn marker_name<'m, 'a>(mut self, marker_name: &'a CStr) -> DebugMarkerMarkerInfoExtBuilder<'b>
            where 'a: 'b {
        self.raw.pMarkerName = marker_name.as_ptr();
        self.set_mask |= DebugMarkerMarkerInfoExtFlags::FLAG_PMARKERNAME;
        self
    }

    pub fn color<'m>(mut self, color: [f32; 4]) -> DebugMarkerMarkerInfoExtBuilder<'b> {
        self.raw.color = color;
        self.set_mask |= DebugMarkerMarkerInfoExtFlags::FLAG_COLOR;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DebugMarkerMarkerInfoExtFlags::FLAG_PNEXT != DebugMarkerMarkerInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_marker_name<'a>(&'a self) -> Option<&'a CStr> {
        if self.set_mask & DebugMarkerMarkerInfoExtFlags::FLAG_PMARKERNAME != DebugMarkerMarkerInfoExtFlags::FLAG_PMARKERNAME { return None }
        Some( unsafe { CStr::from_ptr(self.raw.pMarkerName) } )
    }

    pub fn get_color<'a>(&'a self) -> Option<&[f32]> {
        if self.set_mask & DebugMarkerMarkerInfoExtFlags::FLAG_COLOR != DebugMarkerMarkerInfoExtFlags::FLAG_COLOR { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.color as *const _, 4 as usize) } )
    }

    pub fn build(self) -> DebugMarkerMarkerInfoExt<'b> {
        DebugMarkerMarkerInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationImageCreateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationImageCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationImageCreateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        DedicatedAllocationImageCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationImageCreateInfoNV) -> DedicatedAllocationImageCreateInfoNv<'s> {
        DedicatedAllocationImageCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dedicated_allocation<'m>(&mut self, dedicated_allocation: bool) {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationImageCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationImageCreateInfoNv<'s>> for vks::VkDedicatedAllocationImageCreateInfoNV {
    fn from(f: DedicatedAllocationImageCreateInfoNv<'s>) -> vks::VkDedicatedAllocationImageCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkDedicatedAllocationImageCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DedicatedAllocationImageCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DEDICATEDALLOCATION			 = 0b100;
    }
}


/// A builder for `VkDedicatedAllocationImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationImageCreateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationImageCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: DedicatedAllocationImageCreateInfoNvFlags,
}

impl<'b> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        DedicatedAllocationImageCreateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationImageCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: DedicatedAllocationImageCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DedicatedAllocationImageCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn dedicated_allocation<'m>(mut self, dedicated_allocation: bool) -> DedicatedAllocationImageCreateInfoNvBuilder<'b> {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
        self.set_mask |= DedicatedAllocationImageCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DedicatedAllocationImageCreateInfoNvFlags::FLAG_PNEXT != DedicatedAllocationImageCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_dedicated_allocation<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DedicatedAllocationImageCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION != DedicatedAllocationImageCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION { return None }
        Some( self.raw.dedicatedAllocation != 0 )
    }

    pub fn build(self) -> DedicatedAllocationImageCreateInfoNv<'b> {
        DedicatedAllocationImageCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationBufferCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationBufferCreateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationBufferCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationBufferCreateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        DedicatedAllocationBufferCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationBufferCreateInfoNV) -> DedicatedAllocationBufferCreateInfoNv<'s> {
        DedicatedAllocationBufferCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.dedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_dedicated_allocation<'m>(&mut self, dedicated_allocation: bool) {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationBufferCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationBufferCreateInfoNv<'s>> for vks::VkDedicatedAllocationBufferCreateInfoNV {
    fn from(f: DedicatedAllocationBufferCreateInfoNv<'s>) -> vks::VkDedicatedAllocationBufferCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkDedicatedAllocationBufferCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DedicatedAllocationBufferCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DEDICATEDALLOCATION			 = 0b100;
    }
}


/// A builder for `VkDedicatedAllocationBufferCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationBufferCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: DedicatedAllocationBufferCreateInfoNvFlags,
}

impl<'b> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        DedicatedAllocationBufferCreateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationBufferCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: DedicatedAllocationBufferCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DedicatedAllocationBufferCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn dedicated_allocation<'m>(mut self, dedicated_allocation: bool) -> DedicatedAllocationBufferCreateInfoNvBuilder<'b> {
        self.raw.dedicatedAllocation = dedicated_allocation as u32;
        self.set_mask |= DedicatedAllocationBufferCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DedicatedAllocationBufferCreateInfoNvFlags::FLAG_PNEXT != DedicatedAllocationBufferCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_dedicated_allocation<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DedicatedAllocationBufferCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION != DedicatedAllocationBufferCreateInfoNvFlags::FLAG_DEDICATEDALLOCATION { return None }
        Some( self.raw.dedicatedAllocation != 0 )
    }

    pub fn build(self) -> DedicatedAllocationBufferCreateInfoNv<'b> {
        DedicatedAllocationBufferCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDedicatedAllocationMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DedicatedAllocationMemoryAllocateInfoNv<'s> {
    raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> DedicatedAllocationMemoryAllocateInfoNv<'s> {
    pub fn builder<'b>() -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        DedicatedAllocationMemoryAllocateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV) -> DedicatedAllocationMemoryAllocateInfoNv<'s> {
        DedicatedAllocationMemoryAllocateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkDedicatedAllocationMemoryAllocateInfoNV {
        &self.raw
    }
}

impl<'s> From<DedicatedAllocationMemoryAllocateInfoNv<'s>> for vks::VkDedicatedAllocationMemoryAllocateInfoNV {
    fn from(f: DedicatedAllocationMemoryAllocateInfoNv<'s>) -> vks::VkDedicatedAllocationMemoryAllocateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkDedicatedAllocationMemoryAllocateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DedicatedAllocationMemoryAllocateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_IMAGE			 = 0b100;
        const FLAG_BUFFER			 = 0b1000;
    }
}


/// A builder for `VkDedicatedAllocationMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
    raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: DedicatedAllocationMemoryAllocateInfoNvFlags,
}

impl<'b> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
    pub fn new() -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        DedicatedAllocationMemoryAllocateInfoNvBuilder {
            raw: vks::VkDedicatedAllocationMemoryAllocateInfoNV::default(),
            _p: PhantomData,
            set_mask: DedicatedAllocationMemoryAllocateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_IMAGE;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> DedicatedAllocationMemoryAllocateInfoNvBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_BUFFER;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_PNEXT != DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_IMAGE != DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_BUFFER != DedicatedAllocationMemoryAllocateInfoNvFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn build(self) -> DedicatedAllocationMemoryAllocateInfoNv<'b> {
        DedicatedAllocationMemoryAllocateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalImageFormatPropertiesNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalImageFormatPropertiesNv {
    raw: vks::VkExternalImageFormatPropertiesNV,
}

impl ExternalImageFormatPropertiesNv {
    pub fn builder() -> ExternalImageFormatPropertiesNvBuilder {
        ExternalImageFormatPropertiesNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalImageFormatPropertiesNV) -> ExternalImageFormatPropertiesNv {
        ExternalImageFormatPropertiesNv { raw, }
    }

    pub fn image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
         unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub fn external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsNv {
        ExternalMemoryFeatureFlagsNv::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalImageFormatPropertiesNv::external_memory_features: error converting flags")
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::compatible_handle_types: error converting flags")
    }

    pub fn set_image_format_properties<'m>(&mut self, image_format_properties: ImageFormatProperties) {
        self.raw.imageFormatProperties = image_format_properties.raw;
    }

    pub fn set_external_memory_features<'m>(&mut self, external_memory_features: ExternalMemoryFeatureFlagsNv) {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalImageFormatPropertiesNV {
        &self.raw
    }
}

impl From<ExternalImageFormatPropertiesNv> for vks::VkExternalImageFormatPropertiesNV {
    fn from(f: ExternalImageFormatPropertiesNv) -> vks::VkExternalImageFormatPropertiesNV {
        f.raw
    }
}


/// Bitflags for `VkExternalImageFormatPropertiesNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalImageFormatPropertiesNvFlags: u32 {
        const FLAG_IMAGEFORMATPROPERTIES			 = 0b1;
        const FLAG_EXTERNALMEMORYFEATURES			 = 0b10;
        const FLAG_EXPORTFROMIMPORTEDHANDLETYPES			 = 0b100;
        const FLAG_COMPATIBLEHANDLETYPES			 = 0b1000;
    }
}


/// A builder for `VkExternalImageFormatPropertiesNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalImageFormatPropertiesNvBuilder {
    raw: vks::VkExternalImageFormatPropertiesNV,
    set_mask: ExternalImageFormatPropertiesNvFlags,
}

impl ExternalImageFormatPropertiesNvBuilder {
    pub fn new() -> ExternalImageFormatPropertiesNvBuilder {
        ExternalImageFormatPropertiesNvBuilder {
            raw: vks::VkExternalImageFormatPropertiesNV::default(),
            set_mask: ExternalImageFormatPropertiesNvFlags::default(),
        }
    }

    pub fn image_format_properties<'m>(mut self, image_format_properties: ImageFormatProperties) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.imageFormatProperties = image_format_properties.raw;
        self.set_mask |= ExternalImageFormatPropertiesNvFlags::FLAG_IMAGEFORMATPROPERTIES;
        self
    }

    pub fn external_memory_features<'m>(mut self, external_memory_features: ExternalMemoryFeatureFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
        self.set_mask |= ExternalImageFormatPropertiesNvFlags::FLAG_EXTERNALMEMORYFEATURES;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self.set_mask |= ExternalImageFormatPropertiesNvFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES;
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalImageFormatPropertiesNvBuilder {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self.set_mask |= ExternalImageFormatPropertiesNvFlags::FLAG_COMPATIBLEHANDLETYPES;
        self
    }

    pub fn get_image_format_properties<'a>(&'a self) -> Option<&'a ImageFormatProperties> {
        if self.set_mask & ExternalImageFormatPropertiesNvFlags::FLAG_IMAGEFORMATPROPERTIES != ExternalImageFormatPropertiesNvFlags::FLAG_IMAGEFORMATPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) } )
    }

    pub fn get_image_format_properties_mut<'a>(&'a mut self) -> Option<&'a mut ImageFormatProperties> {
        if self.set_mask & ExternalImageFormatPropertiesNvFlags::FLAG_IMAGEFORMATPROPERTIES != ExternalImageFormatPropertiesNvFlags::FLAG_IMAGEFORMATPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) } )
    }

    pub fn get_external_memory_features<'a>(&'a self) -> Option<ExternalMemoryFeatureFlagsNv> {
        if self.set_mask & ExternalImageFormatPropertiesNvFlags::FLAG_EXTERNALMEMORYFEATURES != ExternalImageFormatPropertiesNvFlags::FLAG_EXTERNALMEMORYFEATURES { return None }
        Some( ExternalMemoryFeatureFlagsNv::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalImageFormatPropertiesNv::external_memory_features: error converting flags") )
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsNv> {
        if self.set_mask & ExternalImageFormatPropertiesNvFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES != ExternalImageFormatPropertiesNvFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::export_from_imported_handle_types: error converting flags") )
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsNv> {
        if self.set_mask & ExternalImageFormatPropertiesNvFlags::FLAG_COMPATIBLEHANDLETYPES != ExternalImageFormatPropertiesNvFlags::FLAG_COMPATIBLEHANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalImageFormatPropertiesNv::compatible_handle_types: error converting flags") )
    }

    pub fn build(self) -> ExternalImageFormatPropertiesNv {
        ExternalImageFormatPropertiesNv {
            raw: self.raw,
        }
    }
}


/// A `VkExternalMemoryImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryImageCreateInfoNv<'s> {
    raw: vks::VkExternalMemoryImageCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryImageCreateInfoNv<'s> {
    pub fn builder<'b>() -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        ExternalMemoryImageCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryImageCreateInfoNV) -> ExternalMemoryImageCreateInfoNv<'s> {
        ExternalMemoryImageCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoNv::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryImageCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryImageCreateInfoNv<'s>> for vks::VkExternalMemoryImageCreateInfoNV {
    fn from(f: ExternalMemoryImageCreateInfoNv<'s>) -> vks::VkExternalMemoryImageCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkExternalMemoryImageCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalMemoryImageCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExternalMemoryImageCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryImageCreateInfoNvBuilder<'b> {
    raw: vks::VkExternalMemoryImageCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalMemoryImageCreateInfoNvFlags,
}

impl<'b> ExternalMemoryImageCreateInfoNvBuilder<'b> {
    pub fn new() -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        ExternalMemoryImageCreateInfoNvBuilder {
            raw: vks::VkExternalMemoryImageCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: ExternalMemoryImageCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalMemoryImageCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExternalMemoryImageCreateInfoNvBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExternalMemoryImageCreateInfoNvFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExternalMemoryImageCreateInfoNvFlags::FLAG_PNEXT != ExternalMemoryImageCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsNv> {
        if self.set_mask & ExternalMemoryImageCreateInfoNvFlags::FLAG_HANDLETYPES != ExternalMemoryImageCreateInfoNvFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoNv::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExternalMemoryImageCreateInfoNv<'b> {
        ExternalMemoryImageCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryAllocateInfoNv<'s> {
    raw: vks::VkExportMemoryAllocateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryAllocateInfoNv<'s> {
    pub fn builder<'b>() -> ExportMemoryAllocateInfoNvBuilder<'b> {
        ExportMemoryAllocateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryAllocateInfoNV) -> ExportMemoryAllocateInfoNv<'s> {
        ExportMemoryAllocateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoNv::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryAllocateInfoNV {
        &self.raw
    }
}

impl<'s> From<ExportMemoryAllocateInfoNv<'s>> for vks::VkExportMemoryAllocateInfoNV {
    fn from(f: ExportMemoryAllocateInfoNv<'s>) -> vks::VkExportMemoryAllocateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkExportMemoryAllocateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportMemoryAllocateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExportMemoryAllocateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryAllocateInfoNvBuilder<'b> {
    raw: vks::VkExportMemoryAllocateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportMemoryAllocateInfoNvFlags,
}

impl<'b> ExportMemoryAllocateInfoNvBuilder<'b> {
    pub fn new() -> ExportMemoryAllocateInfoNvBuilder<'b> {
        ExportMemoryAllocateInfoNvBuilder {
            raw: vks::VkExportMemoryAllocateInfoNV::default(),
            _p: PhantomData,
            set_mask: ExportMemoryAllocateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryAllocateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportMemoryAllocateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsNv) -> ExportMemoryAllocateInfoNvBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExportMemoryAllocateInfoNvFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportMemoryAllocateInfoNvFlags::FLAG_PNEXT != ExportMemoryAllocateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsNv> {
        if self.set_mask & ExportMemoryAllocateInfoNvFlags::FLAG_HANDLETYPES != ExportMemoryAllocateInfoNvFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoNv::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExportMemoryAllocateInfoNv<'b> {
        ExportMemoryAllocateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryWin32HandleInfoNv<'s> {
    raw: vks::VkImportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryWin32HandleInfoNv<'s> {
    pub fn builder<'b>() -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        ImportMemoryWin32HandleInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryWin32HandleInfoNV) -> ImportMemoryWin32HandleInfoNv<'s> {
        ImportMemoryWin32HandleInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsNv {
        ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoNv::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsNv) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryWin32HandleInfoNV {
        &self.raw
    }
}

impl<'s> From<ImportMemoryWin32HandleInfoNv<'s>> for vks::VkImportMemoryWin32HandleInfoNV {
    fn from(f: ImportMemoryWin32HandleInfoNv<'s>) -> vks::VkImportMemoryWin32HandleInfoNV {
        f.raw
    }
}


/// Bitflags for `VkImportMemoryWin32HandleInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportMemoryWin32HandleInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
        const FLAG_HANDLE			 = 0b1000;
    }
}


/// A builder for `VkImportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryWin32HandleInfoNvBuilder<'b> {
    raw: vks::VkImportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportMemoryWin32HandleInfoNvFlags,
}

impl<'b> ImportMemoryWin32HandleInfoNvBuilder<'b> {
    pub fn new() -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        ImportMemoryWin32HandleInfoNvBuilder {
            raw: vks::VkImportMemoryWin32HandleInfoNV::default(),
            _p: PhantomData,
            set_mask: ImportMemoryWin32HandleInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsNv) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.handle = handle.into();
        self.set_mask |= ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT != ImportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsNv> {
        if self.set_mask & ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLETYPE != ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsNv::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoNv::handle_type: error converting flags") )
    }

    pub fn get_handle<'a>(&'a self) -> Option<HANDLE> {
        if self.set_mask & ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLE != ImportMemoryWin32HandleInfoNvFlags::FLAG_HANDLE { return None }
        Some( self.raw.handle.into() )
    }

    pub fn build(self) -> ImportMemoryWin32HandleInfoNv<'b> {
        ImportMemoryWin32HandleInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryWin32HandleInfoNv<'s> {
    raw: vks::VkExportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryWin32HandleInfoNv<'s> {
    pub fn builder<'b>() -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        ExportMemoryWin32HandleInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryWin32HandleInfoNV) -> ExportMemoryWin32HandleInfoNv<'s> {
        ExportMemoryWin32HandleInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryWin32HandleInfoNV {
        &self.raw
    }
}

impl<'s> From<ExportMemoryWin32HandleInfoNv<'s>> for vks::VkExportMemoryWin32HandleInfoNV {
    fn from(f: ExportMemoryWin32HandleInfoNv<'s>) -> vks::VkExportMemoryWin32HandleInfoNV {
        f.raw
    }
}


/// Bitflags for `VkExportMemoryWin32HandleInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportMemoryWin32HandleInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PATTRIBUTES			 = 0b100;
        const FLAG_DWACCESS			 = 0b1000;
    }
}


/// A builder for `VkExportMemoryWin32HandleInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryWin32HandleInfoNvBuilder<'b> {
    raw: vks::VkExportMemoryWin32HandleInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportMemoryWin32HandleInfoNvFlags,
}

impl<'b> ExportMemoryWin32HandleInfoNvBuilder<'b> {
    pub fn new() -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        ExportMemoryWin32HandleInfoNvBuilder {
            raw: vks::VkExportMemoryWin32HandleInfoNV::default(),
            _p: PhantomData,
            set_mask: ExportMemoryWin32HandleInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.pAttributes = attributes;
        self.set_mask |= ExportMemoryWin32HandleInfoNvFlags::FLAG_PATTRIBUTES;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoNvBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self.set_mask |= ExportMemoryWin32HandleInfoNvFlags::FLAG_DWACCESS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT != ExportMemoryWin32HandleInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_attributes<'a>(&'a self) -> Option<&'a SECURITY_ATTRIBUTES> {
        if self.set_mask & ExportMemoryWin32HandleInfoNvFlags::FLAG_PATTRIBUTES != ExportMemoryWin32HandleInfoNvFlags::FLAG_PATTRIBUTES { return None }
        Some( unsafe { &*(self.raw.pAttributes as *const _) } )
    }

    pub fn get_dw_access<'a>(&'a self) -> Option<DWORD> {
        if self.set_mask & ExportMemoryWin32HandleInfoNvFlags::FLAG_DWACCESS != ExportMemoryWin32HandleInfoNvFlags::FLAG_DWACCESS { return None }
        Some( self.raw.dwAccess.into() )
    }

    pub fn build(self) -> ExportMemoryWin32HandleInfoNv<'b> {
        ExportMemoryWin32HandleInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32KeyedMutexAcquireReleaseInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32KeyedMutexAcquireReleaseInfoNv<'s> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32KeyedMutexAcquireReleaseInfoNv<'s> {
    pub fn builder<'b>() -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV) -> Win32KeyedMutexAcquireReleaseInfoNv<'s> {
        Win32KeyedMutexAcquireReleaseInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_timeout_milliseconds<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeoutMilliseconds as *const _, self.raw.acquireCount as usize) }
    }

    pub fn release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_acquire_syncs<'m, 'a>(&mut self, acquire_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_acquire_keys<'m, 'a>(&mut self, acquire_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn set_acquire_timeout_milliseconds<'m, 'a>(&mut self, acquire_timeout_milliseconds: &'a [u32])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeout_milliseconds.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_timeout_milliseconds`.");
        self.raw.acquireCount = acquire_timeout_milliseconds.len() as _;
        self.raw.pAcquireTimeoutMilliseconds = acquire_timeout_milliseconds.as_ptr() as *const u32 as *const _;
    }

    pub fn set_release_syncs<'m, 'a>(&mut self, release_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_release_keys<'m, 'a>(&mut self, release_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
        &self.raw
    }
}

impl<'s> From<Win32KeyedMutexAcquireReleaseInfoNv<'s>> for vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
    fn from(f: Win32KeyedMutexAcquireReleaseInfoNv<'s>) -> vks::VkWin32KeyedMutexAcquireReleaseInfoNV {
        f.raw
    }
}


/// Bitflags for `VkWin32KeyedMutexAcquireReleaseInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Win32KeyedMutexAcquireReleaseInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_ACQUIRECOUNT			 = 0b100;
        const FLAG_PACQUIRESYNCS			 = 0b1000;
        const FLAG_PACQUIREKEYS			 = 0b10000;
        const FLAG_PACQUIRETIMEOUTMILLISECONDS			 = 0b100000;
        const FLAG_RELEASECOUNT			 = 0b1000000;
        const FLAG_PRELEASESYNCS			 = 0b10000000;
        const FLAG_PRELEASEKEYS			 = 0b100000000;
    }
}


/// A builder for `VkWin32KeyedMutexAcquireReleaseInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: Win32KeyedMutexAcquireReleaseInfoNvFlags,
}

impl<'b> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
    pub fn new() -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoNvBuilder {
            raw: vks::VkWin32KeyedMutexAcquireReleaseInfoNV::default(),
            _p: PhantomData,
            set_mask: Win32KeyedMutexAcquireReleaseInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn acquire_syncs<'m, 'a>(mut self, acquire_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRESYNCS;
        self
    }

    pub fn acquire_keys<'m, 'a>(mut self, acquire_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIREKEYS;
        self
    }

    pub fn acquire_timeout_milliseconds<'m, 'a>(mut self, acquire_timeout_milliseconds: &'a [u32]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeout_milliseconds.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::acquire_timeout_milliseconds`.");
        self.raw.acquireCount = acquire_timeout_milliseconds.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireTimeoutMilliseconds = acquire_timeout_milliseconds.as_ptr() as *const u32 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRETIMEOUTMILLISECONDS;
        self
    }

    pub fn release_syncs<'m, 'a>(mut self, release_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_RELEASECOUNT;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASESYNCS;
        self
    }

    pub fn release_keys<'m, 'a>(mut self, release_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoNv::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_RELEASECOUNT;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASEKEYS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PNEXT != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_acquire_syncs<'a>(&'a self) -> Option<&'a [vks::VkDeviceMemory]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRESYNCS != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRESYNCS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_acquire_keys<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIREKEYS != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIREKEYS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_acquire_timeout_milliseconds<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRETIMEOUTMILLISECONDS != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PACQUIRETIMEOUTMILLISECONDS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireTimeoutMilliseconds as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_release_syncs<'a>(&'a self) -> Option<&'a [vks::VkDeviceMemory]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASESYNCS != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASESYNCS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) } )
    }

    pub fn get_release_keys<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASEKEYS != Win32KeyedMutexAcquireReleaseInfoNvFlags::FLAG_PRELEASEKEYS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) } )
    }

    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoNv<'b> {
        Win32KeyedMutexAcquireReleaseInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGeneratedCommandsFeaturesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGeneratedCommandsFeaturesNvx<'s> {
    raw: vks::VkDeviceGeneratedCommandsFeaturesNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGeneratedCommandsFeaturesNvx<'s> {
    pub fn builder<'b>() -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        DeviceGeneratedCommandsFeaturesNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGeneratedCommandsFeaturesNVX) -> DeviceGeneratedCommandsFeaturesNvx<'s> {
        DeviceGeneratedCommandsFeaturesNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn compute_binding_point_support<'a>(&'a self) -> bool {
        self.raw.computeBindingPointSupport != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_compute_binding_point_support<'m>(&mut self, compute_binding_point_support: bool) {
        self.raw.computeBindingPointSupport = compute_binding_point_support as u32;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGeneratedCommandsFeaturesNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGeneratedCommandsFeaturesNvx<'s>> for vks::VkDeviceGeneratedCommandsFeaturesNVX {
    fn from(f: DeviceGeneratedCommandsFeaturesNvx<'s>) -> vks::VkDeviceGeneratedCommandsFeaturesNVX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGeneratedCommandsFeaturesNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGeneratedCommandsFeaturesNvxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_COMPUTEBINDINGPOINTSUPPORT			 = 0b100;
    }
}


/// A builder for `VkDeviceGeneratedCommandsFeaturesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
    raw: vks::VkDeviceGeneratedCommandsFeaturesNVX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGeneratedCommandsFeaturesNvxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
    pub fn new() -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        DeviceGeneratedCommandsFeaturesNvxBuilder {
            raw: vks::VkDeviceGeneratedCommandsFeaturesNVX::default(),
            _p: PhantomData,
            set_mask: DeviceGeneratedCommandsFeaturesNvxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_PNEXT;
        self
    }

    pub fn compute_binding_point_support<'m>(mut self, compute_binding_point_support: bool) -> DeviceGeneratedCommandsFeaturesNvxBuilder<'b> {
        self.raw.computeBindingPointSupport = compute_binding_point_support as u32;
        self.set_mask |= DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_COMPUTEBINDINGPOINTSUPPORT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_PNEXT != DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_compute_binding_point_support<'a>(&'a self) -> Option<bool> {
        if self.set_mask & DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_COMPUTEBINDINGPOINTSUPPORT != DeviceGeneratedCommandsFeaturesNvxFlags::FLAG_COMPUTEBINDINGPOINTSUPPORT { return None }
        Some( self.raw.computeBindingPointSupport != 0 )
    }

    pub fn build(self) -> DeviceGeneratedCommandsFeaturesNvx<'b> {
        DeviceGeneratedCommandsFeaturesNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGeneratedCommandsLimitsNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGeneratedCommandsLimitsNvx<'s> {
    raw: vks::VkDeviceGeneratedCommandsLimitsNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGeneratedCommandsLimitsNvx<'s> {
    pub fn builder<'b>() -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        DeviceGeneratedCommandsLimitsNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGeneratedCommandsLimitsNVX) -> DeviceGeneratedCommandsLimitsNvx<'s> {
        DeviceGeneratedCommandsLimitsNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn max_indirect_commands_layout_token_count<'a>(&'a self) -> u32 {
        self.raw.maxIndirectCommandsLayoutTokenCount.into()
    }

    pub fn max_object_entry_counts<'a>(&'a self) -> u32 {
        self.raw.maxObjectEntryCounts.into()
    }

    pub fn min_sequence_count_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceCountBufferOffsetAlignment.into()
    }

    pub fn min_sequence_index_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minSequenceIndexBufferOffsetAlignment.into()
    }

    pub fn min_commands_token_buffer_offset_alignment<'a>(&'a self) -> u32 {
        self.raw.minCommandsTokenBufferOffsetAlignment.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_indirect_commands_layout_token_count<'m>(&mut self, max_indirect_commands_layout_token_count: u32) {
        self.raw.maxIndirectCommandsLayoutTokenCount = max_indirect_commands_layout_token_count.into();
    }

    pub fn set_max_object_entry_counts<'m>(&mut self, max_object_entry_counts: u32) {
        self.raw.maxObjectEntryCounts = max_object_entry_counts.into();
    }

    pub fn set_min_sequence_count_buffer_offset_alignment<'m>(&mut self, min_sequence_count_buffer_offset_alignment: u32) {
        self.raw.minSequenceCountBufferOffsetAlignment = min_sequence_count_buffer_offset_alignment.into();
    }

    pub fn set_min_sequence_index_buffer_offset_alignment<'m>(&mut self, min_sequence_index_buffer_offset_alignment: u32) {
        self.raw.minSequenceIndexBufferOffsetAlignment = min_sequence_index_buffer_offset_alignment.into();
    }

    pub fn set_min_commands_token_buffer_offset_alignment<'m>(&mut self, min_commands_token_buffer_offset_alignment: u32) {
        self.raw.minCommandsTokenBufferOffsetAlignment = min_commands_token_buffer_offset_alignment.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGeneratedCommandsLimitsNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGeneratedCommandsLimitsNvx<'s>> for vks::VkDeviceGeneratedCommandsLimitsNVX {
    fn from(f: DeviceGeneratedCommandsLimitsNvx<'s>) -> vks::VkDeviceGeneratedCommandsLimitsNVX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGeneratedCommandsLimitsNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGeneratedCommandsLimitsNvxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MAXINDIRECTCOMMANDSLAYOUTTOKENCOUNT			 = 0b100;
        const FLAG_MAXOBJECTENTRYCOUNTS			 = 0b1000;
        const FLAG_MINSEQUENCECOUNTBUFFEROFFSETALIGNMENT			 = 0b10000;
        const FLAG_MINSEQUENCEINDEXBUFFEROFFSETALIGNMENT			 = 0b100000;
        const FLAG_MINCOMMANDSTOKENBUFFEROFFSETALIGNMENT			 = 0b1000000;
    }
}


/// A builder for `VkDeviceGeneratedCommandsLimitsNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
    raw: vks::VkDeviceGeneratedCommandsLimitsNVX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGeneratedCommandsLimitsNvxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
    pub fn new() -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        DeviceGeneratedCommandsLimitsNvxBuilder {
            raw: vks::VkDeviceGeneratedCommandsLimitsNVX::default(),
            _p: PhantomData,
            set_mask: DeviceGeneratedCommandsLimitsNvxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_PNEXT;
        self
    }

    pub fn max_indirect_commands_layout_token_count<'m>(mut self, max_indirect_commands_layout_token_count: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.maxIndirectCommandsLayoutTokenCount = max_indirect_commands_layout_token_count.into();
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXINDIRECTCOMMANDSLAYOUTTOKENCOUNT;
        self
    }

    pub fn max_object_entry_counts<'m>(mut self, max_object_entry_counts: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.maxObjectEntryCounts = max_object_entry_counts.into();
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXOBJECTENTRYCOUNTS;
        self
    }

    pub fn min_sequence_count_buffer_offset_alignment<'m>(mut self, min_sequence_count_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minSequenceCountBufferOffsetAlignment = min_sequence_count_buffer_offset_alignment.into();
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCECOUNTBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn min_sequence_index_buffer_offset_alignment<'m>(mut self, min_sequence_index_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minSequenceIndexBufferOffsetAlignment = min_sequence_index_buffer_offset_alignment.into();
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCEINDEXBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn min_commands_token_buffer_offset_alignment<'m>(mut self, min_commands_token_buffer_offset_alignment: u32) -> DeviceGeneratedCommandsLimitsNvxBuilder<'b> {
        self.raw.minCommandsTokenBufferOffsetAlignment = min_commands_token_buffer_offset_alignment.into();
        self.set_mask |= DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINCOMMANDSTOKENBUFFEROFFSETALIGNMENT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_PNEXT != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_max_indirect_commands_layout_token_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXINDIRECTCOMMANDSLAYOUTTOKENCOUNT != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXINDIRECTCOMMANDSLAYOUTTOKENCOUNT { return None }
        Some( self.raw.maxIndirectCommandsLayoutTokenCount.into() )
    }

    pub fn get_max_object_entry_counts<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXOBJECTENTRYCOUNTS != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MAXOBJECTENTRYCOUNTS { return None }
        Some( self.raw.maxObjectEntryCounts.into() )
    }

    pub fn get_min_sequence_count_buffer_offset_alignment<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCECOUNTBUFFEROFFSETALIGNMENT != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCECOUNTBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minSequenceCountBufferOffsetAlignment.into() )
    }

    pub fn get_min_sequence_index_buffer_offset_alignment<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCEINDEXBUFFEROFFSETALIGNMENT != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINSEQUENCEINDEXBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minSequenceIndexBufferOffsetAlignment.into() )
    }

    pub fn get_min_commands_token_buffer_offset_alignment<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINCOMMANDSTOKENBUFFEROFFSETALIGNMENT != DeviceGeneratedCommandsLimitsNvxFlags::FLAG_MINCOMMANDSTOKENBUFFEROFFSETALIGNMENT { return None }
        Some( self.raw.minCommandsTokenBufferOffsetAlignment.into() )
    }

    pub fn build(self) -> DeviceGeneratedCommandsLimitsNvx<'b> {
        DeviceGeneratedCommandsLimitsNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkCmdReserveSpaceForCommandsInfoNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct CmdReserveSpaceForCommandsInfoNvx<'s> {
    raw: vks::VkCmdReserveSpaceForCommandsInfoNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> CmdReserveSpaceForCommandsInfoNvx<'s> {
    pub fn builder<'b>() -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        CmdReserveSpaceForCommandsInfoNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkCmdReserveSpaceForCommandsInfoNVX) -> CmdReserveSpaceForCommandsInfoNvx<'s> {
        CmdReserveSpaceForCommandsInfoNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn object_table<'a>(&'a self) -> vks::VkObjectTableNVX {
        self.raw.objectTable
    }

    pub fn indirect_commands_layout<'a>(&'a self) -> vks::VkIndirectCommandsLayoutNVX {
        self.raw.indirectCommandsLayout
    }

    pub fn max_sequences_count<'a>(&'a self) -> u32 {
        self.raw.maxSequencesCount.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_object_table<'m, H>(&mut self, object_table: H)
            where H: Handle<Target=ObjectTableNvxHandle> {
        self.raw.objectTable = object_table.handle().0;
    }

    pub fn set_indirect_commands_layout<'m, H>(&mut self, indirect_commands_layout: H)
            where H: Handle<Target=IndirectCommandsLayoutNvxHandle> {
        self.raw.indirectCommandsLayout = indirect_commands_layout.handle().0;
    }

    pub fn set_max_sequences_count<'m>(&mut self, max_sequences_count: u32) {
        self.raw.maxSequencesCount = max_sequences_count.into();
    }

    pub fn as_raw(&self) -> &vks::VkCmdReserveSpaceForCommandsInfoNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<CmdReserveSpaceForCommandsInfoNvx<'s>> for vks::VkCmdReserveSpaceForCommandsInfoNVX {
    fn from(f: CmdReserveSpaceForCommandsInfoNvx<'s>) -> vks::VkCmdReserveSpaceForCommandsInfoNVX {
        f.raw
    }
}


/// Bitflags for `VkCmdReserveSpaceForCommandsInfoNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct CmdReserveSpaceForCommandsInfoNvxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_OBJECTTABLE			 = 0b100;
        const FLAG_INDIRECTCOMMANDSLAYOUT			 = 0b1000;
        const FLAG_MAXSEQUENCESCOUNT			 = 0b10000;
    }
}


/// A builder for `VkCmdReserveSpaceForCommandsInfoNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
    raw: vks::VkCmdReserveSpaceForCommandsInfoNVX,
    _p: PhantomData<&'b ()>, 
    set_mask: CmdReserveSpaceForCommandsInfoNvxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
    pub fn new() -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        CmdReserveSpaceForCommandsInfoNvxBuilder {
            raw: vks::VkCmdReserveSpaceForCommandsInfoNVX::default(),
            _p: PhantomData,
            set_mask: CmdReserveSpaceForCommandsInfoNvxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_PNEXT;
        self
    }

    pub fn object_table<'m, H>(mut self, object_table: H) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b>
            where H: Handle<Target=ObjectTableNvxHandle> {
        self.raw.objectTable = object_table.handle().0;
        self.set_mask |= CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_OBJECTTABLE;
        self
    }

    pub fn indirect_commands_layout<'m, H>(mut self, indirect_commands_layout: H) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b>
            where H: Handle<Target=IndirectCommandsLayoutNvxHandle> {
        self.raw.indirectCommandsLayout = indirect_commands_layout.handle().0;
        self.set_mask |= CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_INDIRECTCOMMANDSLAYOUT;
        self
    }

    pub fn max_sequences_count<'m>(mut self, max_sequences_count: u32) -> CmdReserveSpaceForCommandsInfoNvxBuilder<'b> {
        self.raw.maxSequencesCount = max_sequences_count.into();
        self.set_mask |= CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_MAXSEQUENCESCOUNT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_PNEXT != CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_object_table<'a>(&'a self) -> Option<vks::VkObjectTableNVX> {
        if self.set_mask & CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_OBJECTTABLE != CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_OBJECTTABLE { return None }
        Some( self.raw.objectTable )
    }

    pub fn get_indirect_commands_layout<'a>(&'a self) -> Option<vks::VkIndirectCommandsLayoutNVX> {
        if self.set_mask & CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_INDIRECTCOMMANDSLAYOUT != CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_INDIRECTCOMMANDSLAYOUT { return None }
        Some( self.raw.indirectCommandsLayout )
    }

    pub fn get_max_sequences_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_MAXSEQUENCESCOUNT != CmdReserveSpaceForCommandsInfoNvxFlags::FLAG_MAXSEQUENCESCOUNT { return None }
        Some( self.raw.maxSequencesCount.into() )
    }

    pub fn build(self) -> CmdReserveSpaceForCommandsInfoNvx<'b> {
        CmdReserveSpaceForCommandsInfoNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkObjectTableDescriptorSetEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableDescriptorSetEntryNvx {
    raw: vks::VkObjectTableDescriptorSetEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableDescriptorSetEntryNvx {
    pub fn builder() -> ObjectTableDescriptorSetEntryNvxBuilder {
        ObjectTableDescriptorSetEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableDescriptorSetEntryNVX) -> ObjectTableDescriptorSetEntryNvx {
        ObjectTableDescriptorSetEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableDescriptorSetEntryNvx::flags: error converting flags")
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn descriptor_set<'a>(&'a self) -> vks::VkDescriptorSet {
        self.raw.descriptorSet
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_descriptor_set<'m, H>(&mut self, descriptor_set: H)
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.descriptorSet = descriptor_set.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableDescriptorSetEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableDescriptorSetEntryNvx> for vks::VkObjectTableDescriptorSetEntryNVX {
    fn from(f: ObjectTableDescriptorSetEntryNvx) -> vks::VkObjectTableDescriptorSetEntryNVX {
        f.raw
    }
}


/// Bitflags for `VkObjectTableDescriptorSetEntryNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ObjectTableDescriptorSetEntryNvxFlags: u32 {
        const FLAG_TYPE_			 = 0b1;
        const FLAG_FLAGS			 = 0b10;
        const FLAG_PIPELINELAYOUT			 = 0b100;
        const FLAG_DESCRIPTORSET			 = 0b1000;
    }
}


/// A builder for `VkObjectTableDescriptorSetEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableDescriptorSetEntryNvxBuilder {
    raw: vks::VkObjectTableDescriptorSetEntryNVX,
    set_mask: ObjectTableDescriptorSetEntryNvxFlags,
}

#[cfg(feature = "experimental")]
impl ObjectTableDescriptorSetEntryNvxBuilder {
    pub fn new() -> ObjectTableDescriptorSetEntryNvxBuilder {
        ObjectTableDescriptorSetEntryNvxBuilder {
            raw: vks::VkObjectTableDescriptorSetEntryNVX::default(),
            set_mask: ObjectTableDescriptorSetEntryNvxFlags::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableDescriptorSetEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self.set_mask |= ObjectTableDescriptorSetEntryNvxFlags::FLAG_TYPE_;
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableDescriptorSetEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= ObjectTableDescriptorSetEntryNvxFlags::FLAG_FLAGS;
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> ObjectTableDescriptorSetEntryNvxBuilder
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self.set_mask |= ObjectTableDescriptorSetEntryNvxFlags::FLAG_PIPELINELAYOUT;
        self
    }

    pub fn descriptor_set<'m, H>(mut self, descriptor_set: H) -> ObjectTableDescriptorSetEntryNvxBuilder
            where H: Handle<Target=DescriptorSetHandle> {
        self.raw.descriptorSet = descriptor_set.handle().0;
        self.set_mask |= ObjectTableDescriptorSetEntryNvxFlags::FLAG_DESCRIPTORSET;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ObjectEntryTypeNvx> {
        if self.set_mask & ObjectTableDescriptorSetEntryNvxFlags::FLAG_TYPE_ != ObjectTableDescriptorSetEntryNvxFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ObjectEntryUsageFlagsNvx> {
        if self.set_mask & ObjectTableDescriptorSetEntryNvxFlags::FLAG_FLAGS != ObjectTableDescriptorSetEntryNvxFlags::FLAG_FLAGS { return None }
        Some( ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableDescriptorSetEntryNvx::flags: error converting flags") )
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> Option<vks::VkPipelineLayout> {
        if self.set_mask & ObjectTableDescriptorSetEntryNvxFlags::FLAG_PIPELINELAYOUT != ObjectTableDescriptorSetEntryNvxFlags::FLAG_PIPELINELAYOUT { return None }
        Some( self.raw.pipelineLayout )
    }

    pub fn get_descriptor_set<'a>(&'a self) -> Option<vks::VkDescriptorSet> {
        if self.set_mask & ObjectTableDescriptorSetEntryNvxFlags::FLAG_DESCRIPTORSET != ObjectTableDescriptorSetEntryNvxFlags::FLAG_DESCRIPTORSET { return None }
        Some( self.raw.descriptorSet )
    }

    pub fn build(self) -> ObjectTableDescriptorSetEntryNvx {
        ObjectTableDescriptorSetEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTableVertexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableVertexBufferEntryNvx {
    raw: vks::VkObjectTableVertexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableVertexBufferEntryNvx {
    pub fn builder() -> ObjectTableVertexBufferEntryNvxBuilder {
        ObjectTableVertexBufferEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableVertexBufferEntryNVX) -> ObjectTableVertexBufferEntryNvx {
        ObjectTableVertexBufferEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableVertexBufferEntryNvx::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableVertexBufferEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableVertexBufferEntryNvx> for vks::VkObjectTableVertexBufferEntryNVX {
    fn from(f: ObjectTableVertexBufferEntryNvx) -> vks::VkObjectTableVertexBufferEntryNVX {
        f.raw
    }
}


/// Bitflags for `VkObjectTableVertexBufferEntryNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ObjectTableVertexBufferEntryNvxFlags: u32 {
        const FLAG_TYPE_			 = 0b1;
        const FLAG_FLAGS			 = 0b10;
        const FLAG_BUFFER			 = 0b100;
    }
}


/// A builder for `VkObjectTableVertexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableVertexBufferEntryNvxBuilder {
    raw: vks::VkObjectTableVertexBufferEntryNVX,
    set_mask: ObjectTableVertexBufferEntryNvxFlags,
}

#[cfg(feature = "experimental")]
impl ObjectTableVertexBufferEntryNvxBuilder {
    pub fn new() -> ObjectTableVertexBufferEntryNvxBuilder {
        ObjectTableVertexBufferEntryNvxBuilder {
            raw: vks::VkObjectTableVertexBufferEntryNVX::default(),
            set_mask: ObjectTableVertexBufferEntryNvxFlags::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableVertexBufferEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self.set_mask |= ObjectTableVertexBufferEntryNvxFlags::FLAG_TYPE_;
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableVertexBufferEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= ObjectTableVertexBufferEntryNvxFlags::FLAG_FLAGS;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> ObjectTableVertexBufferEntryNvxBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= ObjectTableVertexBufferEntryNvxFlags::FLAG_BUFFER;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ObjectEntryTypeNvx> {
        if self.set_mask & ObjectTableVertexBufferEntryNvxFlags::FLAG_TYPE_ != ObjectTableVertexBufferEntryNvxFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ObjectEntryUsageFlagsNvx> {
        if self.set_mask & ObjectTableVertexBufferEntryNvxFlags::FLAG_FLAGS != ObjectTableVertexBufferEntryNvxFlags::FLAG_FLAGS { return None }
        Some( ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableVertexBufferEntryNvx::flags: error converting flags") )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & ObjectTableVertexBufferEntryNvxFlags::FLAG_BUFFER != ObjectTableVertexBufferEntryNvxFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn build(self) -> ObjectTableVertexBufferEntryNvx {
        ObjectTableVertexBufferEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTableIndexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTableIndexBufferEntryNvx {
    raw: vks::VkObjectTableIndexBufferEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTableIndexBufferEntryNvx {
    pub fn builder() -> ObjectTableIndexBufferEntryNvxBuilder {
        ObjectTableIndexBufferEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTableIndexBufferEntryNVX) -> ObjectTableIndexBufferEntryNvx {
        ObjectTableIndexBufferEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableIndexBufferEntryNvx::flags: error converting flags")
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub fn index_type<'a>(&'a self) -> IndexType {
        self.raw.indexType.into()
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn set_index_type<'m>(&mut self, index_type: IndexType) {
        self.raw.indexType = index_type.into();
    }

    pub fn as_raw(&self) -> &vks::VkObjectTableIndexBufferEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTableIndexBufferEntryNvx> for vks::VkObjectTableIndexBufferEntryNVX {
    fn from(f: ObjectTableIndexBufferEntryNvx) -> vks::VkObjectTableIndexBufferEntryNVX {
        f.raw
    }
}


/// Bitflags for `VkObjectTableIndexBufferEntryNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ObjectTableIndexBufferEntryNvxFlags: u32 {
        const FLAG_TYPE_			 = 0b1;
        const FLAG_FLAGS			 = 0b10;
        const FLAG_BUFFER			 = 0b100;
        const FLAG_INDEXTYPE			 = 0b1000;
    }
}


/// A builder for `VkObjectTableIndexBufferEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTableIndexBufferEntryNvxBuilder {
    raw: vks::VkObjectTableIndexBufferEntryNVX,
    set_mask: ObjectTableIndexBufferEntryNvxFlags,
}

#[cfg(feature = "experimental")]
impl ObjectTableIndexBufferEntryNvxBuilder {
    pub fn new() -> ObjectTableIndexBufferEntryNvxBuilder {
        ObjectTableIndexBufferEntryNvxBuilder {
            raw: vks::VkObjectTableIndexBufferEntryNVX::default(),
            set_mask: ObjectTableIndexBufferEntryNvxFlags::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self.set_mask |= ObjectTableIndexBufferEntryNvxFlags::FLAG_TYPE_;
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= ObjectTableIndexBufferEntryNvxFlags::FLAG_FLAGS;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> ObjectTableIndexBufferEntryNvxBuilder
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= ObjectTableIndexBufferEntryNvxFlags::FLAG_BUFFER;
        self
    }

    pub fn index_type<'m>(mut self, index_type: IndexType) -> ObjectTableIndexBufferEntryNvxBuilder {
        self.raw.indexType = index_type.into();
        self.set_mask |= ObjectTableIndexBufferEntryNvxFlags::FLAG_INDEXTYPE;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ObjectEntryTypeNvx> {
        if self.set_mask & ObjectTableIndexBufferEntryNvxFlags::FLAG_TYPE_ != ObjectTableIndexBufferEntryNvxFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ObjectEntryUsageFlagsNvx> {
        if self.set_mask & ObjectTableIndexBufferEntryNvxFlags::FLAG_FLAGS != ObjectTableIndexBufferEntryNvxFlags::FLAG_FLAGS { return None }
        Some( ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTableIndexBufferEntryNvx::flags: error converting flags") )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & ObjectTableIndexBufferEntryNvxFlags::FLAG_BUFFER != ObjectTableIndexBufferEntryNvxFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn get_index_type<'a>(&'a self) -> Option<IndexType> {
        if self.set_mask & ObjectTableIndexBufferEntryNvxFlags::FLAG_INDEXTYPE != ObjectTableIndexBufferEntryNvxFlags::FLAG_INDEXTYPE { return None }
        Some( self.raw.indexType.into() )
    }

    pub fn build(self) -> ObjectTableIndexBufferEntryNvx {
        ObjectTableIndexBufferEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkObjectTablePushConstantEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ObjectTablePushConstantEntryNvx {
    raw: vks::VkObjectTablePushConstantEntryNVX,
}

#[cfg(feature = "experimental")]
impl ObjectTablePushConstantEntryNvx {
    pub fn builder() -> ObjectTablePushConstantEntryNvxBuilder {
        ObjectTablePushConstantEntryNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkObjectTablePushConstantEntryNVX) -> ObjectTablePushConstantEntryNvx {
        ObjectTablePushConstantEntryNvx { raw, }
    }

    pub fn type_of<'a>(&'a self) -> ObjectEntryTypeNvx {
        self.raw.type_.into()
    }

    pub fn flags<'a>(&'a self) -> ObjectEntryUsageFlagsNvx {
        ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTablePushConstantEntryNvx::flags: error converting flags")
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn stage_flags<'a>(&'a self) -> ShaderStageFlags {
        ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("ObjectTablePushConstantEntryNvx::stage_flags: error converting flags")
    }

    pub fn set_type_of<'m>(&mut self, type_of: ObjectEntryTypeNvx) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_flags<'m>(&mut self, flags: ObjectEntryUsageFlagsNvx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_stage_flags<'m>(&mut self, stage_flags: ShaderStageFlags) {
        self.raw.stageFlags = stage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkObjectTablePushConstantEntryNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl From<ObjectTablePushConstantEntryNvx> for vks::VkObjectTablePushConstantEntryNVX {
    fn from(f: ObjectTablePushConstantEntryNvx) -> vks::VkObjectTablePushConstantEntryNVX {
        f.raw
    }
}


/// Bitflags for `VkObjectTablePushConstantEntryNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ObjectTablePushConstantEntryNvxFlags: u32 {
        const FLAG_TYPE_			 = 0b1;
        const FLAG_FLAGS			 = 0b10;
        const FLAG_PIPELINELAYOUT			 = 0b100;
        const FLAG_STAGEFLAGS			 = 0b1000;
    }
}


/// A builder for `VkObjectTablePushConstantEntryNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ObjectTablePushConstantEntryNvxBuilder {
    raw: vks::VkObjectTablePushConstantEntryNVX,
    set_mask: ObjectTablePushConstantEntryNvxFlags,
}

#[cfg(feature = "experimental")]
impl ObjectTablePushConstantEntryNvxBuilder {
    pub fn new() -> ObjectTablePushConstantEntryNvxBuilder {
        ObjectTablePushConstantEntryNvxBuilder {
            raw: vks::VkObjectTablePushConstantEntryNVX::default(),
            set_mask: ObjectTablePushConstantEntryNvxFlags::default(),
        }
    }

    pub fn type_of<'m>(mut self, type_of: ObjectEntryTypeNvx) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.type_ = type_of.into();
        self.set_mask |= ObjectTablePushConstantEntryNvxFlags::FLAG_TYPE_;
        self
    }

    pub fn flags<'m>(mut self, flags: ObjectEntryUsageFlagsNvx) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.flags = flags.bits();
        self.set_mask |= ObjectTablePushConstantEntryNvxFlags::FLAG_FLAGS;
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> ObjectTablePushConstantEntryNvxBuilder
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self.set_mask |= ObjectTablePushConstantEntryNvxFlags::FLAG_PIPELINELAYOUT;
        self
    }

    pub fn stage_flags<'m>(mut self, stage_flags: ShaderStageFlags) -> ObjectTablePushConstantEntryNvxBuilder {
        self.raw.stageFlags = stage_flags.bits();
        self.set_mask |= ObjectTablePushConstantEntryNvxFlags::FLAG_STAGEFLAGS;
        self
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ObjectEntryTypeNvx> {
        if self.set_mask & ObjectTablePushConstantEntryNvxFlags::FLAG_TYPE_ != ObjectTablePushConstantEntryNvxFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ObjectEntryUsageFlagsNvx> {
        if self.set_mask & ObjectTablePushConstantEntryNvxFlags::FLAG_FLAGS != ObjectTablePushConstantEntryNvxFlags::FLAG_FLAGS { return None }
        Some( ObjectEntryUsageFlagsNvx::from_bits(self.raw.flags)
            .expect("ObjectTablePushConstantEntryNvx::flags: error converting flags") )
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> Option<vks::VkPipelineLayout> {
        if self.set_mask & ObjectTablePushConstantEntryNvxFlags::FLAG_PIPELINELAYOUT != ObjectTablePushConstantEntryNvxFlags::FLAG_PIPELINELAYOUT { return None }
        Some( self.raw.pipelineLayout )
    }

    pub fn get_stage_flags<'a>(&'a self) -> Option<ShaderStageFlags> {
        if self.set_mask & ObjectTablePushConstantEntryNvxFlags::FLAG_STAGEFLAGS != ObjectTablePushConstantEntryNvxFlags::FLAG_STAGEFLAGS { return None }
        Some( ShaderStageFlags::from_bits(self.raw.stageFlags)
            .expect("ObjectTablePushConstantEntryNvx::stage_flags: error converting flags") )
    }

    pub fn build(self) -> ObjectTablePushConstantEntryNvx {
        ObjectTablePushConstantEntryNvx {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceFeatures2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceFeatures2Khr<'s> {
    raw: vks::VkPhysicalDeviceFeatures2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceFeatures2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        PhysicalDeviceFeatures2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceFeatures2KHR) -> PhysicalDeviceFeatures2Khr<'s> {
        PhysicalDeviceFeatures2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn features<'a>(&'a self) -> &'a PhysicalDeviceFeatures {
         unsafe { &*(&self.raw.features as *const vks::VkPhysicalDeviceFeatures as *const PhysicalDeviceFeatures) }
    }

    pub fn features_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceFeatures {
        unsafe { &mut *(&mut self.raw.features as *mut  vks::VkPhysicalDeviceFeatures as *mut PhysicalDeviceFeatures) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_features<'m>(&mut self, features: PhysicalDeviceFeatures) {
        self.raw.features = features.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceFeatures2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceFeatures2Khr<'s>> for vks::VkPhysicalDeviceFeatures2KHR {
    fn from(f: PhysicalDeviceFeatures2Khr<'s>) -> vks::VkPhysicalDeviceFeatures2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceFeatures2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceFeatures2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FEATURES			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceFeatures2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceFeatures2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceFeatures2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceFeatures2KhrFlags,
}

impl<'b> PhysicalDeviceFeatures2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        PhysicalDeviceFeatures2KhrBuilder {
            raw: vks::VkPhysicalDeviceFeatures2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceFeatures2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceFeatures2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn features<'m>(mut self, features: PhysicalDeviceFeatures) -> PhysicalDeviceFeatures2KhrBuilder<'b> {
        self.raw.features = features.raw;
        self.set_mask |= PhysicalDeviceFeatures2KhrFlags::FLAG_FEATURES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceFeatures2KhrFlags::FLAG_PNEXT != PhysicalDeviceFeatures2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_features<'a>(&'a self) -> Option<&'a PhysicalDeviceFeatures> {
        if self.set_mask & PhysicalDeviceFeatures2KhrFlags::FLAG_FEATURES != PhysicalDeviceFeatures2KhrFlags::FLAG_FEATURES { return None }
        Some(  unsafe { &*(&self.raw.features as *const vks::VkPhysicalDeviceFeatures as *const PhysicalDeviceFeatures) } )
    }

    pub fn get_features_mut<'a>(&'a mut self) -> Option<&'a mut PhysicalDeviceFeatures> {
        if self.set_mask & PhysicalDeviceFeatures2KhrFlags::FLAG_FEATURES != PhysicalDeviceFeatures2KhrFlags::FLAG_FEATURES { return None }
        Some( unsafe { &mut *(&mut self.raw.features as *mut  vks::VkPhysicalDeviceFeatures as *mut PhysicalDeviceFeatures) } )
    }

    pub fn build(self) -> PhysicalDeviceFeatures2Khr<'b> {
        PhysicalDeviceFeatures2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceProperties2Khr<'s> {
    raw: vks::VkPhysicalDeviceProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceProperties2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceProperties2KhrBuilder<'b> {
        PhysicalDeviceProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceProperties2KHR) -> PhysicalDeviceProperties2Khr<'s> {
        PhysicalDeviceProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn properties<'a>(&'a self) -> &'a PhysicalDeviceProperties {
         unsafe { &*(&self.raw.properties as *const vks::VkPhysicalDeviceProperties as *const PhysicalDeviceProperties) }
    }

    pub fn properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkPhysicalDeviceProperties as *mut PhysicalDeviceProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_properties<'m>(&mut self, properties: PhysicalDeviceProperties) {
        self.raw.properties = properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceProperties2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceProperties2Khr<'s>> for vks::VkPhysicalDeviceProperties2KHR {
    fn from(f: PhysicalDeviceProperties2Khr<'s>) -> vks::VkPhysicalDeviceProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PROPERTIES			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceProperties2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceProperties2KhrFlags,
}

impl<'b> PhysicalDeviceProperties2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceProperties2KhrBuilder<'b> {
        PhysicalDeviceProperties2KhrBuilder {
            raw: vks::VkPhysicalDeviceProperties2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn properties<'m>(mut self, properties: PhysicalDeviceProperties) -> PhysicalDeviceProperties2KhrBuilder<'b> {
        self.raw.properties = properties.raw;
        self.set_mask |= PhysicalDeviceProperties2KhrFlags::FLAG_PROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceProperties2KhrFlags::FLAG_PNEXT != PhysicalDeviceProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_properties<'a>(&'a self) -> Option<&'a PhysicalDeviceProperties> {
        if self.set_mask & PhysicalDeviceProperties2KhrFlags::FLAG_PROPERTIES != PhysicalDeviceProperties2KhrFlags::FLAG_PROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.properties as *const vks::VkPhysicalDeviceProperties as *const PhysicalDeviceProperties) } )
    }

    pub fn get_properties_mut<'a>(&'a mut self) -> Option<&'a mut PhysicalDeviceProperties> {
        if self.set_mask & PhysicalDeviceProperties2KhrFlags::FLAG_PROPERTIES != PhysicalDeviceProperties2KhrFlags::FLAG_PROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkPhysicalDeviceProperties as *mut PhysicalDeviceProperties) } )
    }

    pub fn build(self) -> PhysicalDeviceProperties2Khr<'b> {
        PhysicalDeviceProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FormatProperties2Khr<'s> {
    raw: vks::VkFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FormatProperties2Khr<'s> {
    pub fn builder<'b>() -> FormatProperties2KhrBuilder<'b> {
        FormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFormatProperties2KHR) -> FormatProperties2Khr<'s> {
        FormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn format_properties<'a>(&'a self) -> &'a FormatProperties {
         unsafe { &*(&self.raw.formatProperties as *const vks::VkFormatProperties as *const FormatProperties) }
    }

    pub fn format_properties_mut<'a>(&'a mut self) -> &'a mut FormatProperties {
        unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkFormatProperties as *mut FormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format_properties<'m>(&mut self, format_properties: FormatProperties) {
        self.raw.formatProperties = format_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<FormatProperties2Khr<'s>> for vks::VkFormatProperties2KHR {
    fn from(f: FormatProperties2Khr<'s>) -> vks::VkFormatProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkFormatProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FormatProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FORMATPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FormatProperties2KhrBuilder<'b> {
    raw: vks::VkFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: FormatProperties2KhrFlags,
}

impl<'b> FormatProperties2KhrBuilder<'b> {
    pub fn new() -> FormatProperties2KhrBuilder<'b> {
        FormatProperties2KhrBuilder {
            raw: vks::VkFormatProperties2KHR::default(),
            _p: PhantomData,
            set_mask: FormatProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> FormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= FormatProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn format_properties<'m>(mut self, format_properties: FormatProperties) -> FormatProperties2KhrBuilder<'b> {
        self.raw.formatProperties = format_properties.raw;
        self.set_mask |= FormatProperties2KhrFlags::FLAG_FORMATPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & FormatProperties2KhrFlags::FLAG_PNEXT != FormatProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_format_properties<'a>(&'a self) -> Option<&'a FormatProperties> {
        if self.set_mask & FormatProperties2KhrFlags::FLAG_FORMATPROPERTIES != FormatProperties2KhrFlags::FLAG_FORMATPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.formatProperties as *const vks::VkFormatProperties as *const FormatProperties) } )
    }

    pub fn get_format_properties_mut<'a>(&'a mut self) -> Option<&'a mut FormatProperties> {
        if self.set_mask & FormatProperties2KhrFlags::FLAG_FORMATPROPERTIES != FormatProperties2KhrFlags::FLAG_FORMATPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.formatProperties as *mut  vks::VkFormatProperties as *mut FormatProperties) } )
    }

    pub fn build(self) -> FormatProperties2Khr<'b> {
        FormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageFormatProperties2Khr<'s> {
    raw: vks::VkImageFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageFormatProperties2Khr<'s> {
    pub fn builder<'b>() -> ImageFormatProperties2KhrBuilder<'b> {
        ImageFormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageFormatProperties2KHR) -> ImageFormatProperties2Khr<'s> {
        ImageFormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn image_format_properties<'a>(&'a self) -> &'a ImageFormatProperties {
         unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) }
    }

    pub fn image_format_properties_mut<'a>(&'a mut self) -> &'a mut ImageFormatProperties {
        unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image_format_properties<'m>(&mut self, image_format_properties: ImageFormatProperties) {
        self.raw.imageFormatProperties = image_format_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkImageFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<ImageFormatProperties2Khr<'s>> for vks::VkImageFormatProperties2KHR {
    fn from(f: ImageFormatProperties2Khr<'s>) -> vks::VkImageFormatProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkImageFormatProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageFormatProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_IMAGEFORMATPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageFormatProperties2KhrBuilder<'b> {
    raw: vks::VkImageFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageFormatProperties2KhrFlags,
}

impl<'b> ImageFormatProperties2KhrBuilder<'b> {
    pub fn new() -> ImageFormatProperties2KhrBuilder<'b> {
        ImageFormatProperties2KhrBuilder {
            raw: vks::VkImageFormatProperties2KHR::default(),
            _p: PhantomData,
            set_mask: ImageFormatProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ImageFormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageFormatProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn image_format_properties<'m>(mut self, image_format_properties: ImageFormatProperties) -> ImageFormatProperties2KhrBuilder<'b> {
        self.raw.imageFormatProperties = image_format_properties.raw;
        self.set_mask |= ImageFormatProperties2KhrFlags::FLAG_IMAGEFORMATPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ImageFormatProperties2KhrFlags::FLAG_PNEXT != ImageFormatProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_image_format_properties<'a>(&'a self) -> Option<&'a ImageFormatProperties> {
        if self.set_mask & ImageFormatProperties2KhrFlags::FLAG_IMAGEFORMATPROPERTIES != ImageFormatProperties2KhrFlags::FLAG_IMAGEFORMATPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.imageFormatProperties as *const vks::VkImageFormatProperties as *const ImageFormatProperties) } )
    }

    pub fn get_image_format_properties_mut<'a>(&'a mut self) -> Option<&'a mut ImageFormatProperties> {
        if self.set_mask & ImageFormatProperties2KhrFlags::FLAG_IMAGEFORMATPROPERTIES != ImageFormatProperties2KhrFlags::FLAG_IMAGEFORMATPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.imageFormatProperties as *mut  vks::VkImageFormatProperties as *mut ImageFormatProperties) } )
    }

    pub fn build(self) -> ImageFormatProperties2Khr<'b> {
        ImageFormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceImageFormatInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceImageFormatInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceImageFormatInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceImageFormatInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceImageFormatInfo2KHR) -> PhysicalDeviceImageFormatInfo2Khr<'s> {
        PhysicalDeviceImageFormatInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn flags<'a>(&'a self) -> ImageCreateFlags {
        ImageCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceImageFormatInfo2Khr::flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_type_of<'m>(&mut self, type_of: ImageType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_flags<'m>(&mut self, flags: ImageCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceImageFormatInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceImageFormatInfo2Khr<'s>> for vks::VkPhysicalDeviceImageFormatInfo2KHR {
    fn from(f: PhysicalDeviceImageFormatInfo2Khr<'s>) -> vks::VkPhysicalDeviceImageFormatInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceImageFormatInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceImageFormatInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FORMAT			 = 0b100;
        const FLAG_TYPE_			 = 0b1000;
        const FLAG_TILING			 = 0b10000;
        const FLAG_USAGE			 = 0b100000;
        const FLAG_FLAGS			 = 0b1000000;
    }
}


/// A builder for `VkPhysicalDeviceImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceImageFormatInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceImageFormatInfo2KhrFlags,
}

impl<'b> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceImageFormatInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceImageFormatInfo2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceImageFormatInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.format = format.into();
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FORMAT;
        self
    }

    pub fn type_of<'m>(mut self, type_of: ImageType) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.type_ = type_of.into();
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TYPE_;
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.tiling = tiling.into();
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TILING;
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_USAGE;
        self
    }

    pub fn flags<'m>(mut self, flags: ImageCreateFlags) -> PhysicalDeviceImageFormatInfo2KhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FLAGS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_PNEXT != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FORMAT != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ImageType> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TYPE_ != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_tiling<'a>(&'a self) -> Option<ImageTiling> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TILING != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_TILING { return None }
        Some( self.raw.tiling.into() )
    }

    pub fn get_usage<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_USAGE != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_USAGE { return None }
        Some( ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceImageFormatInfo2Khr::usage: error converting flags") )
    }

    pub fn get_flags<'a>(&'a self) -> Option<ImageCreateFlags> {
        if self.set_mask & PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FLAGS != PhysicalDeviceImageFormatInfo2KhrFlags::FLAG_FLAGS { return None }
        Some( ImageCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceImageFormatInfo2Khr::flags: error converting flags") )
    }

    pub fn build(self) -> PhysicalDeviceImageFormatInfo2Khr<'b> {
        PhysicalDeviceImageFormatInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkQueueFamilyProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct QueueFamilyProperties2Khr<'s> {
    raw: vks::VkQueueFamilyProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> QueueFamilyProperties2Khr<'s> {
    pub fn builder<'b>() -> QueueFamilyProperties2KhrBuilder<'b> {
        QueueFamilyProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkQueueFamilyProperties2KHR) -> QueueFamilyProperties2Khr<'s> {
        QueueFamilyProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn queue_family_properties<'a>(&'a self) -> &'a QueueFamilyProperties {
         unsafe { &*(&self.raw.queueFamilyProperties as *const vks::VkQueueFamilyProperties as *const QueueFamilyProperties) }
    }

    pub fn queue_family_properties_mut<'a>(&'a mut self) -> &'a mut QueueFamilyProperties {
        unsafe { &mut *(&mut self.raw.queueFamilyProperties as *mut  vks::VkQueueFamilyProperties as *mut QueueFamilyProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_queue_family_properties<'m>(&mut self, queue_family_properties: QueueFamilyProperties) {
        self.raw.queueFamilyProperties = queue_family_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkQueueFamilyProperties2KHR {
        &self.raw
    }
}

impl<'s> From<QueueFamilyProperties2Khr<'s>> for vks::VkQueueFamilyProperties2KHR {
    fn from(f: QueueFamilyProperties2Khr<'s>) -> vks::VkQueueFamilyProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkQueueFamilyProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct QueueFamilyProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_QUEUEFAMILYPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkQueueFamilyProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct QueueFamilyProperties2KhrBuilder<'b> {
    raw: vks::VkQueueFamilyProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: QueueFamilyProperties2KhrFlags,
}

impl<'b> QueueFamilyProperties2KhrBuilder<'b> {
    pub fn new() -> QueueFamilyProperties2KhrBuilder<'b> {
        QueueFamilyProperties2KhrBuilder {
            raw: vks::VkQueueFamilyProperties2KHR::default(),
            _p: PhantomData,
            set_mask: QueueFamilyProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> QueueFamilyProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= QueueFamilyProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn queue_family_properties<'m>(mut self, queue_family_properties: QueueFamilyProperties) -> QueueFamilyProperties2KhrBuilder<'b> {
        self.raw.queueFamilyProperties = queue_family_properties.raw;
        self.set_mask |= QueueFamilyProperties2KhrFlags::FLAG_QUEUEFAMILYPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & QueueFamilyProperties2KhrFlags::FLAG_PNEXT != QueueFamilyProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_queue_family_properties<'a>(&'a self) -> Option<&'a QueueFamilyProperties> {
        if self.set_mask & QueueFamilyProperties2KhrFlags::FLAG_QUEUEFAMILYPROPERTIES != QueueFamilyProperties2KhrFlags::FLAG_QUEUEFAMILYPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.queueFamilyProperties as *const vks::VkQueueFamilyProperties as *const QueueFamilyProperties) } )
    }

    pub fn get_queue_family_properties_mut<'a>(&'a mut self) -> Option<&'a mut QueueFamilyProperties> {
        if self.set_mask & QueueFamilyProperties2KhrFlags::FLAG_QUEUEFAMILYPROPERTIES != QueueFamilyProperties2KhrFlags::FLAG_QUEUEFAMILYPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.queueFamilyProperties as *mut  vks::VkQueueFamilyProperties as *mut QueueFamilyProperties) } )
    }

    pub fn build(self) -> QueueFamilyProperties2Khr<'b> {
        QueueFamilyProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMemoryProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMemoryProperties2Khr<'s> {
    raw: vks::VkPhysicalDeviceMemoryProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceMemoryProperties2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        PhysicalDeviceMemoryProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMemoryProperties2KHR) -> PhysicalDeviceMemoryProperties2Khr<'s> {
        PhysicalDeviceMemoryProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_properties<'a>(&'a self) -> &'a PhysicalDeviceMemoryProperties {
         unsafe { &*(&self.raw.memoryProperties as *const vks::VkPhysicalDeviceMemoryProperties as *const PhysicalDeviceMemoryProperties) }
    }

    pub fn memory_properties_mut<'a>(&'a mut self) -> &'a mut PhysicalDeviceMemoryProperties {
        unsafe { &mut *(&mut self.raw.memoryProperties as *mut  vks::VkPhysicalDeviceMemoryProperties as *mut PhysicalDeviceMemoryProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_properties<'m>(&mut self, memory_properties: PhysicalDeviceMemoryProperties) {
        self.raw.memoryProperties = memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMemoryProperties2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceMemoryProperties2Khr<'s>> for vks::VkPhysicalDeviceMemoryProperties2KHR {
    fn from(f: PhysicalDeviceMemoryProperties2Khr<'s>) -> vks::VkPhysicalDeviceMemoryProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceMemoryProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceMemoryProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORYPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceMemoryProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceMemoryProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceMemoryProperties2KhrFlags,
}

impl<'b> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        PhysicalDeviceMemoryProperties2KhrBuilder {
            raw: vks::VkPhysicalDeviceMemoryProperties2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceMemoryProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceMemoryProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory_properties<'m>(mut self, memory_properties: PhysicalDeviceMemoryProperties) -> PhysicalDeviceMemoryProperties2KhrBuilder<'b> {
        self.raw.memoryProperties = memory_properties.raw;
        self.set_mask |= PhysicalDeviceMemoryProperties2KhrFlags::FLAG_MEMORYPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceMemoryProperties2KhrFlags::FLAG_PNEXT != PhysicalDeviceMemoryProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory_properties<'a>(&'a self) -> Option<&'a PhysicalDeviceMemoryProperties> {
        if self.set_mask & PhysicalDeviceMemoryProperties2KhrFlags::FLAG_MEMORYPROPERTIES != PhysicalDeviceMemoryProperties2KhrFlags::FLAG_MEMORYPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.memoryProperties as *const vks::VkPhysicalDeviceMemoryProperties as *const PhysicalDeviceMemoryProperties) } )
    }

    pub fn get_memory_properties_mut<'a>(&'a mut self) -> Option<&'a mut PhysicalDeviceMemoryProperties> {
        if self.set_mask & PhysicalDeviceMemoryProperties2KhrFlags::FLAG_MEMORYPROPERTIES != PhysicalDeviceMemoryProperties2KhrFlags::FLAG_MEMORYPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.memoryProperties as *mut  vks::VkPhysicalDeviceMemoryProperties as *mut PhysicalDeviceMemoryProperties) } )
    }

    pub fn build(self) -> PhysicalDeviceMemoryProperties2Khr<'b> {
        PhysicalDeviceMemoryProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageFormatProperties2Khr<'s> {
    raw: vks::VkSparseImageFormatProperties2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageFormatProperties2Khr<'s> {
    pub fn builder<'b>() -> SparseImageFormatProperties2KhrBuilder<'b> {
        SparseImageFormatProperties2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageFormatProperties2KHR) -> SparseImageFormatProperties2Khr<'s> {
        SparseImageFormatProperties2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn properties<'a>(&'a self) -> &'a SparseImageFormatProperties {
         unsafe { &*(&self.raw.properties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) }
    }

    pub fn properties_mut<'a>(&'a mut self) -> &'a mut SparseImageFormatProperties {
        unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_properties<'m>(&mut self, properties: SparseImageFormatProperties) {
        self.raw.properties = properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageFormatProperties2KHR {
        &self.raw
    }
}

impl<'s> From<SparseImageFormatProperties2Khr<'s>> for vks::VkSparseImageFormatProperties2KHR {
    fn from(f: SparseImageFormatProperties2Khr<'s>) -> vks::VkSparseImageFormatProperties2KHR {
        f.raw
    }
}


/// Bitflags for `VkSparseImageFormatProperties2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageFormatProperties2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PROPERTIES			 = 0b100;
    }
}


/// A builder for `VkSparseImageFormatProperties2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageFormatProperties2KhrBuilder<'b> {
    raw: vks::VkSparseImageFormatProperties2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SparseImageFormatProperties2KhrFlags,
}

impl<'b> SparseImageFormatProperties2KhrBuilder<'b> {
    pub fn new() -> SparseImageFormatProperties2KhrBuilder<'b> {
        SparseImageFormatProperties2KhrBuilder {
            raw: vks::VkSparseImageFormatProperties2KHR::default(),
            _p: PhantomData,
            set_mask: SparseImageFormatProperties2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SparseImageFormatProperties2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SparseImageFormatProperties2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn properties<'m>(mut self, properties: SparseImageFormatProperties) -> SparseImageFormatProperties2KhrBuilder<'b> {
        self.raw.properties = properties.raw;
        self.set_mask |= SparseImageFormatProperties2KhrFlags::FLAG_PROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SparseImageFormatProperties2KhrFlags::FLAG_PNEXT != SparseImageFormatProperties2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_properties<'a>(&'a self) -> Option<&'a SparseImageFormatProperties> {
        if self.set_mask & SparseImageFormatProperties2KhrFlags::FLAG_PROPERTIES != SparseImageFormatProperties2KhrFlags::FLAG_PROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.properties as *const vks::VkSparseImageFormatProperties as *const SparseImageFormatProperties) } )
    }

    pub fn get_properties_mut<'a>(&'a mut self) -> Option<&'a mut SparseImageFormatProperties> {
        if self.set_mask & SparseImageFormatProperties2KhrFlags::FLAG_PROPERTIES != SparseImageFormatProperties2KhrFlags::FLAG_PROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.properties as *mut  vks::VkSparseImageFormatProperties as *mut SparseImageFormatProperties) } )
    }

    pub fn build(self) -> SparseImageFormatProperties2Khr<'b> {
        SparseImageFormatProperties2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSparseImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceSparseImageFormatInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR) -> PhysicalDeviceSparseImageFormatInfo2Khr<'s> {
        PhysicalDeviceSparseImageFormatInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn format<'a>(&'a self) -> Format {
        self.raw.format.into()
    }

    pub fn type_of<'a>(&'a self) -> ImageType {
        self.raw.type_.into()
    }

    pub fn samples<'a>(&'a self) -> SampleCountFlags {
        SampleCountFlags::from_bits(self.raw.samples)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::samples: error converting flags")
    }

    pub fn usage<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::usage: error converting flags")
    }

    pub fn tiling<'a>(&'a self) -> ImageTiling {
        self.raw.tiling.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_format<'m>(&mut self, format: Format) {
        self.raw.format = format.into();
    }

    pub fn set_type_of<'m>(&mut self, type_of: ImageType) {
        self.raw.type_ = type_of.into();
    }

    pub fn set_samples<'m>(&mut self, samples: SampleCountFlags) {
        self.raw.samples = samples.bits();
    }

    pub fn set_usage<'m>(&mut self, usage: ImageUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_tiling<'m>(&mut self, tiling: ImageTiling) {
        self.raw.tiling = tiling.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSparseImageFormatInfo2Khr<'s>> for vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
    fn from(f: PhysicalDeviceSparseImageFormatInfo2Khr<'s>) -> vks::VkPhysicalDeviceSparseImageFormatInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceSparseImageFormatInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceSparseImageFormatInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FORMAT			 = 0b100;
        const FLAG_TYPE_			 = 0b1000;
        const FLAG_SAMPLES			 = 0b10000;
        const FLAG_USAGE			 = 0b100000;
        const FLAG_TILING			 = 0b1000000;
    }
}


/// A builder for `VkPhysicalDeviceSparseImageFormatInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceSparseImageFormatInfo2KhrFlags,
}

impl<'b> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        PhysicalDeviceSparseImageFormatInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceSparseImageFormatInfo2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceSparseImageFormatInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn format<'m>(mut self, format: Format) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.format = format.into();
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_FORMAT;
        self
    }

    pub fn type_of<'m>(mut self, type_of: ImageType) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.type_ = type_of.into();
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TYPE_;
        self
    }

    pub fn samples<'m>(mut self, samples: SampleCountFlags) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.samples = samples.bits();
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_SAMPLES;
        self
    }

    pub fn usage<'m>(mut self, usage: ImageUsageFlags) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_USAGE;
        self
    }

    pub fn tiling<'m>(mut self, tiling: ImageTiling) -> PhysicalDeviceSparseImageFormatInfo2KhrBuilder<'b> {
        self.raw.tiling = tiling.into();
        self.set_mask |= PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TILING;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_PNEXT != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_format<'a>(&'a self) -> Option<Format> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_FORMAT != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_FORMAT { return None }
        Some( self.raw.format.into() )
    }

    pub fn get_type_of<'a>(&'a self) -> Option<ImageType> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TYPE_ != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TYPE_ { return None }
        Some( self.raw.type_.into() )
    }

    pub fn get_samples<'a>(&'a self) -> Option<SampleCountFlags> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_SAMPLES != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_SAMPLES { return None }
        Some( SampleCountFlags::from_bits(self.raw.samples)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::samples: error converting flags") )
    }

    pub fn get_usage<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_USAGE != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_USAGE { return None }
        Some( ImageUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceSparseImageFormatInfo2Khr::usage: error converting flags") )
    }

    pub fn get_tiling<'a>(&'a self) -> Option<ImageTiling> {
        if self.set_mask & PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TILING != PhysicalDeviceSparseImageFormatInfo2KhrFlags::FLAG_TILING { return None }
        Some( self.raw.tiling.into() )
    }

    pub fn build(self) -> PhysicalDeviceSparseImageFormatInfo2Khr<'b> {
        PhysicalDeviceSparseImageFormatInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDevicePushDescriptorPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDevicePushDescriptorPropertiesKhr<'s> {
    raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDevicePushDescriptorPropertiesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        PhysicalDevicePushDescriptorPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR) -> PhysicalDevicePushDescriptorPropertiesKhr<'s> {
        PhysicalDevicePushDescriptorPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_push_descriptors<'a>(&'a self) -> u32 {
        self.raw.maxPushDescriptors.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_push_descriptors<'m>(&mut self, max_push_descriptors: u32) {
        self.raw.maxPushDescriptors = max_push_descriptors.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDevicePushDescriptorPropertiesKhr<'s>> for vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
    fn from(f: PhysicalDevicePushDescriptorPropertiesKhr<'s>) -> vks::VkPhysicalDevicePushDescriptorPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDevicePushDescriptorPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDevicePushDescriptorPropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MAXPUSHDESCRIPTORS			 = 0b100;
    }
}


/// A builder for `VkPhysicalDevicePushDescriptorPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
    raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDevicePushDescriptorPropertiesKhrFlags,
}

impl<'b> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
    pub fn new() -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        PhysicalDevicePushDescriptorPropertiesKhrBuilder {
            raw: vks::VkPhysicalDevicePushDescriptorPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDevicePushDescriptorPropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn max_push_descriptors<'m>(mut self, max_push_descriptors: u32) -> PhysicalDevicePushDescriptorPropertiesKhrBuilder<'b> {
        self.raw.maxPushDescriptors = max_push_descriptors.into();
        self.set_mask |= PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_MAXPUSHDESCRIPTORS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_PNEXT != PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_max_push_descriptors<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_MAXPUSHDESCRIPTORS != PhysicalDevicePushDescriptorPropertiesKhrFlags::FLAG_MAXPUSHDESCRIPTORS { return None }
        Some( self.raw.maxPushDescriptors.into() )
    }

    pub fn build(self) -> PhysicalDevicePushDescriptorPropertiesKhr<'b> {
        PhysicalDevicePushDescriptorPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentRegionsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentRegionsKhr<'s> {
    raw: vks::VkPresentRegionsKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentRegionsKhr<'s> {
    pub fn builder<'b>() -> PresentRegionsKhrBuilder<'b> {
        PresentRegionsKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentRegionsKHR) -> PresentRegionsKhr<'s> {
        PresentRegionsKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn regions<'a>(&'a self) -> &'a [PresentRegionKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRegions as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_regions<'m, 'a>(&mut self, regions: &'a [PresentRegionKhr])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == regions.len() as _, 
            "count inconsistency found when specifying `PresentRegionsKhr::regions`.");
        self.raw.swapchainCount = regions.len() as _;
        self.raw.pRegions = regions.as_ptr() as *const vks::VkPresentRegionKHR;
    }

    pub fn as_raw(&self) -> &vks::VkPresentRegionsKHR {
        &self.raw
    }
}

impl<'s> From<PresentRegionsKhr<'s>> for vks::VkPresentRegionsKHR {
    fn from(f: PresentRegionsKhr<'s>) -> vks::VkPresentRegionsKHR {
        f.raw
    }
}


/// Bitflags for `VkPresentRegionsKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PresentRegionsKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SWAPCHAINCOUNT			 = 0b100;
        const FLAG_PREGIONS			 = 0b1000;
    }
}


/// A builder for `VkPresentRegionsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentRegionsKhrBuilder<'b> {
    raw: vks::VkPresentRegionsKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PresentRegionsKhrFlags,
}

impl<'b> PresentRegionsKhrBuilder<'b> {
    pub fn new() -> PresentRegionsKhrBuilder<'b> {
        PresentRegionsKhrBuilder {
            raw: vks::VkPresentRegionsKHR::default(),
            _p: PhantomData,
            set_mask: PresentRegionsKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentRegionsKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PresentRegionsKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn regions<'m, 'a>(mut self, regions: &'a [PresentRegionKhr]) -> PresentRegionsKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == regions.len() as _, 
            "count inconsistency found when specifying `PresentRegionsKhr::regions`.");
        self.raw.swapchainCount = regions.len() as _;
        self.set_mask |= PresentRegionsKhrFlags::FLAG_SWAPCHAINCOUNT;
        self.raw.pRegions = regions.as_ptr() as *const vks::VkPresentRegionKHR;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PresentRegionsKhrFlags::FLAG_PNEXT != PresentRegionsKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_regions<'a>(&'a self) -> Option<&'a [PresentRegionKhr]> {
        if self.raw.pRegions.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pRegions as *const _, self.raw.swapchainCount as usize) } )
    }

    pub fn build(self) -> PresentRegionsKhr<'b> {
        PresentRegionsKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentRegionKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentRegionKhr<'s> {
    raw: vks::VkPresentRegionKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentRegionKhr<'s> {
    pub fn builder<'b>() -> PresentRegionKhrBuilder<'b> {
        PresentRegionKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentRegionKHR) -> PresentRegionKhr<'s> {
        PresentRegionKhr { raw, _p: PhantomData }
    }

    pub fn rectangles<'a>(&'a self) -> &'a [RectLayerKhr] {
        unsafe { slice::from_raw_parts(self.raw.pRectangles as *const _, self.raw.rectangleCount as usize) }
    }

    pub fn set_rectangles<'m, 'a>(&mut self, rectangles: &'a [RectLayerKhr])
            where 'a: 's {
        assert!(self.raw.rectangleCount == 0 || self.raw.rectangleCount == rectangles.len() as _, 
            "count inconsistency found when specifying `PresentRegionKhr::rectangles`.");
        self.raw.rectangleCount = rectangles.len() as _;
        self.raw.pRectangles = rectangles.as_ptr() as *const vks::VkRectLayerKHR;
    }

    pub fn as_raw(&self) -> &vks::VkPresentRegionKHR {
        &self.raw
    }
}

impl<'s> From<PresentRegionKhr<'s>> for vks::VkPresentRegionKHR {
    fn from(f: PresentRegionKhr<'s>) -> vks::VkPresentRegionKHR {
        f.raw
    }
}


/// Bitflags for `VkPresentRegionKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PresentRegionKhrFlags: u32 {
        const FLAG_RECTANGLECOUNT			 = 0b1;
        const FLAG_PRECTANGLES			 = 0b10;
    }
}


/// A builder for `VkPresentRegionKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentRegionKhrBuilder<'b> {
    raw: vks::VkPresentRegionKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PresentRegionKhrFlags,
}

impl<'b> PresentRegionKhrBuilder<'b> {
    pub fn new() -> PresentRegionKhrBuilder<'b> {
        PresentRegionKhrBuilder {
            raw: vks::VkPresentRegionKHR::default(),
            _p: PhantomData,
            set_mask: PresentRegionKhrFlags::default(),
        }
    }

    pub fn rectangles<'m, 'a>(mut self, rectangles: &'a [RectLayerKhr]) -> PresentRegionKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.rectangleCount == 0 || self.raw.rectangleCount == rectangles.len() as _, 
            "count inconsistency found when specifying `PresentRegionKhr::rectangles`.");
        self.raw.rectangleCount = rectangles.len() as _;
        self.set_mask |= PresentRegionKhrFlags::FLAG_RECTANGLECOUNT;
        self.raw.pRectangles = rectangles.as_ptr() as *const vks::VkRectLayerKHR;
        self
    }

    pub fn get_rectangles<'a>(&'a self) -> Option<&'a [RectLayerKhr]> {
        if self.raw.pRectangles.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pRectangles as *const _, self.raw.rectangleCount as usize) } )
    }

    pub fn build(self) -> PresentRegionKhr<'b> {
        PresentRegionKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRectLayerKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RectLayerKhr {
    raw: vks::VkRectLayerKHR,
}

impl RectLayerKhr {
    pub fn builder() -> RectLayerKhrBuilder {
        RectLayerKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRectLayerKHR) -> RectLayerKhr {
        RectLayerKhr { raw, }
    }

    pub fn offset<'a>(&'a self) -> &'a Offset2d {
         unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) }
    }

    pub fn offset_mut<'a>(&'a mut self) -> &'a mut Offset2d {
        unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) }
    }

    pub fn extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn layer<'a>(&'a self) -> u32 {
        self.raw.layer.into()
    }

    pub fn set_offset<'m>(&mut self, offset: Offset2d) {
        self.raw.offset = offset.raw;
    }

    pub fn set_extent<'m>(&mut self, extent: Extent2d) {
        self.raw.extent = extent.raw;
    }

    pub fn set_layer<'m>(&mut self, layer: u32) {
        self.raw.layer = layer.into();
    }

    pub fn as_raw(&self) -> &vks::VkRectLayerKHR {
        &self.raw
    }
}

impl From<RectLayerKhr> for vks::VkRectLayerKHR {
    fn from(f: RectLayerKhr) -> vks::VkRectLayerKHR {
        f.raw
    }
}


/// Bitflags for `VkRectLayerKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct RectLayerKhrFlags: u32 {
        const FLAG_OFFSET			 = 0b1;
        const FLAG_EXTENT			 = 0b10;
        const FLAG_LAYER			 = 0b100;
    }
}


/// A builder for `VkRectLayerKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RectLayerKhrBuilder {
    raw: vks::VkRectLayerKHR,
    set_mask: RectLayerKhrFlags,
}

impl RectLayerKhrBuilder {
    pub fn new() -> RectLayerKhrBuilder {
        RectLayerKhrBuilder {
            raw: vks::VkRectLayerKHR::default(),
            set_mask: RectLayerKhrFlags::default(),
        }
    }

    pub fn offset<'m>(mut self, offset: Offset2d) -> RectLayerKhrBuilder {
        self.raw.offset = offset.raw;
        self.set_mask |= RectLayerKhrFlags::FLAG_OFFSET;
        self
    }

    pub fn extent<'m>(mut self, extent: Extent2d) -> RectLayerKhrBuilder {
        self.raw.extent = extent.raw;
        self.set_mask |= RectLayerKhrFlags::FLAG_EXTENT;
        self
    }

    pub fn layer<'m>(mut self, layer: u32) -> RectLayerKhrBuilder {
        self.raw.layer = layer.into();
        self.set_mask |= RectLayerKhrFlags::FLAG_LAYER;
        self
    }

    pub fn get_offset<'a>(&'a self) -> Option<&'a Offset2d> {
        if self.set_mask & RectLayerKhrFlags::FLAG_OFFSET != RectLayerKhrFlags::FLAG_OFFSET { return None }
        Some(  unsafe { &*(&self.raw.offset as *const vks::VkOffset2D as *const Offset2d) } )
    }

    pub fn get_offset_mut<'a>(&'a mut self) -> Option<&'a mut Offset2d> {
        if self.set_mask & RectLayerKhrFlags::FLAG_OFFSET != RectLayerKhrFlags::FLAG_OFFSET { return None }
        Some( unsafe { &mut *(&mut self.raw.offset as *mut  vks::VkOffset2D as *mut Offset2d) } )
    }

    pub fn get_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & RectLayerKhrFlags::FLAG_EXTENT != RectLayerKhrFlags::FLAG_EXTENT { return None }
        Some(  unsafe { &*(&self.raw.extent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & RectLayerKhrFlags::FLAG_EXTENT != RectLayerKhrFlags::FLAG_EXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.extent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_layer<'a>(&'a self) -> Option<u32> {
        if self.set_mask & RectLayerKhrFlags::FLAG_LAYER != RectLayerKhrFlags::FLAG_LAYER { return None }
        Some( self.raw.layer.into() )
    }

    pub fn build(self) -> RectLayerKhr {
        RectLayerKhr {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceVariablePointerFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceVariablePointerFeaturesKhr<'s> {
    raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceVariablePointerFeaturesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        PhysicalDeviceVariablePointerFeaturesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR) -> PhysicalDeviceVariablePointerFeaturesKhr<'s> {
        PhysicalDeviceVariablePointerFeaturesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn variable_pointers_storage_buffer<'a>(&'a self) -> bool {
        self.raw.variablePointersStorageBuffer != 0
    }

    pub fn variable_pointers<'a>(&'a self) -> bool {
        self.raw.variablePointers != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_variable_pointers_storage_buffer<'m>(&mut self, variable_pointers_storage_buffer: bool) {
        self.raw.variablePointersStorageBuffer = variable_pointers_storage_buffer as u32;
    }

    pub fn set_variable_pointers<'m>(&mut self, variable_pointers: bool) {
        self.raw.variablePointers = variable_pointers as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceVariablePointerFeaturesKhr<'s>> for vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
    fn from(f: PhysicalDeviceVariablePointerFeaturesKhr<'s>) -> vks::VkPhysicalDeviceVariablePointerFeaturesKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceVariablePointerFeaturesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceVariablePointerFeaturesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_VARIABLEPOINTERSSTORAGEBUFFER			 = 0b100;
        const FLAG_VARIABLEPOINTERS			 = 0b1000;
    }
}


/// A builder for `VkPhysicalDeviceVariablePointerFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceVariablePointerFeaturesKhrFlags,
}

impl<'b> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        PhysicalDeviceVariablePointerFeaturesKhrBuilder {
            raw: vks::VkPhysicalDeviceVariablePointerFeaturesKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceVariablePointerFeaturesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn variable_pointers_storage_buffer<'m>(mut self, variable_pointers_storage_buffer: bool) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.variablePointersStorageBuffer = variable_pointers_storage_buffer as u32;
        self.set_mask |= PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERSSTORAGEBUFFER;
        self
    }

    pub fn variable_pointers<'m>(mut self, variable_pointers: bool) -> PhysicalDeviceVariablePointerFeaturesKhrBuilder<'b> {
        self.raw.variablePointers = variable_pointers as u32;
        self.set_mask |= PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_PNEXT != PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_variable_pointers_storage_buffer<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERSSTORAGEBUFFER != PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERSSTORAGEBUFFER { return None }
        Some( self.raw.variablePointersStorageBuffer != 0 )
    }

    pub fn get_variable_pointers<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERS != PhysicalDeviceVariablePointerFeaturesKhrFlags::FLAG_VARIABLEPOINTERS { return None }
        Some( self.raw.variablePointers != 0 )
    }

    pub fn build(self) -> PhysicalDeviceVariablePointerFeaturesKhr<'b> {
        PhysicalDeviceVariablePointerFeaturesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryPropertiesKhr {
    raw: vks::VkExternalMemoryPropertiesKHR,
}

impl ExternalMemoryPropertiesKhr {
    pub fn builder() -> ExternalMemoryPropertiesKhrBuilder {
        ExternalMemoryPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryPropertiesKHR) -> ExternalMemoryPropertiesKhr {
        ExternalMemoryPropertiesKhr { raw, }
    }

    pub fn external_memory_features<'a>(&'a self) -> ExternalMemoryFeatureFlagsKhr {
        ExternalMemoryFeatureFlagsKhr::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalMemoryPropertiesKhr::external_memory_features: error converting flags")
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn set_external_memory_features<'m>(&mut self, external_memory_features: ExternalMemoryFeatureFlagsKhr) {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryPropertiesKHR {
        &self.raw
    }
}

impl From<ExternalMemoryPropertiesKhr> for vks::VkExternalMemoryPropertiesKHR {
    fn from(f: ExternalMemoryPropertiesKhr) -> vks::VkExternalMemoryPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalMemoryPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalMemoryPropertiesKhrFlags: u32 {
        const FLAG_EXTERNALMEMORYFEATURES			 = 0b1;
        const FLAG_EXPORTFROMIMPORTEDHANDLETYPES			 = 0b10;
        const FLAG_COMPATIBLEHANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExternalMemoryPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryPropertiesKhrBuilder {
    raw: vks::VkExternalMemoryPropertiesKHR,
    set_mask: ExternalMemoryPropertiesKhrFlags,
}

impl ExternalMemoryPropertiesKhrBuilder {
    pub fn new() -> ExternalMemoryPropertiesKhrBuilder {
        ExternalMemoryPropertiesKhrBuilder {
            raw: vks::VkExternalMemoryPropertiesKHR::default(),
            set_mask: ExternalMemoryPropertiesKhrFlags::default(),
        }
    }

    pub fn external_memory_features<'m>(mut self, external_memory_features: ExternalMemoryFeatureFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.externalMemoryFeatures = external_memory_features.bits();
        self.set_mask |= ExternalMemoryPropertiesKhrFlags::FLAG_EXTERNALMEMORYFEATURES;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self.set_mask |= ExternalMemoryPropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES;
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryPropertiesKhrBuilder {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self.set_mask |= ExternalMemoryPropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES;
        self
    }

    pub fn get_external_memory_features<'a>(&'a self) -> Option<ExternalMemoryFeatureFlagsKhr> {
        if self.set_mask & ExternalMemoryPropertiesKhrFlags::FLAG_EXTERNALMEMORYFEATURES != ExternalMemoryPropertiesKhrFlags::FLAG_EXTERNALMEMORYFEATURES { return None }
        Some( ExternalMemoryFeatureFlagsKhr::from_bits(self.raw.externalMemoryFeatures)
            .expect("ExternalMemoryPropertiesKhr::external_memory_features: error converting flags") )
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ExternalMemoryPropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES != ExternalMemoryPropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::export_from_imported_handle_types: error converting flags") )
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ExternalMemoryPropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES != ExternalMemoryPropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalMemoryPropertiesKhr::compatible_handle_types: error converting flags") )
    }

    pub fn build(self) -> ExternalMemoryPropertiesKhr {
        ExternalMemoryPropertiesKhr {
            raw: self.raw,
        }
    }
}


/// A `VkPhysicalDeviceExternalImageFormatInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalImageFormatInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalImageFormatInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        PhysicalDeviceExternalImageFormatInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR) -> PhysicalDeviceExternalImageFormatInfoKhr<'s> {
        PhysicalDeviceExternalImageFormatInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalImageFormatInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalImageFormatInfoKhr<'s>> for vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
    fn from(f: PhysicalDeviceExternalImageFormatInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalImageFormatInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceExternalImageFormatInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceExternalImageFormatInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceExternalImageFormatInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceExternalImageFormatInfoKhrFlags,
}

impl<'b> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        PhysicalDeviceExternalImageFormatInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalImageFormatInfoKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceExternalImageFormatInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> PhysicalDeviceExternalImageFormatInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_PNEXT != PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_HANDLETYPE != PhysicalDeviceExternalImageFormatInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalImageFormatInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> PhysicalDeviceExternalImageFormatInfoKhr<'b> {
        PhysicalDeviceExternalImageFormatInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalImageFormatPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalImageFormatPropertiesKhr<'s> {
    raw: vks::VkExternalImageFormatPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalImageFormatPropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        ExternalImageFormatPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalImageFormatPropertiesKHR) -> ExternalImageFormatPropertiesKhr<'s> {
        ExternalImageFormatPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
         unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_external_memory_properties<'m>(&mut self, external_memory_properties: ExternalMemoryPropertiesKhr) {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkExternalImageFormatPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalImageFormatPropertiesKhr<'s>> for vks::VkExternalImageFormatPropertiesKHR {
    fn from(f: ExternalImageFormatPropertiesKhr<'s>) -> vks::VkExternalImageFormatPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalImageFormatPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalImageFormatPropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_EXTERNALMEMORYPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkExternalImageFormatPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalImageFormatPropertiesKhrBuilder<'b> {
    raw: vks::VkExternalImageFormatPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalImageFormatPropertiesKhrFlags,
}

impl<'b> ExternalImageFormatPropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        ExternalImageFormatPropertiesKhrBuilder {
            raw: vks::VkExternalImageFormatPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: ExternalImageFormatPropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalImageFormatPropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn external_memory_properties<'m>(mut self, external_memory_properties: ExternalMemoryPropertiesKhr) -> ExternalImageFormatPropertiesKhrBuilder<'b> {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
        self.set_mask |= ExternalImageFormatPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ExternalImageFormatPropertiesKhrFlags::FLAG_PNEXT != ExternalImageFormatPropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_external_memory_properties<'a>(&'a self) -> Option<&'a ExternalMemoryPropertiesKhr> {
        if self.set_mask & ExternalImageFormatPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES != ExternalImageFormatPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) } )
    }

    pub fn get_external_memory_properties_mut<'a>(&'a mut self) -> Option<&'a mut ExternalMemoryPropertiesKhr> {
        if self.set_mask & ExternalImageFormatPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES != ExternalImageFormatPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) } )
    }

    pub fn build(self) -> ExternalImageFormatPropertiesKhr<'b> {
        ExternalImageFormatPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalBufferInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalBufferInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalBufferInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalBufferInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        PhysicalDeviceExternalBufferInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalBufferInfoKHR) -> PhysicalDeviceExternalBufferInfoKhr<'s> {
        PhysicalDeviceExternalBufferInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> BufferCreateFlags {
        BufferCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceExternalBufferInfoKhr::flags: error converting flags")
    }

    pub fn usage<'a>(&'a self) -> BufferUsageFlags {
        BufferUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceExternalBufferInfoKhr::usage: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalBufferInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: BufferCreateFlags) {
        self.raw.flags = flags.bits();
    }

    pub fn set_usage<'m>(&mut self, usage: BufferUsageFlags) {
        self.raw.usage = usage.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalBufferInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalBufferInfoKhr<'s>> for vks::VkPhysicalDeviceExternalBufferInfoKHR {
    fn from(f: PhysicalDeviceExternalBufferInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalBufferInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceExternalBufferInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceExternalBufferInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_USAGE			 = 0b1000;
        const FLAG_HANDLETYPE			 = 0b10000;
    }
}


/// A builder for `VkPhysicalDeviceExternalBufferInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalBufferInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceExternalBufferInfoKhrFlags,
}

impl<'b> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        PhysicalDeviceExternalBufferInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalBufferInfoKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceExternalBufferInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: BufferCreateFlags) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn usage<'m>(mut self, usage: BufferUsageFlags) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.usage = usage.bits();
        self.set_mask |= PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_USAGE;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> PhysicalDeviceExternalBufferInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_PNEXT != PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<BufferCreateFlags> {
        if self.set_mask & PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_FLAGS != PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_FLAGS { return None }
        Some( BufferCreateFlags::from_bits(self.raw.flags)
            .expect("PhysicalDeviceExternalBufferInfoKhr::flags: error converting flags") )
    }

    pub fn get_usage<'a>(&'a self) -> Option<BufferUsageFlags> {
        if self.set_mask & PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_USAGE != PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_USAGE { return None }
        Some( BufferUsageFlags::from_bits(self.raw.usage)
            .expect("PhysicalDeviceExternalBufferInfoKhr::usage: error converting flags") )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_HANDLETYPE != PhysicalDeviceExternalBufferInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalBufferInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> PhysicalDeviceExternalBufferInfoKhr<'b> {
        PhysicalDeviceExternalBufferInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalBufferPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalBufferPropertiesKhr<'s> {
    raw: vks::VkExternalBufferPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalBufferPropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalBufferPropertiesKhrBuilder<'b> {
        ExternalBufferPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalBufferPropertiesKHR) -> ExternalBufferPropertiesKhr<'s> {
        ExternalBufferPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn external_memory_properties<'a>(&'a self) -> &'a ExternalMemoryPropertiesKhr {
         unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) }
    }

    pub fn external_memory_properties_mut<'a>(&'a mut self) -> &'a mut ExternalMemoryPropertiesKhr {
        unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_external_memory_properties<'m>(&mut self, external_memory_properties: ExternalMemoryPropertiesKhr) {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
    }

    pub fn as_raw(&self) -> &vks::VkExternalBufferPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalBufferPropertiesKhr<'s>> for vks::VkExternalBufferPropertiesKHR {
    fn from(f: ExternalBufferPropertiesKhr<'s>) -> vks::VkExternalBufferPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalBufferPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalBufferPropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_EXTERNALMEMORYPROPERTIES			 = 0b100;
    }
}


/// A builder for `VkExternalBufferPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalBufferPropertiesKhrBuilder<'b> {
    raw: vks::VkExternalBufferPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalBufferPropertiesKhrFlags,
}

impl<'b> ExternalBufferPropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalBufferPropertiesKhrBuilder<'b> {
        ExternalBufferPropertiesKhrBuilder {
            raw: vks::VkExternalBufferPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: ExternalBufferPropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalBufferPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalBufferPropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn external_memory_properties<'m>(mut self, external_memory_properties: ExternalMemoryPropertiesKhr) -> ExternalBufferPropertiesKhrBuilder<'b> {
        self.raw.externalMemoryProperties = external_memory_properties.raw;
        self.set_mask |= ExternalBufferPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ExternalBufferPropertiesKhrFlags::FLAG_PNEXT != ExternalBufferPropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_external_memory_properties<'a>(&'a self) -> Option<&'a ExternalMemoryPropertiesKhr> {
        if self.set_mask & ExternalBufferPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES != ExternalBufferPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES { return None }
        Some(  unsafe { &*(&self.raw.externalMemoryProperties as *const vks::VkExternalMemoryPropertiesKHR as *const ExternalMemoryPropertiesKhr) } )
    }

    pub fn get_external_memory_properties_mut<'a>(&'a mut self) -> Option<&'a mut ExternalMemoryPropertiesKhr> {
        if self.set_mask & ExternalBufferPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES != ExternalBufferPropertiesKhrFlags::FLAG_EXTERNALMEMORYPROPERTIES { return None }
        Some( unsafe { &mut *(&mut self.raw.externalMemoryProperties as *mut  vks::VkExternalMemoryPropertiesKHR as *mut ExternalMemoryPropertiesKhr) } )
    }

    pub fn build(self) -> ExternalBufferPropertiesKhr<'b> {
        ExternalBufferPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceIDPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceIDPropertiesKhr<'s> {
    raw: vks::VkPhysicalDeviceIDPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceIDPropertiesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        PhysicalDeviceIDPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceIDPropertiesKHR) -> PhysicalDeviceIDPropertiesKhr<'s> {
        PhysicalDeviceIDPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn device_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn driver_uuid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.driverUUID as *const _, vks::VK_UUID_SIZE as usize) }
    }

    pub fn device_luid<'a>(&'a self) -> &[u8] {
        unsafe { slice::from_raw_parts(&self.raw.deviceLUID as *const _, vks::VK_LUID_SIZE_KHR as usize) }
    }

    pub fn device_node_mask<'a>(&'a self) -> u32 {
        self.raw.deviceNodeMask.into()
    }

    pub fn device_luid_valid<'a>(&'a self) -> bool {
        self.raw.deviceLUIDValid != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_device_uuid<'m>(&mut self, device_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.deviceUUID = device_uuid;
    }

    pub fn set_driver_uuid<'m>(&mut self, driver_uuid: [u8; vks::VK_UUID_SIZE]) {
        self.raw.driverUUID = driver_uuid;
    }

    pub fn set_device_luid<'m>(&mut self, device_luid: [u8; vks::VK_LUID_SIZE_KHR]) {
        self.raw.deviceLUID = device_luid;
    }

    pub fn set_device_node_mask<'m>(&mut self, device_node_mask: u32) {
        self.raw.deviceNodeMask = device_node_mask.into();
    }

    pub fn set_device_luid_valid<'m>(&mut self, device_luid_valid: bool) {
        self.raw.deviceLUIDValid = device_luid_valid as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceIDPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceIDPropertiesKhr<'s>> for vks::VkPhysicalDeviceIDPropertiesKHR {
    fn from(f: PhysicalDeviceIDPropertiesKhr<'s>) -> vks::VkPhysicalDeviceIDPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceIDPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceIDPropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DEVICEUUID			 = 0b100;
        const FLAG_DRIVERUUID			 = 0b1000;
        const FLAG_DEVICELUID			 = 0b10000;
        const FLAG_DEVICENODEMASK			 = 0b100000;
        const FLAG_DEVICELUIDVALID			 = 0b1000000;
    }
}


/// A builder for `VkPhysicalDeviceIDPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceIDPropertiesKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceIDPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceIDPropertiesKhrFlags,
}

impl<'b> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        PhysicalDeviceIDPropertiesKhrBuilder {
            raw: vks::VkPhysicalDeviceIDPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceIDPropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn device_uuid<'m>(mut self, device_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceUUID = device_uuid;
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICEUUID;
        self
    }

    pub fn driver_uuid<'m>(mut self, driver_uuid: [u8; vks::VK_UUID_SIZE]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.driverUUID = driver_uuid;
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_DRIVERUUID;
        self
    }

    pub fn device_luid<'m>(mut self, device_luid: [u8; vks::VK_LUID_SIZE_KHR]) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceLUID = device_luid;
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUID;
        self
    }

    pub fn device_node_mask<'m>(mut self, device_node_mask: u32) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceNodeMask = device_node_mask.into();
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICENODEMASK;
        self
    }

    pub fn device_luid_valid<'m>(mut self, device_luid_valid: bool) -> PhysicalDeviceIDPropertiesKhrBuilder<'b> {
        self.raw.deviceLUIDValid = device_luid_valid as u32;
        self.set_mask |= PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUIDVALID;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_PNEXT != PhysicalDeviceIDPropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_device_uuid<'a>(&'a self) -> Option<&[u8]> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICEUUID != PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICEUUID { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.deviceUUID as *const _, vks::VK_UUID_SIZE as usize) } )
    }

    pub fn get_driver_uuid<'a>(&'a self) -> Option<&[u8]> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_DRIVERUUID != PhysicalDeviceIDPropertiesKhrFlags::FLAG_DRIVERUUID { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.driverUUID as *const _, vks::VK_UUID_SIZE as usize) } )
    }

    pub fn get_device_luid<'a>(&'a self) -> Option<&[u8]> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUID != PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUID { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.deviceLUID as *const _, vks::VK_LUID_SIZE_KHR as usize) } )
    }

    pub fn get_device_node_mask<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICENODEMASK != PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICENODEMASK { return None }
        Some( self.raw.deviceNodeMask.into() )
    }

    pub fn get_device_luid_valid<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUIDVALID != PhysicalDeviceIDPropertiesKhrFlags::FLAG_DEVICELUIDVALID { return None }
        Some( self.raw.deviceLUIDValid != 0 )
    }

    pub fn build(self) -> PhysicalDeviceIDPropertiesKhr<'b> {
        PhysicalDeviceIDPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryImageCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryImageCreateInfoKhr<'s> {
    raw: vks::VkExternalMemoryImageCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryImageCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        ExternalMemoryImageCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryImageCreateInfoKHR) -> ExternalMemoryImageCreateInfoKhr<'s> {
        ExternalMemoryImageCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryImageCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryImageCreateInfoKhr<'s>> for vks::VkExternalMemoryImageCreateInfoKHR {
    fn from(f: ExternalMemoryImageCreateInfoKhr<'s>) -> vks::VkExternalMemoryImageCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalMemoryImageCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalMemoryImageCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExternalMemoryImageCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryImageCreateInfoKhrBuilder<'b> {
    raw: vks::VkExternalMemoryImageCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalMemoryImageCreateInfoKhrFlags,
}

impl<'b> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        ExternalMemoryImageCreateInfoKhrBuilder {
            raw: vks::VkExternalMemoryImageCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExternalMemoryImageCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalMemoryImageCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryImageCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExternalMemoryImageCreateInfoKhrFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExternalMemoryImageCreateInfoKhrFlags::FLAG_PNEXT != ExternalMemoryImageCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ExternalMemoryImageCreateInfoKhrFlags::FLAG_HANDLETYPES != ExternalMemoryImageCreateInfoKhrFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryImageCreateInfoKhr::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExternalMemoryImageCreateInfoKhr<'b> {
        ExternalMemoryImageCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalMemoryBufferCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalMemoryBufferCreateInfoKhr<'s> {
    raw: vks::VkExternalMemoryBufferCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalMemoryBufferCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        ExternalMemoryBufferCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalMemoryBufferCreateInfoKHR) -> ExternalMemoryBufferCreateInfoKhr<'s> {
        ExternalMemoryBufferCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryBufferCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalMemoryBufferCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExternalMemoryBufferCreateInfoKhr<'s>> for vks::VkExternalMemoryBufferCreateInfoKHR {
    fn from(f: ExternalMemoryBufferCreateInfoKhr<'s>) -> vks::VkExternalMemoryBufferCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalMemoryBufferCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalMemoryBufferCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExternalMemoryBufferCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
    raw: vks::VkExternalMemoryBufferCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalMemoryBufferCreateInfoKhrFlags,
}

impl<'b> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        ExternalMemoryBufferCreateInfoKhrBuilder {
            raw: vks::VkExternalMemoryBufferCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExternalMemoryBufferCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalMemoryBufferCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExternalMemoryBufferCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExternalMemoryBufferCreateInfoKhrFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExternalMemoryBufferCreateInfoKhrFlags::FLAG_PNEXT != ExternalMemoryBufferCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ExternalMemoryBufferCreateInfoKhrFlags::FLAG_HANDLETYPES != ExternalMemoryBufferCreateInfoKhrFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExternalMemoryBufferCreateInfoKhr::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExternalMemoryBufferCreateInfoKhr<'b> {
        ExternalMemoryBufferCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryAllocateInfoKhr<'s> {
    raw: vks::VkExportMemoryAllocateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryAllocateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        ExportMemoryAllocateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryAllocateInfoKHR) -> ExportMemoryAllocateInfoKhr<'s> {
        ExportMemoryAllocateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryAllocateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportMemoryAllocateInfoKhr<'s>> for vks::VkExportMemoryAllocateInfoKHR {
    fn from(f: ExportMemoryAllocateInfoKhr<'s>) -> vks::VkExportMemoryAllocateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportMemoryAllocateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportMemoryAllocateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExportMemoryAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryAllocateInfoKhrBuilder<'b> {
    raw: vks::VkExportMemoryAllocateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportMemoryAllocateInfoKhrFlags,
}

impl<'b> ExportMemoryAllocateInfoKhrBuilder<'b> {
    pub fn new() -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        ExportMemoryAllocateInfoKhrBuilder {
            raw: vks::VkExportMemoryAllocateInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportMemoryAllocateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportMemoryAllocateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalMemoryHandleTypeFlagsKhr) -> ExportMemoryAllocateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExportMemoryAllocateInfoKhrFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportMemoryAllocateInfoKhrFlags::FLAG_PNEXT != ExportMemoryAllocateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ExportMemoryAllocateInfoKhrFlags::FLAG_HANDLETYPES != ExportMemoryAllocateInfoKhrFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportMemoryAllocateInfoKhr::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExportMemoryAllocateInfoKhr<'b> {
        ExportMemoryAllocateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryWin32HandleInfoKhr<'s> {
    raw: vks::VkImportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        ImportMemoryWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryWin32HandleInfoKHR) -> ImportMemoryWin32HandleInfoKhr<'s> {
        ImportMemoryWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportMemoryWin32HandleInfoKhr<'s>> for vks::VkImportMemoryWin32HandleInfoKHR {
    fn from(f: ImportMemoryWin32HandleInfoKhr<'s>) -> vks::VkImportMemoryWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportMemoryWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportMemoryWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
        const FLAG_HANDLE			 = 0b1000;
        const FLAG_NAME			 = 0b10000;
    }
}


/// A builder for `VkImportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportMemoryWin32HandleInfoKhrFlags,
}

impl<'b> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        ImportMemoryWin32HandleInfoKhrBuilder {
            raw: vks::VkImportMemoryWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportMemoryWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self.set_mask |= ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLE;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ImportMemoryWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT != ImportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_handle<'a>(&'a self) -> Option<HANDLE> {
        if self.set_mask & ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLE != ImportMemoryWin32HandleInfoKhrFlags::FLAG_HANDLE { return None }
        Some( self.raw.handle.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ImportMemoryWin32HandleInfoKhrFlags::FLAG_NAME != ImportMemoryWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ImportMemoryWin32HandleInfoKhr<'b> {
        ImportMemoryWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportMemoryWin32HandleInfoKhr<'s> {
    raw: vks::VkExportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportMemoryWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        ExportMemoryWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportMemoryWin32HandleInfoKHR) -> ExportMemoryWin32HandleInfoKhr<'s> {
        ExportMemoryWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportMemoryWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportMemoryWin32HandleInfoKhr<'s>> for vks::VkExportMemoryWin32HandleInfoKHR {
    fn from(f: ExportMemoryWin32HandleInfoKhr<'s>) -> vks::VkExportMemoryWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportMemoryWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportMemoryWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PATTRIBUTES			 = 0b100;
        const FLAG_DWACCESS			 = 0b1000;
        const FLAG_NAME			 = 0b10000;
    }
}


/// A builder for `VkExportMemoryWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportMemoryWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportMemoryWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportMemoryWin32HandleInfoKhrFlags,
}

impl<'b> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        ExportMemoryWin32HandleInfoKhrBuilder {
            raw: vks::VkExportMemoryWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportMemoryWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self.set_mask |= ExportMemoryWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self.set_mask |= ExportMemoryWin32HandleInfoKhrFlags::FLAG_DWACCESS;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportMemoryWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ExportMemoryWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT != ExportMemoryWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_attributes<'a>(&'a self) -> Option<&'a SECURITY_ATTRIBUTES> {
        if self.set_mask & ExportMemoryWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES != ExportMemoryWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES { return None }
        Some( unsafe { &*(self.raw.pAttributes as *const _) } )
    }

    pub fn get_dw_access<'a>(&'a self) -> Option<DWORD> {
        if self.set_mask & ExportMemoryWin32HandleInfoKhrFlags::FLAG_DWACCESS != ExportMemoryWin32HandleInfoKhrFlags::FLAG_DWACCESS { return None }
        Some( self.raw.dwAccess.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ExportMemoryWin32HandleInfoKhrFlags::FLAG_NAME != ExportMemoryWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ExportMemoryWin32HandleInfoKhr<'b> {
        ExportMemoryWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryWin32HandlePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryWin32HandlePropertiesKhr<'s> {
    raw: vks::VkMemoryWin32HandlePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryWin32HandlePropertiesKhr<'s> {
    pub fn builder<'b>() -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        MemoryWin32HandlePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryWin32HandlePropertiesKHR) -> MemoryWin32HandlePropertiesKhr<'s> {
        MemoryWin32HandlePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryWin32HandlePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<MemoryWin32HandlePropertiesKhr<'s>> for vks::VkMemoryWin32HandlePropertiesKHR {
    fn from(f: MemoryWin32HandlePropertiesKhr<'s>) -> vks::VkMemoryWin32HandlePropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryWin32HandlePropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryWin32HandlePropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORYTYPEBITS			 = 0b100;
    }
}


/// A builder for `VkMemoryWin32HandlePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryWin32HandlePropertiesKhrBuilder<'b> {
    raw: vks::VkMemoryWin32HandlePropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryWin32HandlePropertiesKhrFlags,
}

impl<'b> MemoryWin32HandlePropertiesKhrBuilder<'b> {
    pub fn new() -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        MemoryWin32HandlePropertiesKhrBuilder {
            raw: vks::VkMemoryWin32HandlePropertiesKHR::default(),
            _p: PhantomData,
            set_mask: MemoryWin32HandlePropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryWin32HandlePropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryWin32HandlePropertiesKhrBuilder<'b> {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self.set_mask |= MemoryWin32HandlePropertiesKhrFlags::FLAG_MEMORYTYPEBITS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & MemoryWin32HandlePropertiesKhrFlags::FLAG_PNEXT != MemoryWin32HandlePropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryWin32HandlePropertiesKhrFlags::FLAG_MEMORYTYPEBITS != MemoryWin32HandlePropertiesKhrFlags::FLAG_MEMORYTYPEBITS { return None }
        Some( self.raw.memoryTypeBits.into() )
    }

    pub fn build(self) -> MemoryWin32HandlePropertiesKhr<'b> {
        MemoryWin32HandlePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryGetWin32HandleInfoKhr<'s> {
    raw: vks::VkMemoryGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        MemoryGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryGetWin32HandleInfoKHR) -> MemoryGetWin32HandleInfoKhr<'s> {
        MemoryGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryGetWin32HandleInfoKhr<'s>> for vks::VkMemoryGetWin32HandleInfoKHR {
    fn from(f: MemoryGetWin32HandleInfoKhr<'s>) -> vks::VkMemoryGetWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryGetWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryGetWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORY			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkMemoryGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkMemoryGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryGetWin32HandleInfoKhrFlags,
}

impl<'b> MemoryGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        MemoryGetWin32HandleInfoKhrBuilder {
            raw: vks::VkMemoryGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: MemoryGetWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryGetWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MemoryGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self.set_mask |= MemoryGetWin32HandleInfoKhrFlags::FLAG_MEMORY;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> MemoryGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= MemoryGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryGetWin32HandleInfoKhrFlags::FLAG_PNEXT != MemoryGetWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory<'a>(&'a self) -> Option<vks::VkDeviceMemory> {
        if self.set_mask & MemoryGetWin32HandleInfoKhrFlags::FLAG_MEMORY != MemoryGetWin32HandleInfoKhrFlags::FLAG_MEMORY { return None }
        Some( self.raw.memory )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & MemoryGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != MemoryGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> MemoryGetWin32HandleInfoKhr<'b> {
        MemoryGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportMemoryFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportMemoryFdInfoKhr<'s> {
    raw: vks::VkImportMemoryFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportMemoryFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportMemoryFdInfoKhrBuilder<'b> {
        ImportMemoryFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportMemoryFdInfoKHR) -> ImportMemoryFdInfoKhr<'s> {
        ImportMemoryFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportMemoryFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportMemoryFdInfoKhr<'s>> for vks::VkImportMemoryFdInfoKHR {
    fn from(f: ImportMemoryFdInfoKhr<'s>) -> vks::VkImportMemoryFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportMemoryFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportMemoryFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
        const FLAG_FD			 = 0b1000;
    }
}


/// A builder for `VkImportMemoryFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportMemoryFdInfoKhrBuilder<'b> {
    raw: vks::VkImportMemoryFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportMemoryFdInfoKhrFlags,
}

impl<'b> ImportMemoryFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportMemoryFdInfoKhrBuilder<'b> {
        ImportMemoryFdInfoKhrBuilder {
            raw: vks::VkImportMemoryFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportMemoryFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportMemoryFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportMemoryFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportMemoryFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self.set_mask |= ImportMemoryFdInfoKhrFlags::FLAG_FD;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportMemoryFdInfoKhrFlags::FLAG_PNEXT != ImportMemoryFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & ImportMemoryFdInfoKhrFlags::FLAG_HANDLETYPE != ImportMemoryFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportMemoryFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_fd<'a>(&'a self) -> Option<i32> {
        if self.set_mask & ImportMemoryFdInfoKhrFlags::FLAG_FD != ImportMemoryFdInfoKhrFlags::FLAG_FD { return None }
        Some( self.raw.fd.into() )
    }

    pub fn build(self) -> ImportMemoryFdInfoKhr<'b> {
        ImportMemoryFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryFdPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryFdPropertiesKhr<'s> {
    raw: vks::VkMemoryFdPropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryFdPropertiesKhr<'s> {
    pub fn builder<'b>() -> MemoryFdPropertiesKhrBuilder<'b> {
        MemoryFdPropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryFdPropertiesKHR) -> MemoryFdPropertiesKhr<'s> {
        MemoryFdPropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_type_bits<'a>(&'a self) -> u32 {
        self.raw.memoryTypeBits.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_type_bits<'m>(&mut self, memory_type_bits: u32) {
        self.raw.memoryTypeBits = memory_type_bits.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryFdPropertiesKHR {
        &self.raw
    }
}

impl<'s> From<MemoryFdPropertiesKhr<'s>> for vks::VkMemoryFdPropertiesKHR {
    fn from(f: MemoryFdPropertiesKhr<'s>) -> vks::VkMemoryFdPropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryFdPropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryFdPropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORYTYPEBITS			 = 0b100;
    }
}


/// A builder for `VkMemoryFdPropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryFdPropertiesKhrBuilder<'b> {
    raw: vks::VkMemoryFdPropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryFdPropertiesKhrFlags,
}

impl<'b> MemoryFdPropertiesKhrBuilder<'b> {
    pub fn new() -> MemoryFdPropertiesKhrBuilder<'b> {
        MemoryFdPropertiesKhrBuilder {
            raw: vks::VkMemoryFdPropertiesKHR::default(),
            _p: PhantomData,
            set_mask: MemoryFdPropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryFdPropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryFdPropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory_type_bits<'m>(mut self, memory_type_bits: u32) -> MemoryFdPropertiesKhrBuilder<'b> {
        self.raw.memoryTypeBits = memory_type_bits.into();
        self.set_mask |= MemoryFdPropertiesKhrFlags::FLAG_MEMORYTYPEBITS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & MemoryFdPropertiesKhrFlags::FLAG_PNEXT != MemoryFdPropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory_type_bits<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryFdPropertiesKhrFlags::FLAG_MEMORYTYPEBITS != MemoryFdPropertiesKhrFlags::FLAG_MEMORYTYPEBITS { return None }
        Some( self.raw.memoryTypeBits.into() )
    }

    pub fn build(self) -> MemoryFdPropertiesKhr<'b> {
        MemoryFdPropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryGetFdInfoKhr<'s> {
    raw: vks::VkMemoryGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryGetFdInfoKhrBuilder<'b> {
        MemoryGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryGetFdInfoKHR) -> MemoryGetFdInfoKhr<'s> {
        MemoryGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn memory<'a>(&'a self) -> vks::VkDeviceMemory {
        self.raw.memory
    }

    pub fn handle_type<'a>(&'a self) -> ExternalMemoryHandleTypeFlagsKhr {
        ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory<'m, H>(&mut self, memory: H)
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryGetFdInfoKhr<'s>> for vks::VkMemoryGetFdInfoKHR {
    fn from(f: MemoryGetFdInfoKhr<'s>) -> vks::VkMemoryGetFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryGetFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryGetFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORY			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkMemoryGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryGetFdInfoKhrBuilder<'b> {
    raw: vks::VkMemoryGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryGetFdInfoKhrFlags,
}

impl<'b> MemoryGetFdInfoKhrBuilder<'b> {
    pub fn new() -> MemoryGetFdInfoKhrBuilder<'b> {
        MemoryGetFdInfoKhrBuilder {
            raw: vks::VkMemoryGetFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: MemoryGetFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryGetFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory<'m, H>(mut self, memory: H) -> MemoryGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=DeviceMemoryHandle> {
        self.raw.memory = memory.handle().0;
        self.set_mask |= MemoryGetFdInfoKhrFlags::FLAG_MEMORY;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalMemoryHandleTypeFlagsKhr) -> MemoryGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= MemoryGetFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryGetFdInfoKhrFlags::FLAG_PNEXT != MemoryGetFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory<'a>(&'a self) -> Option<vks::VkDeviceMemory> {
        if self.set_mask & MemoryGetFdInfoKhrFlags::FLAG_MEMORY != MemoryGetFdInfoKhrFlags::FLAG_MEMORY { return None }
        Some( self.raw.memory )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalMemoryHandleTypeFlagsKhr> {
        if self.set_mask & MemoryGetFdInfoKhrFlags::FLAG_HANDLETYPE != MemoryGetFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalMemoryHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("MemoryGetFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> MemoryGetFdInfoKhr<'b> {
        MemoryGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkWin32KeyedMutexAcquireReleaseInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
    pub fn builder<'b>() -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR) -> Win32KeyedMutexAcquireReleaseInfoKhr<'s> {
        Win32KeyedMutexAcquireReleaseInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn acquire_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) }
    }

    pub fn acquire_timeouts<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pAcquireTimeouts as *const _, self.raw.acquireCount as usize) }
    }

    pub fn release_syncs<'a>(&'a self) -> &'a [vks::VkDeviceMemory] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) }
    }

    pub fn release_keys<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_acquire_syncs<'m, 'a>(&mut self, acquire_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_acquire_keys<'m, 'a>(&mut self, acquire_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn set_acquire_timeouts<'m, 'a>(&mut self, acquire_timeouts: &'a [u32])
            where 'a: 's {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeouts.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_timeouts`.");
        self.raw.acquireCount = acquire_timeouts.len() as _;
        self.raw.pAcquireTimeouts = acquire_timeouts.as_ptr() as *const u32 as *const _;
    }

    pub fn set_release_syncs<'m, 'a>(&mut self, release_syncs: &'a [DeviceMemoryHandle])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
    }

    pub fn set_release_keys<'m, 'a>(&mut self, release_keys: &'a [u64])
            where 'a: 's {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
        &self.raw
    }
}

impl<'s> From<Win32KeyedMutexAcquireReleaseInfoKhr<'s>> for vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
    fn from(f: Win32KeyedMutexAcquireReleaseInfoKhr<'s>) -> vks::VkWin32KeyedMutexAcquireReleaseInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkWin32KeyedMutexAcquireReleaseInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct Win32KeyedMutexAcquireReleaseInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_ACQUIRECOUNT			 = 0b100;
        const FLAG_PACQUIRESYNCS			 = 0b1000;
        const FLAG_PACQUIREKEYS			 = 0b10000;
        const FLAG_PACQUIRETIMEOUTS			 = 0b100000;
        const FLAG_RELEASECOUNT			 = 0b1000000;
        const FLAG_PRELEASESYNCS			 = 0b10000000;
        const FLAG_PRELEASEKEYS			 = 0b100000000;
    }
}


/// A builder for `VkWin32KeyedMutexAcquireReleaseInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
    raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: Win32KeyedMutexAcquireReleaseInfoKhrFlags,
}

impl<'b> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
    pub fn new() -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhrBuilder {
            raw: vks::VkWin32KeyedMutexAcquireReleaseInfoKHR::default(),
            _p: PhantomData,
            set_mask: Win32KeyedMutexAcquireReleaseInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn acquire_syncs<'m, 'a>(mut self, acquire_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_syncs`.");
        self.raw.acquireCount = acquire_syncs.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireSyncs = acquire_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRESYNCS;
        self
    }

    pub fn acquire_keys<'m, 'a>(mut self, acquire_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_keys`.");
        self.raw.acquireCount = acquire_keys.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireKeys = acquire_keys.as_ptr() as *const u64 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIREKEYS;
        self
    }

    pub fn acquire_timeouts<'m, 'a>(mut self, acquire_timeouts: &'a [u32]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.acquireCount == 0 || self.raw.acquireCount == acquire_timeouts.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::acquire_timeouts`.");
        self.raw.acquireCount = acquire_timeouts.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_ACQUIRECOUNT;
        self.raw.pAcquireTimeouts = acquire_timeouts.as_ptr() as *const u32 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRETIMEOUTS;
        self
    }

    pub fn release_syncs<'m, 'a>(mut self, release_syncs: &'a [DeviceMemoryHandle]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_syncs.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_syncs`.");
        self.raw.releaseCount = release_syncs.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_RELEASECOUNT;
        self.raw.pReleaseSyncs = release_syncs.as_ptr() as *const vks::VkDeviceMemory;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASESYNCS;
        self
    }

    pub fn release_keys<'m, 'a>(mut self, release_keys: &'a [u64]) -> Win32KeyedMutexAcquireReleaseInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.releaseCount == 0 || self.raw.releaseCount == release_keys.len() as _, 
            "count inconsistency found when specifying `Win32KeyedMutexAcquireReleaseInfoKhr::release_keys`.");
        self.raw.releaseCount = release_keys.len() as _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_RELEASECOUNT;
        self.raw.pReleaseKeys = release_keys.as_ptr() as *const u64 as *const _;
        self.set_mask |= Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASEKEYS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PNEXT != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_acquire_syncs<'a>(&'a self) -> Option<&'a [vks::VkDeviceMemory]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRESYNCS != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRESYNCS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireSyncs as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_acquire_keys<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIREKEYS != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIREKEYS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireKeys as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_acquire_timeouts<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRETIMEOUTS != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PACQUIRETIMEOUTS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pAcquireTimeouts as *const _, self.raw.acquireCount as usize) } )
    }

    pub fn get_release_syncs<'a>(&'a self) -> Option<&'a [vks::VkDeviceMemory]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASESYNCS != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASESYNCS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pReleaseSyncs as *const _, self.raw.releaseCount as usize) } )
    }

    pub fn get_release_keys<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASEKEYS != Win32KeyedMutexAcquireReleaseInfoKhrFlags::FLAG_PRELEASEKEYS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pReleaseKeys as *const _, self.raw.releaseCount as usize) } )
    }

    pub fn build(self) -> Win32KeyedMutexAcquireReleaseInfoKhr<'b> {
        Win32KeyedMutexAcquireReleaseInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalSemaphoreInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR) -> PhysicalDeviceExternalSemaphoreInfoKhr<'s> {
        PhysicalDeviceExternalSemaphoreInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalSemaphoreInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalSemaphoreInfoKhr<'s>> for vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
    fn from(f: PhysicalDeviceExternalSemaphoreInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalSemaphoreInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceExternalSemaphoreInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceExternalSemaphoreInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceExternalSemaphoreInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceExternalSemaphoreInfoKhrFlags,
}

impl<'b> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalSemaphoreInfoKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceExternalSemaphoreInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> PhysicalDeviceExternalSemaphoreInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_PNEXT != PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_HANDLETYPE != PhysicalDeviceExternalSemaphoreInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalSemaphoreInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> PhysicalDeviceExternalSemaphoreInfoKhr<'b> {
        PhysicalDeviceExternalSemaphoreInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalSemaphorePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalSemaphorePropertiesKhr<'s> {
    raw: vks::VkExternalSemaphorePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalSemaphorePropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        ExternalSemaphorePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalSemaphorePropertiesKHR) -> ExternalSemaphorePropertiesKhr<'s> {
        ExternalSemaphorePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn external_semaphore_features<'a>(&'a self) -> ExternalSemaphoreFeatureFlagsKhr {
        ExternalSemaphoreFeatureFlagsKhr::from_bits(self.raw.externalSemaphoreFeatures)
            .expect("ExternalSemaphorePropertiesKhr::external_semaphore_features: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn set_external_semaphore_features<'m>(&mut self, external_semaphore_features: ExternalSemaphoreFeatureFlagsKhr) {
        self.raw.externalSemaphoreFeatures = external_semaphore_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalSemaphorePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalSemaphorePropertiesKhr<'s>> for vks::VkExternalSemaphorePropertiesKHR {
    fn from(f: ExternalSemaphorePropertiesKhr<'s>) -> vks::VkExternalSemaphorePropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalSemaphorePropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalSemaphorePropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_EXPORTFROMIMPORTEDHANDLETYPES			 = 0b100;
        const FLAG_COMPATIBLEHANDLETYPES			 = 0b1000;
        const FLAG_EXTERNALSEMAPHOREFEATURES			 = 0b10000;
    }
}


/// A builder for `VkExternalSemaphorePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalSemaphorePropertiesKhrBuilder<'b> {
    raw: vks::VkExternalSemaphorePropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalSemaphorePropertiesKhrFlags,
}

impl<'b> ExternalSemaphorePropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        ExternalSemaphorePropertiesKhrBuilder {
            raw: vks::VkExternalSemaphorePropertiesKHR::default(),
            _p: PhantomData,
            set_mask: ExternalSemaphorePropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalSemaphorePropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self.set_mask |= ExternalSemaphorePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES;
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self.set_mask |= ExternalSemaphorePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES;
        self
    }

    pub fn external_semaphore_features<'m>(mut self, external_semaphore_features: ExternalSemaphoreFeatureFlagsKhr) -> ExternalSemaphorePropertiesKhrBuilder<'b> {
        self.raw.externalSemaphoreFeatures = external_semaphore_features.bits();
        self.set_mask |= ExternalSemaphorePropertiesKhrFlags::FLAG_EXTERNALSEMAPHOREFEATURES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ExternalSemaphorePropertiesKhrFlags::FLAG_PNEXT != ExternalSemaphorePropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & ExternalSemaphorePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES != ExternalSemaphorePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::export_from_imported_handle_types: error converting flags") )
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & ExternalSemaphorePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES != ExternalSemaphorePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalSemaphorePropertiesKhr::compatible_handle_types: error converting flags") )
    }

    pub fn get_external_semaphore_features<'a>(&'a self) -> Option<ExternalSemaphoreFeatureFlagsKhr> {
        if self.set_mask & ExternalSemaphorePropertiesKhrFlags::FLAG_EXTERNALSEMAPHOREFEATURES != ExternalSemaphorePropertiesKhrFlags::FLAG_EXTERNALSEMAPHOREFEATURES { return None }
        Some( ExternalSemaphoreFeatureFlagsKhr::from_bits(self.raw.externalSemaphoreFeatures)
            .expect("ExternalSemaphorePropertiesKhr::external_semaphore_features: error converting flags") )
    }

    pub fn build(self) -> ExternalSemaphorePropertiesKhr<'b> {
        ExternalSemaphorePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportSemaphoreCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportSemaphoreCreateInfoKhr<'s> {
    raw: vks::VkExportSemaphoreCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportSemaphoreCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        ExportSemaphoreCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportSemaphoreCreateInfoKHR) -> ExportSemaphoreCreateInfoKhr<'s> {
        ExportSemaphoreCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportSemaphoreCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportSemaphoreCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportSemaphoreCreateInfoKhr<'s>> for vks::VkExportSemaphoreCreateInfoKHR {
    fn from(f: ExportSemaphoreCreateInfoKhr<'s>) -> vks::VkExportSemaphoreCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportSemaphoreCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportSemaphoreCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExportSemaphoreCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportSemaphoreCreateInfoKhrBuilder<'b> {
    raw: vks::VkExportSemaphoreCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportSemaphoreCreateInfoKhrFlags,
}

impl<'b> ExportSemaphoreCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        ExportSemaphoreCreateInfoKhrBuilder {
            raw: vks::VkExportSemaphoreCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportSemaphoreCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportSemaphoreCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalSemaphoreHandleTypeFlagsKhr) -> ExportSemaphoreCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExportSemaphoreCreateInfoKhrFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportSemaphoreCreateInfoKhrFlags::FLAG_PNEXT != ExportSemaphoreCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & ExportSemaphoreCreateInfoKhrFlags::FLAG_HANDLETYPES != ExportSemaphoreCreateInfoKhrFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportSemaphoreCreateInfoKhr::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExportSemaphoreCreateInfoKhr<'b> {
        ExportSemaphoreCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportSemaphoreWin32HandleInfoKhr<'s> {
    raw: vks::VkImportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportSemaphoreWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ImportSemaphoreWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportSemaphoreWin32HandleInfoKHR) -> ImportSemaphoreWin32HandleInfoKhr<'s> {
        ImportSemaphoreWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportSemaphoreWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportSemaphoreWin32HandleInfoKhr<'s>> for vks::VkImportSemaphoreWin32HandleInfoKHR {
    fn from(f: ImportSemaphoreWin32HandleInfoKhr<'s>) -> vks::VkImportSemaphoreWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportSemaphoreWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportSemaphoreWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SEMAPHORE			 = 0b100;
        const FLAG_FLAGS			 = 0b1000;
        const FLAG_HANDLETYPE			 = 0b10000;
        const FLAG_HANDLE			 = 0b100000;
        const FLAG_NAME			 = 0b1000000;
    }
}


/// A builder for `VkImportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportSemaphoreWin32HandleInfoKhrFlags,
}

impl<'b> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ImportSemaphoreWin32HandleInfoKhrBuilder {
            raw: vks::VkImportSemaphoreWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportSemaphoreWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_SEMAPHORE;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreImportFlagsKhr) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLE;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_semaphore<'a>(&'a self) -> Option<vks::VkSemaphore> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_SEMAPHORE != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_SEMAPHORE { return None }
        Some( self.raw.semaphore )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SemaphoreImportFlagsKhr> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_FLAGS != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_FLAGS { return None }
        Some( SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreWin32HandleInfoKhr::flags: error converting flags") )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_handle<'a>(&'a self) -> Option<HANDLE> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLE != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_HANDLE { return None }
        Some( self.raw.handle.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME != ImportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ImportSemaphoreWin32HandleInfoKhr<'b> {
        ImportSemaphoreWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportSemaphoreWin32HandleInfoKhr<'s> {
    raw: vks::VkExportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportSemaphoreWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ExportSemaphoreWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportSemaphoreWin32HandleInfoKHR) -> ExportSemaphoreWin32HandleInfoKhr<'s> {
        ExportSemaphoreWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportSemaphoreWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportSemaphoreWin32HandleInfoKhr<'s>> for vks::VkExportSemaphoreWin32HandleInfoKHR {
    fn from(f: ExportSemaphoreWin32HandleInfoKhr<'s>) -> vks::VkExportSemaphoreWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportSemaphoreWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportSemaphoreWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PATTRIBUTES			 = 0b100;
        const FLAG_DWACCESS			 = 0b1000;
        const FLAG_NAME			 = 0b10000;
    }
}


/// A builder for `VkExportSemaphoreWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportSemaphoreWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportSemaphoreWin32HandleInfoKhrFlags,
}

impl<'b> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        ExportSemaphoreWin32HandleInfoKhrBuilder {
            raw: vks::VkExportSemaphoreWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportSemaphoreWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self.set_mask |= ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self.set_mask |= ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_DWACCESS;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportSemaphoreWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT != ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_attributes<'a>(&'a self) -> Option<&'a SECURITY_ATTRIBUTES> {
        if self.set_mask & ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES != ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES { return None }
        Some( unsafe { &*(self.raw.pAttributes as *const _) } )
    }

    pub fn get_dw_access<'a>(&'a self) -> Option<DWORD> {
        if self.set_mask & ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_DWACCESS != ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_DWACCESS { return None }
        Some( self.raw.dwAccess.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME != ExportSemaphoreWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ExportSemaphoreWin32HandleInfoKhr<'b> {
        ExportSemaphoreWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkD3D12FenceSubmitInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct D3d12FenceSubmitInfoKHR<'s> {
    raw: vks::VkD3D12FenceSubmitInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> D3d12FenceSubmitInfoKHR<'s> {
    pub fn builder<'b>() -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        D3d12FenceSubmitInfoKHRBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkD3D12FenceSubmitInfoKHR) -> D3d12FenceSubmitInfoKHR<'s> {
        D3d12FenceSubmitInfoKHR { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreValues as *const _, self.raw.waitSemaphoreValuesCount as usize) }
    }

    pub fn signal_semaphore_values<'a>(&'a self) -> &'a [u64] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreValues as *const _, self.raw.signalSemaphoreValuesCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphore_values<'m, 'a>(&mut self, wait_semaphore_values: &'a [u64])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreValuesCount == 0 || self.raw.waitSemaphoreValuesCount == wait_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::wait_semaphore_values`.");
        self.raw.waitSemaphoreValuesCount = wait_semaphore_values.len() as _;
        self.raw.pWaitSemaphoreValues = wait_semaphore_values.as_ptr() as *const u64 as *const _;
    }

    pub fn set_signal_semaphore_values<'m, 'a>(&mut self, signal_semaphore_values: &'a [u64])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreValuesCount == 0 || self.raw.signalSemaphoreValuesCount == signal_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::signal_semaphore_values`.");
        self.raw.signalSemaphoreValuesCount = signal_semaphore_values.len() as _;
        self.raw.pSignalSemaphoreValues = signal_semaphore_values.as_ptr() as *const u64 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkD3D12FenceSubmitInfoKHR {
        &self.raw
    }
}

impl<'s> From<D3d12FenceSubmitInfoKHR<'s>> for vks::VkD3D12FenceSubmitInfoKHR {
    fn from(f: D3d12FenceSubmitInfoKHR<'s>) -> vks::VkD3D12FenceSubmitInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkD3D12FenceSubmitInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct D3d12FenceSubmitInfoKHRFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_WAITSEMAPHOREVALUESCOUNT			 = 0b100;
        const FLAG_PWAITSEMAPHOREVALUES			 = 0b1000;
        const FLAG_SIGNALSEMAPHOREVALUESCOUNT			 = 0b10000;
        const FLAG_PSIGNALSEMAPHOREVALUES			 = 0b100000;
    }
}


/// A builder for `VkD3D12FenceSubmitInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct D3d12FenceSubmitInfoKHRBuilder<'b> {
    raw: vks::VkD3D12FenceSubmitInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: D3d12FenceSubmitInfoKHRFlags,
}

impl<'b> D3d12FenceSubmitInfoKHRBuilder<'b> {
    pub fn new() -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        D3d12FenceSubmitInfoKHRBuilder {
            raw: vks::VkD3D12FenceSubmitInfoKHR::default(),
            _p: PhantomData,
            set_mask: D3d12FenceSubmitInfoKHRFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> D3d12FenceSubmitInfoKHRBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= D3d12FenceSubmitInfoKHRFlags::FLAG_PNEXT;
        self
    }

    pub fn wait_semaphore_values<'m, 'a>(mut self, wait_semaphore_values: &'a [u64]) -> D3d12FenceSubmitInfoKHRBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreValuesCount == 0 || self.raw.waitSemaphoreValuesCount == wait_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::wait_semaphore_values`.");
        self.raw.waitSemaphoreValuesCount = wait_semaphore_values.len() as _;
        self.set_mask |= D3d12FenceSubmitInfoKHRFlags::FLAG_WAITSEMAPHOREVALUESCOUNT;
        self.raw.pWaitSemaphoreValues = wait_semaphore_values.as_ptr() as *const u64 as *const _;
        self.set_mask |= D3d12FenceSubmitInfoKHRFlags::FLAG_PWAITSEMAPHOREVALUES;
        self
    }

    pub fn signal_semaphore_values<'m, 'a>(mut self, signal_semaphore_values: &'a [u64]) -> D3d12FenceSubmitInfoKHRBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreValuesCount == 0 || self.raw.signalSemaphoreValuesCount == signal_semaphore_values.len() as _, 
            "count inconsistency found when specifying `D3d12FenceSubmitInfoKHR::signal_semaphore_values`.");
        self.raw.signalSemaphoreValuesCount = signal_semaphore_values.len() as _;
        self.set_mask |= D3d12FenceSubmitInfoKHRFlags::FLAG_SIGNALSEMAPHOREVALUESCOUNT;
        self.raw.pSignalSemaphoreValues = signal_semaphore_values.as_ptr() as *const u64 as *const _;
        self.set_mask |= D3d12FenceSubmitInfoKHRFlags::FLAG_PSIGNALSEMAPHOREVALUES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & D3d12FenceSubmitInfoKHRFlags::FLAG_PNEXT != D3d12FenceSubmitInfoKHRFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_wait_semaphore_values<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & D3d12FenceSubmitInfoKHRFlags::FLAG_PWAITSEMAPHOREVALUES != D3d12FenceSubmitInfoKHRFlags::FLAG_PWAITSEMAPHOREVALUES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreValues as *const _, self.raw.waitSemaphoreValuesCount as usize) } )
    }

    pub fn get_signal_semaphore_values<'a>(&'a self) -> Option<&'a [u64]> {
        if self.set_mask & D3d12FenceSubmitInfoKHRFlags::FLAG_PSIGNALSEMAPHOREVALUES != D3d12FenceSubmitInfoKHRFlags::FLAG_PSIGNALSEMAPHOREVALUES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreValues as *const _, self.raw.signalSemaphoreValuesCount as usize) } )
    }

    pub fn build(self) -> D3d12FenceSubmitInfoKHR<'b> {
        D3d12FenceSubmitInfoKHR {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSemaphoreGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreGetWin32HandleInfoKhr<'s> {
    raw: vks::VkSemaphoreGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        SemaphoreGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreGetWin32HandleInfoKHR) -> SemaphoreGetWin32HandleInfoKhr<'s> {
        SemaphoreGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<SemaphoreGetWin32HandleInfoKhr<'s>> for vks::VkSemaphoreGetWin32HandleInfoKHR {
    fn from(f: SemaphoreGetWin32HandleInfoKhr<'s>) -> vks::VkSemaphoreGetWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkSemaphoreGetWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SemaphoreGetWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SEMAPHORE			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkSemaphoreGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkSemaphoreGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SemaphoreGetWin32HandleInfoKhrFlags,
}

impl<'b> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        SemaphoreGetWin32HandleInfoKhrBuilder {
            raw: vks::VkSemaphoreGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: SemaphoreGetWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SemaphoreGetWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self.set_mask |= SemaphoreGetWin32HandleInfoKhrFlags::FLAG_SEMAPHORE;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> SemaphoreGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= SemaphoreGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SemaphoreGetWin32HandleInfoKhrFlags::FLAG_PNEXT != SemaphoreGetWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_semaphore<'a>(&'a self) -> Option<vks::VkSemaphore> {
        if self.set_mask & SemaphoreGetWin32HandleInfoKhrFlags::FLAG_SEMAPHORE != SemaphoreGetWin32HandleInfoKhrFlags::FLAG_SEMAPHORE { return None }
        Some( self.raw.semaphore )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & SemaphoreGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != SemaphoreGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> SemaphoreGetWin32HandleInfoKhr<'b> {
        SemaphoreGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportSemaphoreFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportSemaphoreFdInfoKhr<'s> {
    raw: vks::VkImportSemaphoreFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportSemaphoreFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        ImportSemaphoreFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportSemaphoreFdInfoKHR) -> ImportSemaphoreFdInfoKhr<'s> {
        ImportSemaphoreFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn flags<'a>(&'a self) -> SemaphoreImportFlagsKhr {
        SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreFdInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: SemaphoreImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportSemaphoreFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportSemaphoreFdInfoKhr<'s>> for vks::VkImportSemaphoreFdInfoKHR {
    fn from(f: ImportSemaphoreFdInfoKhr<'s>) -> vks::VkImportSemaphoreFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportSemaphoreFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportSemaphoreFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SEMAPHORE			 = 0b100;
        const FLAG_FLAGS			 = 0b1000;
        const FLAG_HANDLETYPE			 = 0b10000;
        const FLAG_FD			 = 0b100000;
    }
}


/// A builder for `VkImportSemaphoreFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportSemaphoreFdInfoKhrBuilder<'b> {
    raw: vks::VkImportSemaphoreFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportSemaphoreFdInfoKhrFlags,
}

impl<'b> ImportSemaphoreFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        ImportSemaphoreFdInfoKhrBuilder {
            raw: vks::VkImportSemaphoreFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportSemaphoreFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportSemaphoreFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> ImportSemaphoreFdInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self.set_mask |= ImportSemaphoreFdInfoKhrFlags::FLAG_SEMAPHORE;
        self
    }

    pub fn flags<'m>(mut self, flags: SemaphoreImportFlagsKhr) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImportSemaphoreFdInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportSemaphoreFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportSemaphoreFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self.set_mask |= ImportSemaphoreFdInfoKhrFlags::FLAG_FD;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportSemaphoreFdInfoKhrFlags::FLAG_PNEXT != ImportSemaphoreFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_semaphore<'a>(&'a self) -> Option<vks::VkSemaphore> {
        if self.set_mask & ImportSemaphoreFdInfoKhrFlags::FLAG_SEMAPHORE != ImportSemaphoreFdInfoKhrFlags::FLAG_SEMAPHORE { return None }
        Some( self.raw.semaphore )
    }

    pub fn get_flags<'a>(&'a self) -> Option<SemaphoreImportFlagsKhr> {
        if self.set_mask & ImportSemaphoreFdInfoKhrFlags::FLAG_FLAGS != ImportSemaphoreFdInfoKhrFlags::FLAG_FLAGS { return None }
        Some( SemaphoreImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportSemaphoreFdInfoKhr::flags: error converting flags") )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & ImportSemaphoreFdInfoKhrFlags::FLAG_HANDLETYPE != ImportSemaphoreFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportSemaphoreFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_fd<'a>(&'a self) -> Option<i32> {
        if self.set_mask & ImportSemaphoreFdInfoKhrFlags::FLAG_FD != ImportSemaphoreFdInfoKhrFlags::FLAG_FD { return None }
        Some( self.raw.fd.into() )
    }

    pub fn build(self) -> ImportSemaphoreFdInfoKhr<'b> {
        ImportSemaphoreFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSemaphoreGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SemaphoreGetFdInfoKhr<'s> {
    raw: vks::VkSemaphoreGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SemaphoreGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> SemaphoreGetFdInfoKhrBuilder<'b> {
        SemaphoreGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSemaphoreGetFdInfoKHR) -> SemaphoreGetFdInfoKhr<'s> {
        SemaphoreGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn handle_type<'a>(&'a self) -> ExternalSemaphoreHandleTypeFlagsKhr {
        ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSemaphoreGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<SemaphoreGetFdInfoKhr<'s>> for vks::VkSemaphoreGetFdInfoKHR {
    fn from(f: SemaphoreGetFdInfoKhr<'s>) -> vks::VkSemaphoreGetFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkSemaphoreGetFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SemaphoreGetFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SEMAPHORE			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkSemaphoreGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SemaphoreGetFdInfoKhrBuilder<'b> {
    raw: vks::VkSemaphoreGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SemaphoreGetFdInfoKhrFlags,
}

impl<'b> SemaphoreGetFdInfoKhrBuilder<'b> {
    pub fn new() -> SemaphoreGetFdInfoKhrBuilder<'b> {
        SemaphoreGetFdInfoKhrBuilder {
            raw: vks::VkSemaphoreGetFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: SemaphoreGetFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SemaphoreGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SemaphoreGetFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> SemaphoreGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self.set_mask |= SemaphoreGetFdInfoKhrFlags::FLAG_SEMAPHORE;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalSemaphoreHandleTypeFlagsKhr) -> SemaphoreGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= SemaphoreGetFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SemaphoreGetFdInfoKhrFlags::FLAG_PNEXT != SemaphoreGetFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_semaphore<'a>(&'a self) -> Option<vks::VkSemaphore> {
        if self.set_mask & SemaphoreGetFdInfoKhrFlags::FLAG_SEMAPHORE != SemaphoreGetFdInfoKhrFlags::FLAG_SEMAPHORE { return None }
        Some( self.raw.semaphore )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalSemaphoreHandleTypeFlagsKhr> {
        if self.set_mask & SemaphoreGetFdInfoKhrFlags::FLAG_HANDLETYPE != SemaphoreGetFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalSemaphoreHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("SemaphoreGetFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> SemaphoreGetFdInfoKhr<'b> {
        SemaphoreGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceExternalFenceInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceExternalFenceInfoKhr<'s> {
    raw: vks::VkPhysicalDeviceExternalFenceInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceExternalFenceInfoKhr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        PhysicalDeviceExternalFenceInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceExternalFenceInfoKHR) -> PhysicalDeviceExternalFenceInfoKhr<'s> {
        PhysicalDeviceExternalFenceInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalFenceInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceExternalFenceInfoKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceExternalFenceInfoKhr<'s>> for vks::VkPhysicalDeviceExternalFenceInfoKHR {
    fn from(f: PhysicalDeviceExternalFenceInfoKhr<'s>) -> vks::VkPhysicalDeviceExternalFenceInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceExternalFenceInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceExternalFenceInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPE			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceExternalFenceInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceExternalFenceInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceExternalFenceInfoKhrFlags,
}

impl<'b> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        PhysicalDeviceExternalFenceInfoKhrBuilder {
            raw: vks::VkPhysicalDeviceExternalFenceInfoKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceExternalFenceInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> PhysicalDeviceExternalFenceInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_PNEXT != PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_HANDLETYPE != PhysicalDeviceExternalFenceInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("PhysicalDeviceExternalFenceInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> PhysicalDeviceExternalFenceInfoKhr<'b> {
        PhysicalDeviceExternalFenceInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExternalFencePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExternalFencePropertiesKhr<'s> {
    raw: vks::VkExternalFencePropertiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExternalFencePropertiesKhr<'s> {
    pub fn builder<'b>() -> ExternalFencePropertiesKhrBuilder<'b> {
        ExternalFencePropertiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExternalFencePropertiesKHR) -> ExternalFencePropertiesKhr<'s> {
        ExternalFencePropertiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn export_from_imported_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalFencePropertiesKhr::export_from_imported_handle_types: error converting flags")
    }

    pub fn compatible_handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalFencePropertiesKhr::compatible_handle_types: error converting flags")
    }

    pub fn external_fence_features<'a>(&'a self) -> ExternalFenceFeatureFlagsKhr {
        ExternalFenceFeatureFlagsKhr::from_bits(self.raw.externalFenceFeatures)
            .expect("ExternalFencePropertiesKhr::external_fence_features: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_export_from_imported_handle_types<'m>(&mut self, export_from_imported_handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
    }

    pub fn set_compatible_handle_types<'m>(&mut self, compatible_handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
    }

    pub fn set_external_fence_features<'m>(&mut self, external_fence_features: ExternalFenceFeatureFlagsKhr) {
        self.raw.externalFenceFeatures = external_fence_features.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExternalFencePropertiesKHR {
        &self.raw
    }
}

impl<'s> From<ExternalFencePropertiesKhr<'s>> for vks::VkExternalFencePropertiesKHR {
    fn from(f: ExternalFencePropertiesKhr<'s>) -> vks::VkExternalFencePropertiesKHR {
        f.raw
    }
}


/// Bitflags for `VkExternalFencePropertiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExternalFencePropertiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_EXPORTFROMIMPORTEDHANDLETYPES			 = 0b100;
        const FLAG_COMPATIBLEHANDLETYPES			 = 0b1000;
        const FLAG_EXTERNALFENCEFEATURES			 = 0b10000;
    }
}


/// A builder for `VkExternalFencePropertiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExternalFencePropertiesKhrBuilder<'b> {
    raw: vks::VkExternalFencePropertiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExternalFencePropertiesKhrFlags,
}

impl<'b> ExternalFencePropertiesKhrBuilder<'b> {
    pub fn new() -> ExternalFencePropertiesKhrBuilder<'b> {
        ExternalFencePropertiesKhrBuilder {
            raw: vks::VkExternalFencePropertiesKHR::default(),
            _p: PhantomData,
            set_mask: ExternalFencePropertiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExternalFencePropertiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn export_from_imported_handle_types<'m>(mut self, export_from_imported_handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.exportFromImportedHandleTypes = export_from_imported_handle_types.bits();
        self.set_mask |= ExternalFencePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES;
        self
    }

    pub fn compatible_handle_types<'m>(mut self, compatible_handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.compatibleHandleTypes = compatible_handle_types.bits();
        self.set_mask |= ExternalFencePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES;
        self
    }

    pub fn external_fence_features<'m>(mut self, external_fence_features: ExternalFenceFeatureFlagsKhr) -> ExternalFencePropertiesKhrBuilder<'b> {
        self.raw.externalFenceFeatures = external_fence_features.bits();
        self.set_mask |= ExternalFencePropertiesKhrFlags::FLAG_EXTERNALFENCEFEATURES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & ExternalFencePropertiesKhrFlags::FLAG_PNEXT != ExternalFencePropertiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_export_from_imported_handle_types<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & ExternalFencePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES != ExternalFencePropertiesKhrFlags::FLAG_EXPORTFROMIMPORTEDHANDLETYPES { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.exportFromImportedHandleTypes)
            .expect("ExternalFencePropertiesKhr::export_from_imported_handle_types: error converting flags") )
    }

    pub fn get_compatible_handle_types<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & ExternalFencePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES != ExternalFencePropertiesKhrFlags::FLAG_COMPATIBLEHANDLETYPES { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.compatibleHandleTypes)
            .expect("ExternalFencePropertiesKhr::compatible_handle_types: error converting flags") )
    }

    pub fn get_external_fence_features<'a>(&'a self) -> Option<ExternalFenceFeatureFlagsKhr> {
        if self.set_mask & ExternalFencePropertiesKhrFlags::FLAG_EXTERNALFENCEFEATURES != ExternalFencePropertiesKhrFlags::FLAG_EXTERNALFENCEFEATURES { return None }
        Some( ExternalFenceFeatureFlagsKhr::from_bits(self.raw.externalFenceFeatures)
            .expect("ExternalFencePropertiesKhr::external_fence_features: error converting flags") )
    }

    pub fn build(self) -> ExternalFencePropertiesKhr<'b> {
        ExternalFencePropertiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportFenceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportFenceCreateInfoKhr<'s> {
    raw: vks::VkExportFenceCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportFenceCreateInfoKhr<'s> {
    pub fn builder<'b>() -> ExportFenceCreateInfoKhrBuilder<'b> {
        ExportFenceCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportFenceCreateInfoKHR) -> ExportFenceCreateInfoKhr<'s> {
        ExportFenceCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn handle_types<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportFenceCreateInfoKhr::handle_types: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_handle_types<'m>(&mut self, handle_types: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleTypes = handle_types.bits();
    }

    pub fn as_raw(&self) -> &vks::VkExportFenceCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportFenceCreateInfoKhr<'s>> for vks::VkExportFenceCreateInfoKHR {
    fn from(f: ExportFenceCreateInfoKhr<'s>) -> vks::VkExportFenceCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportFenceCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportFenceCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_HANDLETYPES			 = 0b100;
    }
}


/// A builder for `VkExportFenceCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportFenceCreateInfoKhrBuilder<'b> {
    raw: vks::VkExportFenceCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportFenceCreateInfoKhrFlags,
}

impl<'b> ExportFenceCreateInfoKhrBuilder<'b> {
    pub fn new() -> ExportFenceCreateInfoKhrBuilder<'b> {
        ExportFenceCreateInfoKhrBuilder {
            raw: vks::VkExportFenceCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportFenceCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportFenceCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportFenceCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn handle_types<'m>(mut self, handle_types: ExternalFenceHandleTypeFlagsKhr) -> ExportFenceCreateInfoKhrBuilder<'b> {
        self.raw.handleTypes = handle_types.bits();
        self.set_mask |= ExportFenceCreateInfoKhrFlags::FLAG_HANDLETYPES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportFenceCreateInfoKhrFlags::FLAG_PNEXT != ExportFenceCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_handle_types<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & ExportFenceCreateInfoKhrFlags::FLAG_HANDLETYPES != ExportFenceCreateInfoKhrFlags::FLAG_HANDLETYPES { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleTypes)
            .expect("ExportFenceCreateInfoKhr::handle_types: error converting flags") )
    }

    pub fn build(self) -> ExportFenceCreateInfoKhr<'b> {
        ExportFenceCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportFenceWin32HandleInfoKhr<'s> {
    raw: vks::VkImportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportFenceWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        ImportFenceWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportFenceWin32HandleInfoKHR) -> ImportFenceWin32HandleInfoKhr<'s> {
        ImportFenceWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceWin32HandleInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub fn handle<'a>(&'a self) -> HANDLE {
        self.raw.handle.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_handle<'m>(&mut self, handle: HANDLE) {
        self.raw.handle = handle.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportFenceWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportFenceWin32HandleInfoKhr<'s>> for vks::VkImportFenceWin32HandleInfoKHR {
    fn from(f: ImportFenceWin32HandleInfoKhr<'s>) -> vks::VkImportFenceWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportFenceWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportFenceWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FENCE			 = 0b100;
        const FLAG_FLAGS			 = 0b1000;
        const FLAG_HANDLETYPE			 = 0b10000;
        const FLAG_HANDLE			 = 0b100000;
        const FLAG_NAME			 = 0b1000000;
    }
}


/// A builder for `VkImportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportFenceWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkImportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportFenceWin32HandleInfoKhrFlags,
}

impl<'b> ImportFenceWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        ImportFenceWin32HandleInfoKhrBuilder {
            raw: vks::VkImportFenceWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportFenceWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> ImportFenceWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_FENCE;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceImportFlagsKhr) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn handle<'m>(mut self, handle: HANDLE) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.handle = handle.into();
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLE;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ImportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ImportFenceWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT != ImportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_fence<'a>(&'a self) -> Option<vks::VkFence> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_FENCE != ImportFenceWin32HandleInfoKhrFlags::FLAG_FENCE { return None }
        Some( self.raw.fence )
    }

    pub fn get_flags<'a>(&'a self) -> Option<FenceImportFlagsKhr> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_FLAGS != ImportFenceWin32HandleInfoKhrFlags::FLAG_FLAGS { return None }
        Some( FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceWin32HandleInfoKhr::flags: error converting flags") )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_handle<'a>(&'a self) -> Option<HANDLE> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLE != ImportFenceWin32HandleInfoKhrFlags::FLAG_HANDLE { return None }
        Some( self.raw.handle.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ImportFenceWin32HandleInfoKhrFlags::FLAG_NAME != ImportFenceWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ImportFenceWin32HandleInfoKhr<'b> {
        ImportFenceWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkExportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ExportFenceWin32HandleInfoKhr<'s> {
    raw: vks::VkExportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ExportFenceWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        ExportFenceWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkExportFenceWin32HandleInfoKHR) -> ExportFenceWin32HandleInfoKhr<'s> {
        ExportFenceWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn attributes<'a>(&'a self) -> &'a SECURITY_ATTRIBUTES {
        unsafe { &*(self.raw.pAttributes as *const _) }
    }

    pub fn dw_access<'a>(&'a self) -> DWORD {
        self.raw.dwAccess.into()
    }

    pub fn name<'a>(&'a self) -> LPCWSTR {
        self.raw.name.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_attributes<'m, 'a>(&mut self, attributes: &'a SECURITY_ATTRIBUTES) {
        self.raw.pAttributes = attributes;
    }

    pub fn set_dw_access<'m>(&mut self, dw_access: DWORD) {
        self.raw.dwAccess = dw_access.into();
    }

    pub fn set_name<'m>(&mut self, name: LPCWSTR) {
        self.raw.name = name.into();
    }

    pub fn as_raw(&self) -> &vks::VkExportFenceWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<ExportFenceWin32HandleInfoKhr<'s>> for vks::VkExportFenceWin32HandleInfoKHR {
    fn from(f: ExportFenceWin32HandleInfoKhr<'s>) -> vks::VkExportFenceWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkExportFenceWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ExportFenceWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PATTRIBUTES			 = 0b100;
        const FLAG_DWACCESS			 = 0b1000;
        const FLAG_NAME			 = 0b10000;
    }
}


/// A builder for `VkExportFenceWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ExportFenceWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkExportFenceWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ExportFenceWin32HandleInfoKhrFlags,
}

impl<'b> ExportFenceWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        ExportFenceWin32HandleInfoKhrBuilder {
            raw: vks::VkExportFenceWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: ExportFenceWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ExportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn attributes<'m, 'a>(mut self, attributes: &'a SECURITY_ATTRIBUTES) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.pAttributes = attributes;
        self.set_mask |= ExportFenceWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES;
        self
    }

    pub fn dw_access<'m>(mut self, dw_access: DWORD) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.dwAccess = dw_access.into();
        self.set_mask |= ExportFenceWin32HandleInfoKhrFlags::FLAG_DWACCESS;
        self
    }

    pub fn name<'m>(mut self, name: LPCWSTR) -> ExportFenceWin32HandleInfoKhrBuilder<'b> {
        self.raw.name = name.into();
        self.set_mask |= ExportFenceWin32HandleInfoKhrFlags::FLAG_NAME;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ExportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT != ExportFenceWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_attributes<'a>(&'a self) -> Option<&'a SECURITY_ATTRIBUTES> {
        if self.set_mask & ExportFenceWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES != ExportFenceWin32HandleInfoKhrFlags::FLAG_PATTRIBUTES { return None }
        Some( unsafe { &*(self.raw.pAttributes as *const _) } )
    }

    pub fn get_dw_access<'a>(&'a self) -> Option<DWORD> {
        if self.set_mask & ExportFenceWin32HandleInfoKhrFlags::FLAG_DWACCESS != ExportFenceWin32HandleInfoKhrFlags::FLAG_DWACCESS { return None }
        Some( self.raw.dwAccess.into() )
    }

    pub fn get_name<'a>(&'a self) -> Option<LPCWSTR> {
        if self.set_mask & ExportFenceWin32HandleInfoKhrFlags::FLAG_NAME != ExportFenceWin32HandleInfoKhrFlags::FLAG_NAME { return None }
        Some( self.raw.name.into() )
    }

    pub fn build(self) -> ExportFenceWin32HandleInfoKhr<'b> {
        ExportFenceWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceGetWin32HandleInfoKhr<'s> {
    raw: vks::VkFenceGetWin32HandleInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceGetWin32HandleInfoKhr<'s> {
    pub fn builder<'b>() -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        FenceGetWin32HandleInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceGetWin32HandleInfoKHR) -> FenceGetWin32HandleInfoKhr<'s> {
        FenceGetWin32HandleInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetWin32HandleInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceGetWin32HandleInfoKHR {
        &self.raw
    }
}

impl<'s> From<FenceGetWin32HandleInfoKhr<'s>> for vks::VkFenceGetWin32HandleInfoKHR {
    fn from(f: FenceGetWin32HandleInfoKhr<'s>) -> vks::VkFenceGetWin32HandleInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkFenceGetWin32HandleInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FenceGetWin32HandleInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FENCE			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkFenceGetWin32HandleInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceGetWin32HandleInfoKhrBuilder<'b> {
    raw: vks::VkFenceGetWin32HandleInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: FenceGetWin32HandleInfoKhrFlags,
}

impl<'b> FenceGetWin32HandleInfoKhrBuilder<'b> {
    pub fn new() -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        FenceGetWin32HandleInfoKhrBuilder {
            raw: vks::VkFenceGetWin32HandleInfoKHR::default(),
            _p: PhantomData,
            set_mask: FenceGetWin32HandleInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= FenceGetWin32HandleInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> FenceGetWin32HandleInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self.set_mask |= FenceGetWin32HandleInfoKhrFlags::FLAG_FENCE;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> FenceGetWin32HandleInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= FenceGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & FenceGetWin32HandleInfoKhrFlags::FLAG_PNEXT != FenceGetWin32HandleInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_fence<'a>(&'a self) -> Option<vks::VkFence> {
        if self.set_mask & FenceGetWin32HandleInfoKhrFlags::FLAG_FENCE != FenceGetWin32HandleInfoKhrFlags::FLAG_FENCE { return None }
        Some( self.raw.fence )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & FenceGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE != FenceGetWin32HandleInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetWin32HandleInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> FenceGetWin32HandleInfoKhr<'b> {
        FenceGetWin32HandleInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImportFenceFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImportFenceFdInfoKhr<'s> {
    raw: vks::VkImportFenceFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImportFenceFdInfoKhr<'s> {
    pub fn builder<'b>() -> ImportFenceFdInfoKhrBuilder<'b> {
        ImportFenceFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImportFenceFdInfoKHR) -> ImportFenceFdInfoKhr<'s> {
        ImportFenceFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn flags<'a>(&'a self) -> FenceImportFlagsKhr {
        FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceFdInfoKhr::flags: error converting flags")
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceFdInfoKhr::handle_type: error converting flags")
    }

    pub fn fd<'a>(&'a self) -> i32 {
        self.raw.fd.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_flags<'m>(&mut self, flags: FenceImportFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn set_fd<'m>(&mut self, fd: i32) {
        self.raw.fd = fd.into();
    }

    pub fn as_raw(&self) -> &vks::VkImportFenceFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<ImportFenceFdInfoKhr<'s>> for vks::VkImportFenceFdInfoKHR {
    fn from(f: ImportFenceFdInfoKhr<'s>) -> vks::VkImportFenceFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkImportFenceFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImportFenceFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FENCE			 = 0b100;
        const FLAG_FLAGS			 = 0b1000;
        const FLAG_HANDLETYPE			 = 0b10000;
        const FLAG_FD			 = 0b100000;
    }
}


/// A builder for `VkImportFenceFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImportFenceFdInfoKhrBuilder<'b> {
    raw: vks::VkImportFenceFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImportFenceFdInfoKhrFlags,
}

impl<'b> ImportFenceFdInfoKhrBuilder<'b> {
    pub fn new() -> ImportFenceFdInfoKhrBuilder<'b> {
        ImportFenceFdInfoKhrBuilder {
            raw: vks::VkImportFenceFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: ImportFenceFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImportFenceFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> ImportFenceFdInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self.set_mask |= ImportFenceFdInfoKhrFlags::FLAG_FENCE;
        self
    }

    pub fn flags<'m>(mut self, flags: FenceImportFlagsKhr) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= ImportFenceFdInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= ImportFenceFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn fd<'m>(mut self, fd: i32) -> ImportFenceFdInfoKhrBuilder<'b> {
        self.raw.fd = fd.into();
        self.set_mask |= ImportFenceFdInfoKhrFlags::FLAG_FD;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImportFenceFdInfoKhrFlags::FLAG_PNEXT != ImportFenceFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_fence<'a>(&'a self) -> Option<vks::VkFence> {
        if self.set_mask & ImportFenceFdInfoKhrFlags::FLAG_FENCE != ImportFenceFdInfoKhrFlags::FLAG_FENCE { return None }
        Some( self.raw.fence )
    }

    pub fn get_flags<'a>(&'a self) -> Option<FenceImportFlagsKhr> {
        if self.set_mask & ImportFenceFdInfoKhrFlags::FLAG_FLAGS != ImportFenceFdInfoKhrFlags::FLAG_FLAGS { return None }
        Some( FenceImportFlagsKhr::from_bits(self.raw.flags)
            .expect("ImportFenceFdInfoKhr::flags: error converting flags") )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & ImportFenceFdInfoKhrFlags::FLAG_HANDLETYPE != ImportFenceFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("ImportFenceFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn get_fd<'a>(&'a self) -> Option<i32> {
        if self.set_mask & ImportFenceFdInfoKhrFlags::FLAG_FD != ImportFenceFdInfoKhrFlags::FLAG_FD { return None }
        Some( self.raw.fd.into() )
    }

    pub fn build(self) -> ImportFenceFdInfoKhr<'b> {
        ImportFenceFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkFenceGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct FenceGetFdInfoKhr<'s> {
    raw: vks::VkFenceGetFdInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> FenceGetFdInfoKhr<'s> {
    pub fn builder<'b>() -> FenceGetFdInfoKhrBuilder<'b> {
        FenceGetFdInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkFenceGetFdInfoKHR) -> FenceGetFdInfoKhr<'s> {
        FenceGetFdInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn handle_type<'a>(&'a self) -> ExternalFenceHandleTypeFlagsKhr {
        ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetFdInfoKhr::handle_type: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_handle_type<'m>(&mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) {
        self.raw.handleType = handle_type.bits();
    }

    pub fn as_raw(&self) -> &vks::VkFenceGetFdInfoKHR {
        &self.raw
    }
}

impl<'s> From<FenceGetFdInfoKhr<'s>> for vks::VkFenceGetFdInfoKHR {
    fn from(f: FenceGetFdInfoKhr<'s>) -> vks::VkFenceGetFdInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkFenceGetFdInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct FenceGetFdInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FENCE			 = 0b100;
        const FLAG_HANDLETYPE			 = 0b1000;
    }
}


/// A builder for `VkFenceGetFdInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct FenceGetFdInfoKhrBuilder<'b> {
    raw: vks::VkFenceGetFdInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: FenceGetFdInfoKhrFlags,
}

impl<'b> FenceGetFdInfoKhrBuilder<'b> {
    pub fn new() -> FenceGetFdInfoKhrBuilder<'b> {
        FenceGetFdInfoKhrBuilder {
            raw: vks::VkFenceGetFdInfoKHR::default(),
            _p: PhantomData,
            set_mask: FenceGetFdInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> FenceGetFdInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= FenceGetFdInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> FenceGetFdInfoKhrBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self.set_mask |= FenceGetFdInfoKhrFlags::FLAG_FENCE;
        self
    }

    pub fn handle_type<'m>(mut self, handle_type: ExternalFenceHandleTypeFlagsKhr) -> FenceGetFdInfoKhrBuilder<'b> {
        self.raw.handleType = handle_type.bits();
        self.set_mask |= FenceGetFdInfoKhrFlags::FLAG_HANDLETYPE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & FenceGetFdInfoKhrFlags::FLAG_PNEXT != FenceGetFdInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_fence<'a>(&'a self) -> Option<vks::VkFence> {
        if self.set_mask & FenceGetFdInfoKhrFlags::FLAG_FENCE != FenceGetFdInfoKhrFlags::FLAG_FENCE { return None }
        Some( self.raw.fence )
    }

    pub fn get_handle_type<'a>(&'a self) -> Option<ExternalFenceHandleTypeFlagsKhr> {
        if self.set_mask & FenceGetFdInfoKhrFlags::FLAG_HANDLETYPE != FenceGetFdInfoKhrFlags::FLAG_HANDLETYPE { return None }
        Some( ExternalFenceHandleTypeFlagsKhr::from_bits(self.raw.handleType)
            .expect("FenceGetFdInfoKhr::handle_type: error converting flags") )
    }

    pub fn build(self) -> FenceGetFdInfoKhr<'b> {
        FenceGetFdInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewFeaturesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewFeaturesKhx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewFeaturesKhx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        PhysicalDeviceMultiviewFeaturesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX) -> PhysicalDeviceMultiviewFeaturesKhx<'s> {
        PhysicalDeviceMultiviewFeaturesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn multiview<'a>(&'a self) -> bool {
        self.raw.multiview != 0
    }

    pub fn multiview_geometry_shader<'a>(&'a self) -> bool {
        self.raw.multiviewGeometryShader != 0
    }

    pub fn multiview_tessellation_shader<'a>(&'a self) -> bool {
        self.raw.multiviewTessellationShader != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_multiview<'m>(&mut self, multiview: bool) {
        self.raw.multiview = multiview as u32;
    }

    pub fn set_multiview_geometry_shader<'m>(&mut self, multiview_geometry_shader: bool) {
        self.raw.multiviewGeometryShader = multiview_geometry_shader as u32;
    }

    pub fn set_multiview_tessellation_shader<'m>(&mut self, multiview_tessellation_shader: bool) {
        self.raw.multiviewTessellationShader = multiview_tessellation_shader as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewFeaturesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewFeaturesKhx<'s>> for vks::VkPhysicalDeviceMultiviewFeaturesKHX {
    fn from(f: PhysicalDeviceMultiviewFeaturesKhx<'s>) -> vks::VkPhysicalDeviceMultiviewFeaturesKHX {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceMultiviewFeaturesKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceMultiviewFeaturesKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MULTIVIEW			 = 0b100;
        const FLAG_MULTIVIEWGEOMETRYSHADER			 = 0b1000;
        const FLAG_MULTIVIEWTESSELLATIONSHADER			 = 0b10000;
    }
}


/// A builder for `VkPhysicalDeviceMultiviewFeaturesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceMultiviewFeaturesKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        PhysicalDeviceMultiviewFeaturesKhxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewFeaturesKHX::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceMultiviewFeaturesKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn multiview<'m>(mut self, multiview: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiview = multiview as u32;
        self.set_mask |= PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEW;
        self
    }

    pub fn multiview_geometry_shader<'m>(mut self, multiview_geometry_shader: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiviewGeometryShader = multiview_geometry_shader as u32;
        self.set_mask |= PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWGEOMETRYSHADER;
        self
    }

    pub fn multiview_tessellation_shader<'m>(mut self, multiview_tessellation_shader: bool) -> PhysicalDeviceMultiviewFeaturesKhxBuilder<'b> {
        self.raw.multiviewTessellationShader = multiview_tessellation_shader as u32;
        self.set_mask |= PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWTESSELLATIONSHADER;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_PNEXT != PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_multiview<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEW != PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEW { return None }
        Some( self.raw.multiview != 0 )
    }

    pub fn get_multiview_geometry_shader<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWGEOMETRYSHADER != PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWGEOMETRYSHADER { return None }
        Some( self.raw.multiviewGeometryShader != 0 )
    }

    pub fn get_multiview_tessellation_shader<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWTESSELLATIONSHADER != PhysicalDeviceMultiviewFeaturesKhxFlags::FLAG_MULTIVIEWTESSELLATIONSHADER { return None }
        Some( self.raw.multiviewTessellationShader != 0 )
    }

    pub fn build(self) -> PhysicalDeviceMultiviewFeaturesKhx<'b> {
        PhysicalDeviceMultiviewFeaturesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewPropertiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewPropertiesKhx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewPropertiesKhx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        PhysicalDeviceMultiviewPropertiesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX) -> PhysicalDeviceMultiviewPropertiesKhx<'s> {
        PhysicalDeviceMultiviewPropertiesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_multiview_view_count<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewViewCount.into()
    }

    pub fn max_multiview_instance_index<'a>(&'a self) -> u32 {
        self.raw.maxMultiviewInstanceIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_multiview_view_count<'m>(&mut self, max_multiview_view_count: u32) {
        self.raw.maxMultiviewViewCount = max_multiview_view_count.into();
    }

    pub fn set_max_multiview_instance_index<'m>(&mut self, max_multiview_instance_index: u32) {
        self.raw.maxMultiviewInstanceIndex = max_multiview_instance_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewPropertiesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewPropertiesKhx<'s>> for vks::VkPhysicalDeviceMultiviewPropertiesKHX {
    fn from(f: PhysicalDeviceMultiviewPropertiesKhx<'s>) -> vks::VkPhysicalDeviceMultiviewPropertiesKHX {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceMultiviewPropertiesKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceMultiviewPropertiesKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MAXMULTIVIEWVIEWCOUNT			 = 0b100;
        const FLAG_MAXMULTIVIEWINSTANCEINDEX			 = 0b1000;
    }
}


/// A builder for `VkPhysicalDeviceMultiviewPropertiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceMultiviewPropertiesKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        PhysicalDeviceMultiviewPropertiesKhxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewPropertiesKHX::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceMultiviewPropertiesKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn max_multiview_view_count<'m>(mut self, max_multiview_view_count: u32) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.maxMultiviewViewCount = max_multiview_view_count.into();
        self.set_mask |= PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWVIEWCOUNT;
        self
    }

    pub fn max_multiview_instance_index<'m>(mut self, max_multiview_instance_index: u32) -> PhysicalDeviceMultiviewPropertiesKhxBuilder<'b> {
        self.raw.maxMultiviewInstanceIndex = max_multiview_instance_index.into();
        self.set_mask |= PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWINSTANCEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_PNEXT != PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_max_multiview_view_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWVIEWCOUNT != PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWVIEWCOUNT { return None }
        Some( self.raw.maxMultiviewViewCount.into() )
    }

    pub fn get_max_multiview_instance_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWINSTANCEINDEX != PhysicalDeviceMultiviewPropertiesKhxFlags::FLAG_MAXMULTIVIEWINSTANCEINDEX { return None }
        Some( self.raw.maxMultiviewInstanceIndex.into() )
    }

    pub fn build(self) -> PhysicalDeviceMultiviewPropertiesKhx<'b> {
        PhysicalDeviceMultiviewPropertiesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilities2EXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilities2Ext<'s> {
    raw: vks::VkSurfaceCapabilities2EXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceCapabilities2Ext<'s> {
    pub fn builder<'b>() -> SurfaceCapabilities2ExtBuilder<'b> {
        SurfaceCapabilities2ExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilities2EXT) -> SurfaceCapabilities2Ext<'s> {
        SurfaceCapabilities2Ext { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn min_image_count<'a>(&'a self) -> u32 {
        self.raw.minImageCount.into()
    }

    pub fn max_image_count<'a>(&'a self) -> u32 {
        self.raw.maxImageCount.into()
    }

    pub fn current_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn current_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn min_image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn min_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_extent<'a>(&'a self) -> &'a Extent2d {
         unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) }
    }

    pub fn max_image_extent_mut<'a>(&'a mut self) -> &'a mut Extent2d {
        unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) }
    }

    pub fn max_image_array_layers<'a>(&'a self) -> u32 {
        self.raw.maxImageArrayLayers.into()
    }

    pub fn supported_transforms<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilities2Ext::supported_transforms: error converting flags")
    }

    pub fn current_transform<'a>(&'a self) -> SurfaceTransformFlagsKhr {
        SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilities2Ext::current_transform: error converting flags")
    }

    pub fn supported_composite_alpha<'a>(&'a self) -> CompositeAlphaFlagsKhr {
        CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilities2Ext::supported_composite_alpha: error converting flags")
    }

    pub fn supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilities2Ext::supported_usage_flags: error converting flags")
    }

    pub fn supported_surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.supportedSurfaceCounters)
            .expect("SurfaceCapabilities2Ext::supported_surface_counters: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_min_image_count<'m>(&mut self, min_image_count: u32) {
        self.raw.minImageCount = min_image_count.into();
    }

    pub fn set_max_image_count<'m>(&mut self, max_image_count: u32) {
        self.raw.maxImageCount = max_image_count.into();
    }

    pub fn set_current_extent<'m>(&mut self, current_extent: Extent2d) {
        self.raw.currentExtent = current_extent.raw;
    }

    pub fn set_min_image_extent<'m>(&mut self, min_image_extent: Extent2d) {
        self.raw.minImageExtent = min_image_extent.raw;
    }

    pub fn set_max_image_extent<'m>(&mut self, max_image_extent: Extent2d) {
        self.raw.maxImageExtent = max_image_extent.raw;
    }

    pub fn set_max_image_array_layers<'m>(&mut self, max_image_array_layers: u32) {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
    }

    pub fn set_supported_transforms<'m>(&mut self, supported_transforms: SurfaceTransformFlagsKhr) {
        self.raw.supportedTransforms = supported_transforms.bits();
    }

    pub fn set_current_transform<'m>(&mut self, current_transform: SurfaceTransformFlagsKhr) {
        self.raw.currentTransform = current_transform.bits();
    }

    pub fn set_supported_composite_alpha<'m>(&mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
    }

    pub fn set_supported_usage_flags<'m>(&mut self, supported_usage_flags: ImageUsageFlags) {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
    }

    pub fn set_supported_surface_counters<'m>(&mut self, supported_surface_counters: SurfaceCounterFlagsExt) {
        self.raw.supportedSurfaceCounters = supported_surface_counters.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilities2EXT {
        &self.raw
    }
}

impl<'s> From<SurfaceCapabilities2Ext<'s>> for vks::VkSurfaceCapabilities2EXT {
    fn from(f: SurfaceCapabilities2Ext<'s>) -> vks::VkSurfaceCapabilities2EXT {
        f.raw
    }
}


/// Bitflags for `VkSurfaceCapabilities2EXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SurfaceCapabilities2ExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MINIMAGECOUNT			 = 0b100;
        const FLAG_MAXIMAGECOUNT			 = 0b1000;
        const FLAG_CURRENTEXTENT			 = 0b10000;
        const FLAG_MINIMAGEEXTENT			 = 0b100000;
        const FLAG_MAXIMAGEEXTENT			 = 0b1000000;
        const FLAG_MAXIMAGEARRAYLAYERS			 = 0b10000000;
        const FLAG_SUPPORTEDTRANSFORMS			 = 0b100000000;
        const FLAG_CURRENTTRANSFORM			 = 0b1000000000;
        const FLAG_SUPPORTEDCOMPOSITEALPHA			 = 0b10000000000;
        const FLAG_SUPPORTEDUSAGEFLAGS			 = 0b100000000000;
        const FLAG_SUPPORTEDSURFACECOUNTERS			 = 0b1000000000000;
    }
}


/// A builder for `VkSurfaceCapabilities2EXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilities2ExtBuilder<'b> {
    raw: vks::VkSurfaceCapabilities2EXT,
    _p: PhantomData<&'b ()>, 
    set_mask: SurfaceCapabilities2ExtFlags,
}

impl<'b> SurfaceCapabilities2ExtBuilder<'b> {
    pub fn new() -> SurfaceCapabilities2ExtBuilder<'b> {
        SurfaceCapabilities2ExtBuilder {
            raw: vks::VkSurfaceCapabilities2EXT::default(),
            _p: PhantomData,
            set_mask: SurfaceCapabilities2ExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_PNEXT;
        self
    }

    pub fn min_image_count<'m>(mut self, min_image_count: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.minImageCount = min_image_count.into();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_MINIMAGECOUNT;
        self
    }

    pub fn max_image_count<'m>(mut self, max_image_count: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageCount = max_image_count.into();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGECOUNT;
        self
    }

    pub fn current_extent<'m>(mut self, current_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.currentExtent = current_extent.raw;
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_CURRENTEXTENT;
        self
    }

    pub fn min_image_extent<'m>(mut self, min_image_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.minImageExtent = min_image_extent.raw;
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_MINIMAGEEXTENT;
        self
    }

    pub fn max_image_extent<'m>(mut self, max_image_extent: Extent2d) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageExtent = max_image_extent.raw;
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEEXTENT;
        self
    }

    pub fn max_image_array_layers<'m>(mut self, max_image_array_layers: u32) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.maxImageArrayLayers = max_image_array_layers.into();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEARRAYLAYERS;
        self
    }

    pub fn supported_transforms<'m>(mut self, supported_transforms: SurfaceTransformFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedTransforms = supported_transforms.bits();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDTRANSFORMS;
        self
    }

    pub fn current_transform<'m>(mut self, current_transform: SurfaceTransformFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.currentTransform = current_transform.bits();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_CURRENTTRANSFORM;
        self
    }

    pub fn supported_composite_alpha<'m>(mut self, supported_composite_alpha: CompositeAlphaFlagsKhr) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedCompositeAlpha = supported_composite_alpha.bits();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDCOMPOSITEALPHA;
        self
    }

    pub fn supported_usage_flags<'m>(mut self, supported_usage_flags: ImageUsageFlags) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedUsageFlags = supported_usage_flags.bits();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDUSAGEFLAGS;
        self
    }

    pub fn supported_surface_counters<'m>(mut self, supported_surface_counters: SurfaceCounterFlagsExt) -> SurfaceCapabilities2ExtBuilder<'b> {
        self.raw.supportedSurfaceCounters = supported_surface_counters.bits();
        self.set_mask |= SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDSURFACECOUNTERS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_PNEXT != SurfaceCapabilities2ExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_min_image_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MINIMAGECOUNT != SurfaceCapabilities2ExtFlags::FLAG_MINIMAGECOUNT { return None }
        Some( self.raw.minImageCount.into() )
    }

    pub fn get_max_image_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGECOUNT != SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGECOUNT { return None }
        Some( self.raw.maxImageCount.into() )
    }

    pub fn get_current_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_CURRENTEXTENT != SurfaceCapabilities2ExtFlags::FLAG_CURRENTEXTENT { return None }
        Some(  unsafe { &*(&self.raw.currentExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_current_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_CURRENTEXTENT != SurfaceCapabilities2ExtFlags::FLAG_CURRENTEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.currentExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_min_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MINIMAGEEXTENT != SurfaceCapabilities2ExtFlags::FLAG_MINIMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.minImageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_min_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MINIMAGEEXTENT != SurfaceCapabilities2ExtFlags::FLAG_MINIMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.minImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_image_extent<'a>(&'a self) -> Option<&'a Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEEXTENT != SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEEXTENT { return None }
        Some(  unsafe { &*(&self.raw.maxImageExtent as *const vks::VkExtent2D as *const Extent2d) } )
    }

    pub fn get_max_image_extent_mut<'a>(&'a mut self) -> Option<&'a mut Extent2d> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEEXTENT != SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEEXTENT { return None }
        Some( unsafe { &mut *(&mut self.raw.maxImageExtent as *mut  vks::VkExtent2D as *mut Extent2d) } )
    }

    pub fn get_max_image_array_layers<'a>(&'a self) -> Option<u32> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEARRAYLAYERS != SurfaceCapabilities2ExtFlags::FLAG_MAXIMAGEARRAYLAYERS { return None }
        Some( self.raw.maxImageArrayLayers.into() )
    }

    pub fn get_supported_transforms<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDTRANSFORMS != SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDTRANSFORMS { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.supportedTransforms)
            .expect("SurfaceCapabilities2Ext::supported_transforms: error converting flags") )
    }

    pub fn get_current_transform<'a>(&'a self) -> Option<SurfaceTransformFlagsKhr> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_CURRENTTRANSFORM != SurfaceCapabilities2ExtFlags::FLAG_CURRENTTRANSFORM { return None }
        Some( SurfaceTransformFlagsKhr::from_bits(self.raw.currentTransform)
            .expect("SurfaceCapabilities2Ext::current_transform: error converting flags") )
    }

    pub fn get_supported_composite_alpha<'a>(&'a self) -> Option<CompositeAlphaFlagsKhr> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDCOMPOSITEALPHA != SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDCOMPOSITEALPHA { return None }
        Some( CompositeAlphaFlagsKhr::from_bits(self.raw.supportedCompositeAlpha)
            .expect("SurfaceCapabilities2Ext::supported_composite_alpha: error converting flags") )
    }

    pub fn get_supported_usage_flags<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDUSAGEFLAGS != SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDUSAGEFLAGS { return None }
        Some( ImageUsageFlags::from_bits(self.raw.supportedUsageFlags)
            .expect("SurfaceCapabilities2Ext::supported_usage_flags: error converting flags") )
    }

    pub fn get_supported_surface_counters<'a>(&'a self) -> Option<SurfaceCounterFlagsExt> {
        if self.set_mask & SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDSURFACECOUNTERS != SurfaceCapabilities2ExtFlags::FLAG_SUPPORTEDSURFACECOUNTERS { return None }
        Some( SurfaceCounterFlagsExt::from_bits(self.raw.supportedSurfaceCounters)
            .expect("SurfaceCapabilities2Ext::supported_surface_counters: error converting flags") )
    }

    pub fn build(self) -> SurfaceCapabilities2Ext<'b> {
        SurfaceCapabilities2Ext {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayPowerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayPowerInfoExt<'s> {
    raw: vks::VkDisplayPowerInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayPowerInfoExt<'s> {
    pub fn builder<'b>() -> DisplayPowerInfoExtBuilder<'b> {
        DisplayPowerInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayPowerInfoEXT) -> DisplayPowerInfoExt<'s> {
        DisplayPowerInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn power_state<'a>(&'a self) -> DisplayPowerStateExt {
        self.raw.powerState.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_power_state<'m>(&mut self, power_state: DisplayPowerStateExt) {
        self.raw.powerState = power_state.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayPowerInfoEXT {
        &self.raw
    }
}

impl<'s> From<DisplayPowerInfoExt<'s>> for vks::VkDisplayPowerInfoEXT {
    fn from(f: DisplayPowerInfoExt<'s>) -> vks::VkDisplayPowerInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDisplayPowerInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayPowerInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_POWERSTATE			 = 0b100;
    }
}


/// A builder for `VkDisplayPowerInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayPowerInfoExtBuilder<'b> {
    raw: vks::VkDisplayPowerInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplayPowerInfoExtFlags,
}

impl<'b> DisplayPowerInfoExtBuilder<'b> {
    pub fn new() -> DisplayPowerInfoExtBuilder<'b> {
        DisplayPowerInfoExtBuilder {
            raw: vks::VkDisplayPowerInfoEXT::default(),
            _p: PhantomData,
            set_mask: DisplayPowerInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayPowerInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DisplayPowerInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn power_state<'m>(mut self, power_state: DisplayPowerStateExt) -> DisplayPowerInfoExtBuilder<'b> {
        self.raw.powerState = power_state.into();
        self.set_mask |= DisplayPowerInfoExtFlags::FLAG_POWERSTATE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DisplayPowerInfoExtFlags::FLAG_PNEXT != DisplayPowerInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_power_state<'a>(&'a self) -> Option<DisplayPowerStateExt> {
        if self.set_mask & DisplayPowerInfoExtFlags::FLAG_POWERSTATE != DisplayPowerInfoExtFlags::FLAG_POWERSTATE { return None }
        Some( self.raw.powerState.into() )
    }

    pub fn build(self) -> DisplayPowerInfoExt<'b> {
        DisplayPowerInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceEventInfoExt<'s> {
    raw: vks::VkDeviceEventInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DeviceEventInfoExt<'s> {
    pub fn builder<'b>() -> DeviceEventInfoExtBuilder<'b> {
        DeviceEventInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceEventInfoEXT) -> DeviceEventInfoExt<'s> {
        DeviceEventInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn device_event<'a>(&'a self) -> DeviceEventTypeExt {
        self.raw.deviceEvent.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_device_event<'m>(&mut self, device_event: DeviceEventTypeExt) {
        self.raw.deviceEvent = device_event.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceEventInfoEXT {
        &self.raw
    }
}

impl<'s> From<DeviceEventInfoExt<'s>> for vks::VkDeviceEventInfoEXT {
    fn from(f: DeviceEventInfoExt<'s>) -> vks::VkDeviceEventInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDeviceEventInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceEventInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DEVICEEVENT			 = 0b100;
    }
}


/// A builder for `VkDeviceEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DeviceEventInfoExtBuilder<'b> {
    raw: vks::VkDeviceEventInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceEventInfoExtFlags,
}

impl<'b> DeviceEventInfoExtBuilder<'b> {
    pub fn new() -> DeviceEventInfoExtBuilder<'b> {
        DeviceEventInfoExtBuilder {
            raw: vks::VkDeviceEventInfoEXT::default(),
            _p: PhantomData,
            set_mask: DeviceEventInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceEventInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceEventInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn device_event<'m>(mut self, device_event: DeviceEventTypeExt) -> DeviceEventInfoExtBuilder<'b> {
        self.raw.deviceEvent = device_event.into();
        self.set_mask |= DeviceEventInfoExtFlags::FLAG_DEVICEEVENT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceEventInfoExtFlags::FLAG_PNEXT != DeviceEventInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_device_event<'a>(&'a self) -> Option<DeviceEventTypeExt> {
        if self.set_mask & DeviceEventInfoExtFlags::FLAG_DEVICEEVENT != DeviceEventInfoExtFlags::FLAG_DEVICEEVENT { return None }
        Some( self.raw.deviceEvent.into() )
    }

    pub fn build(self) -> DeviceEventInfoExt<'b> {
        DeviceEventInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDisplayEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DisplayEventInfoExt<'s> {
    raw: vks::VkDisplayEventInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> DisplayEventInfoExt<'s> {
    pub fn builder<'b>() -> DisplayEventInfoExtBuilder<'b> {
        DisplayEventInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDisplayEventInfoEXT) -> DisplayEventInfoExt<'s> {
        DisplayEventInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn display_event<'a>(&'a self) -> DisplayEventTypeExt {
        self.raw.displayEvent.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_display_event<'m>(&mut self, display_event: DisplayEventTypeExt) {
        self.raw.displayEvent = display_event.into();
    }

    pub fn as_raw(&self) -> &vks::VkDisplayEventInfoEXT {
        &self.raw
    }
}

impl<'s> From<DisplayEventInfoExt<'s>> for vks::VkDisplayEventInfoEXT {
    fn from(f: DisplayEventInfoExt<'s>) -> vks::VkDisplayEventInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkDisplayEventInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DisplayEventInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DISPLAYEVENT			 = 0b100;
    }
}


/// A builder for `VkDisplayEventInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DisplayEventInfoExtBuilder<'b> {
    raw: vks::VkDisplayEventInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: DisplayEventInfoExtFlags,
}

impl<'b> DisplayEventInfoExtBuilder<'b> {
    pub fn new() -> DisplayEventInfoExtBuilder<'b> {
        DisplayEventInfoExtBuilder {
            raw: vks::VkDisplayEventInfoEXT::default(),
            _p: PhantomData,
            set_mask: DisplayEventInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DisplayEventInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DisplayEventInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn display_event<'m>(mut self, display_event: DisplayEventTypeExt) -> DisplayEventInfoExtBuilder<'b> {
        self.raw.displayEvent = display_event.into();
        self.set_mask |= DisplayEventInfoExtFlags::FLAG_DISPLAYEVENT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DisplayEventInfoExtFlags::FLAG_PNEXT != DisplayEventInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_display_event<'a>(&'a self) -> Option<DisplayEventTypeExt> {
        if self.set_mask & DisplayEventInfoExtFlags::FLAG_DISPLAYEVENT != DisplayEventInfoExtFlags::FLAG_DISPLAYEVENT { return None }
        Some( self.raw.displayEvent.into() )
    }

    pub fn build(self) -> DisplayEventInfoExt<'b> {
        DisplayEventInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSwapchainCounterCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SwapchainCounterCreateInfoExt<'s> {
    raw: vks::VkSwapchainCounterCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SwapchainCounterCreateInfoExt<'s> {
    pub fn builder<'b>() -> SwapchainCounterCreateInfoExtBuilder<'b> {
        SwapchainCounterCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSwapchainCounterCreateInfoEXT) -> SwapchainCounterCreateInfoExt<'s> {
        SwapchainCounterCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn surface_counters<'a>(&'a self) -> SurfaceCounterFlagsExt {
        SurfaceCounterFlagsExt::from_bits(self.raw.surfaceCounters)
            .expect("SwapchainCounterCreateInfoExt::surface_counters: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_counters<'m>(&mut self, surface_counters: SurfaceCounterFlagsExt) {
        self.raw.surfaceCounters = surface_counters.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSwapchainCounterCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<SwapchainCounterCreateInfoExt<'s>> for vks::VkSwapchainCounterCreateInfoEXT {
    fn from(f: SwapchainCounterCreateInfoExt<'s>) -> vks::VkSwapchainCounterCreateInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkSwapchainCounterCreateInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SwapchainCounterCreateInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SURFACECOUNTERS			 = 0b100;
    }
}


/// A builder for `VkSwapchainCounterCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SwapchainCounterCreateInfoExtBuilder<'b> {
    raw: vks::VkSwapchainCounterCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: SwapchainCounterCreateInfoExtFlags,
}

impl<'b> SwapchainCounterCreateInfoExtBuilder<'b> {
    pub fn new() -> SwapchainCounterCreateInfoExtBuilder<'b> {
        SwapchainCounterCreateInfoExtBuilder {
            raw: vks::VkSwapchainCounterCreateInfoEXT::default(),
            _p: PhantomData,
            set_mask: SwapchainCounterCreateInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SwapchainCounterCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SwapchainCounterCreateInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn surface_counters<'m>(mut self, surface_counters: SurfaceCounterFlagsExt) -> SwapchainCounterCreateInfoExtBuilder<'b> {
        self.raw.surfaceCounters = surface_counters.bits();
        self.set_mask |= SwapchainCounterCreateInfoExtFlags::FLAG_SURFACECOUNTERS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SwapchainCounterCreateInfoExtFlags::FLAG_PNEXT != SwapchainCounterCreateInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_surface_counters<'a>(&'a self) -> Option<SurfaceCounterFlagsExt> {
        if self.set_mask & SwapchainCounterCreateInfoExtFlags::FLAG_SURFACECOUNTERS != SwapchainCounterCreateInfoExtFlags::FLAG_SURFACECOUNTERS { return None }
        Some( SurfaceCounterFlagsExt::from_bits(self.raw.surfaceCounters)
            .expect("SwapchainCounterCreateInfoExt::surface_counters: error converting flags") )
    }

    pub fn build(self) -> SwapchainCounterCreateInfoExt<'b> {
        SwapchainCounterCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryAllocateFlagsInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryAllocateFlagsInfoKhx<'s> {
    raw: vks::VkMemoryAllocateFlagsInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> MemoryAllocateFlagsInfoKhx<'s> {
    pub fn builder<'b>() -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        MemoryAllocateFlagsInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryAllocateFlagsInfoKHX) -> MemoryAllocateFlagsInfoKhx<'s> {
        MemoryAllocateFlagsInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MemoryAllocateFlagsKhx {
        MemoryAllocateFlagsKhx::from_bits(self.raw.flags)
            .expect("MemoryAllocateFlagsInfoKhx::flags: error converting flags")
    }

    pub fn device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MemoryAllocateFlagsKhx) {
        self.raw.flags = flags.bits();
    }

    pub fn set_device_mask<'m>(&mut self, device_mask: u32) {
        self.raw.deviceMask = device_mask.into();
    }

    pub fn as_raw(&self) -> &vks::VkMemoryAllocateFlagsInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<MemoryAllocateFlagsInfoKhx<'s>> for vks::VkMemoryAllocateFlagsInfoKHX {
    fn from(f: MemoryAllocateFlagsInfoKhx<'s>) -> vks::VkMemoryAllocateFlagsInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkMemoryAllocateFlagsInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryAllocateFlagsInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DEVICEMASK			 = 0b1000;
    }
}


/// A builder for `VkMemoryAllocateFlagsInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct MemoryAllocateFlagsInfoKhxBuilder<'b> {
    raw: vks::VkMemoryAllocateFlagsInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryAllocateFlagsInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> MemoryAllocateFlagsInfoKhxBuilder<'b> {
    pub fn new() -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        MemoryAllocateFlagsInfoKhxBuilder {
            raw: vks::VkMemoryAllocateFlagsInfoKHX::default(),
            _p: PhantomData,
            set_mask: MemoryAllocateFlagsInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryAllocateFlagsInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: MemoryAllocateFlagsKhx) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= MemoryAllocateFlagsInfoKhxFlags::FLAG_FLAGS;
        self
    }

    pub fn device_mask<'m>(mut self, device_mask: u32) -> MemoryAllocateFlagsInfoKhxBuilder<'b> {
        self.raw.deviceMask = device_mask.into();
        self.set_mask |= MemoryAllocateFlagsInfoKhxFlags::FLAG_DEVICEMASK;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryAllocateFlagsInfoKhxFlags::FLAG_PNEXT != MemoryAllocateFlagsInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<MemoryAllocateFlagsKhx> {
        if self.set_mask & MemoryAllocateFlagsInfoKhxFlags::FLAG_FLAGS != MemoryAllocateFlagsInfoKhxFlags::FLAG_FLAGS { return None }
        Some( MemoryAllocateFlagsKhx::from_bits(self.raw.flags)
            .expect("MemoryAllocateFlagsInfoKhx::flags: error converting flags") )
    }

    pub fn get_device_mask<'a>(&'a self) -> Option<u32> {
        if self.set_mask & MemoryAllocateFlagsInfoKhxFlags::FLAG_DEVICEMASK != MemoryAllocateFlagsInfoKhxFlags::FLAG_DEVICEMASK { return None }
        Some( self.raw.deviceMask.into() )
    }

    pub fn build(self) -> MemoryAllocateFlagsInfoKhx<'b> {
        MemoryAllocateFlagsInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupSubmitInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupSubmitInfoKhx<'s> {
    raw: vks::VkDeviceGroupSubmitInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupSubmitInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        DeviceGroupSubmitInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupSubmitInfoKHX) -> DeviceGroupSubmitInfoKhx<'s> {
        DeviceGroupSubmitInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn wait_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreDeviceIndices as *const _, self.raw.waitSemaphoreCount as usize) }
    }

    pub fn command_buffer_device_masks<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pCommandBufferDeviceMasks as *const _, self.raw.commandBufferCount as usize) }
    }

    pub fn signal_semaphore_device_indices<'a>(&'a self) -> &'a [u32] {
        unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreDeviceIndices as *const _, self.raw.signalSemaphoreCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_wait_semaphore_device_indices<'m, 'a>(&mut self, wait_semaphore_device_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::wait_semaphore_device_indices`.");
        self.raw.waitSemaphoreCount = wait_semaphore_device_indices.len() as _;
        self.raw.pWaitSemaphoreDeviceIndices = wait_semaphore_device_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn set_command_buffer_device_masks<'m, 'a>(&mut self, command_buffer_device_masks: &'a [u32])
            where 'a: 's {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffer_device_masks.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::command_buffer_device_masks`.");
        self.raw.commandBufferCount = command_buffer_device_masks.len() as _;
        self.raw.pCommandBufferDeviceMasks = command_buffer_device_masks.as_ptr() as *const u32 as *const _;
    }

    pub fn set_signal_semaphore_device_indices<'m, 'a>(&mut self, signal_semaphore_device_indices: &'a [u32])
            where 'a: 's {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::signal_semaphore_device_indices`.");
        self.raw.signalSemaphoreCount = signal_semaphore_device_indices.len() as _;
        self.raw.pSignalSemaphoreDeviceIndices = signal_semaphore_device_indices.as_ptr() as *const u32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupSubmitInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupSubmitInfoKhx<'s>> for vks::VkDeviceGroupSubmitInfoKHX {
    fn from(f: DeviceGroupSubmitInfoKhx<'s>) -> vks::VkDeviceGroupSubmitInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGroupSubmitInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGroupSubmitInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_WAITSEMAPHORECOUNT			 = 0b100;
        const FLAG_PWAITSEMAPHOREDEVICEINDICES			 = 0b1000;
        const FLAG_COMMANDBUFFERCOUNT			 = 0b10000;
        const FLAG_PCOMMANDBUFFERDEVICEMASKS			 = 0b100000;
        const FLAG_SIGNALSEMAPHORECOUNT			 = 0b1000000;
        const FLAG_PSIGNALSEMAPHOREDEVICEINDICES			 = 0b10000000;
    }
}


/// A builder for `VkDeviceGroupSubmitInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupSubmitInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupSubmitInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGroupSubmitInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupSubmitInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        DeviceGroupSubmitInfoKhxBuilder {
            raw: vks::VkDeviceGroupSubmitInfoKHX::default(),
            _p: PhantomData,
            set_mask: DeviceGroupSubmitInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupSubmitInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn wait_semaphore_device_indices<'m, 'a>(mut self, wait_semaphore_device_indices: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.waitSemaphoreCount == 0 || self.raw.waitSemaphoreCount == wait_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::wait_semaphore_device_indices`.");
        self.raw.waitSemaphoreCount = wait_semaphore_device_indices.len() as _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_WAITSEMAPHORECOUNT;
        self.raw.pWaitSemaphoreDeviceIndices = wait_semaphore_device_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_PWAITSEMAPHOREDEVICEINDICES;
        self
    }

    pub fn command_buffer_device_masks<'m, 'a>(mut self, command_buffer_device_masks: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.commandBufferCount == 0 || self.raw.commandBufferCount == command_buffer_device_masks.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::command_buffer_device_masks`.");
        self.raw.commandBufferCount = command_buffer_device_masks.len() as _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_COMMANDBUFFERCOUNT;
        self.raw.pCommandBufferDeviceMasks = command_buffer_device_masks.as_ptr() as *const u32 as *const _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_PCOMMANDBUFFERDEVICEMASKS;
        self
    }

    pub fn signal_semaphore_device_indices<'m, 'a>(mut self, signal_semaphore_device_indices: &'a [u32]) -> DeviceGroupSubmitInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.signalSemaphoreCount == 0 || self.raw.signalSemaphoreCount == signal_semaphore_device_indices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupSubmitInfoKhx::signal_semaphore_device_indices`.");
        self.raw.signalSemaphoreCount = signal_semaphore_device_indices.len() as _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_SIGNALSEMAPHORECOUNT;
        self.raw.pSignalSemaphoreDeviceIndices = signal_semaphore_device_indices.as_ptr() as *const u32 as *const _;
        self.set_mask |= DeviceGroupSubmitInfoKhxFlags::FLAG_PSIGNALSEMAPHOREDEVICEINDICES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGroupSubmitInfoKhxFlags::FLAG_PNEXT != DeviceGroupSubmitInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_wait_semaphore_device_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & DeviceGroupSubmitInfoKhxFlags::FLAG_PWAITSEMAPHOREDEVICEINDICES != DeviceGroupSubmitInfoKhxFlags::FLAG_PWAITSEMAPHOREDEVICEINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pWaitSemaphoreDeviceIndices as *const _, self.raw.waitSemaphoreCount as usize) } )
    }

    pub fn get_command_buffer_device_masks<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & DeviceGroupSubmitInfoKhxFlags::FLAG_PCOMMANDBUFFERDEVICEMASKS != DeviceGroupSubmitInfoKhxFlags::FLAG_PCOMMANDBUFFERDEVICEMASKS { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pCommandBufferDeviceMasks as *const _, self.raw.commandBufferCount as usize) } )
    }

    pub fn get_signal_semaphore_device_indices<'a>(&'a self) -> Option<&'a [u32]> {
        if self.set_mask & DeviceGroupSubmitInfoKhxFlags::FLAG_PSIGNALSEMAPHOREDEVICEINDICES != DeviceGroupSubmitInfoKhxFlags::FLAG_PSIGNALSEMAPHOREDEVICEINDICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pSignalSemaphoreDeviceIndices as *const _, self.raw.signalSemaphoreCount as usize) } )
    }

    pub fn build(self) -> DeviceGroupSubmitInfoKhx<'b> {
        DeviceGroupSubmitInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupBindSparseInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupBindSparseInfoKhx<'s> {
    raw: vks::VkDeviceGroupBindSparseInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupBindSparseInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        DeviceGroupBindSparseInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupBindSparseInfoKHX) -> DeviceGroupBindSparseInfoKhx<'s> {
        DeviceGroupBindSparseInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn resource_device_index<'a>(&'a self) -> u32 {
        self.raw.resourceDeviceIndex.into()
    }

    pub fn memory_device_index<'a>(&'a self) -> u32 {
        self.raw.memoryDeviceIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_resource_device_index<'m>(&mut self, resource_device_index: u32) {
        self.raw.resourceDeviceIndex = resource_device_index.into();
    }

    pub fn set_memory_device_index<'m>(&mut self, memory_device_index: u32) {
        self.raw.memoryDeviceIndex = memory_device_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupBindSparseInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupBindSparseInfoKhx<'s>> for vks::VkDeviceGroupBindSparseInfoKHX {
    fn from(f: DeviceGroupBindSparseInfoKhx<'s>) -> vks::VkDeviceGroupBindSparseInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGroupBindSparseInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGroupBindSparseInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_RESOURCEDEVICEINDEX			 = 0b100;
        const FLAG_MEMORYDEVICEINDEX			 = 0b1000;
    }
}


/// A builder for `VkDeviceGroupBindSparseInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupBindSparseInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupBindSparseInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGroupBindSparseInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupBindSparseInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        DeviceGroupBindSparseInfoKhxBuilder {
            raw: vks::VkDeviceGroupBindSparseInfoKHX::default(),
            _p: PhantomData,
            set_mask: DeviceGroupBindSparseInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGroupBindSparseInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn resource_device_index<'m>(mut self, resource_device_index: u32) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.resourceDeviceIndex = resource_device_index.into();
        self.set_mask |= DeviceGroupBindSparseInfoKhxFlags::FLAG_RESOURCEDEVICEINDEX;
        self
    }

    pub fn memory_device_index<'m>(mut self, memory_device_index: u32) -> DeviceGroupBindSparseInfoKhxBuilder<'b> {
        self.raw.memoryDeviceIndex = memory_device_index.into();
        self.set_mask |= DeviceGroupBindSparseInfoKhxFlags::FLAG_MEMORYDEVICEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGroupBindSparseInfoKhxFlags::FLAG_PNEXT != DeviceGroupBindSparseInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_resource_device_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGroupBindSparseInfoKhxFlags::FLAG_RESOURCEDEVICEINDEX != DeviceGroupBindSparseInfoKhxFlags::FLAG_RESOURCEDEVICEINDEX { return None }
        Some( self.raw.resourceDeviceIndex.into() )
    }

    pub fn get_memory_device_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DeviceGroupBindSparseInfoKhxFlags::FLAG_MEMORYDEVICEINDEX != DeviceGroupBindSparseInfoKhxFlags::FLAG_MEMORYDEVICEINDEX { return None }
        Some( self.raw.memoryDeviceIndex.into() )
    }

    pub fn build(self) -> DeviceGroupBindSparseInfoKhx<'b> {
        DeviceGroupBindSparseInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupPresentCapabilitiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupPresentCapabilitiesKhx<'s> {
    raw: vks::VkDeviceGroupPresentCapabilitiesKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupPresentCapabilitiesKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        DeviceGroupPresentCapabilitiesKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupPresentCapabilitiesKHX) -> DeviceGroupPresentCapabilitiesKhx<'s> {
        DeviceGroupPresentCapabilitiesKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn present_mask<'a>(&'a self) -> &[u32] {
        unsafe { slice::from_raw_parts(&self.raw.presentMask as *const _, vks::VK_MAX_DEVICE_GROUP_SIZE_KHX as usize) }
    }

    pub fn modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupPresentCapabilitiesKhx::modes: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_present_mask<'m>(&mut self, present_mask: [u32; vks::VK_MAX_DEVICE_GROUP_SIZE_KHX]) {
        self.raw.presentMask = present_mask;
    }

    pub fn set_modes<'m>(&mut self, modes: DeviceGroupPresentModeFlagsKhx) {
        self.raw.modes = modes.bits();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupPresentCapabilitiesKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupPresentCapabilitiesKhx<'s>> for vks::VkDeviceGroupPresentCapabilitiesKHX {
    fn from(f: DeviceGroupPresentCapabilitiesKhx<'s>) -> vks::VkDeviceGroupPresentCapabilitiesKHX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGroupPresentCapabilitiesKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGroupPresentCapabilitiesKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PRESENTMASK			 = 0b100;
        const FLAG_MODES			 = 0b1000;
    }
}


/// A builder for `VkDeviceGroupPresentCapabilitiesKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
    raw: vks::VkDeviceGroupPresentCapabilitiesKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGroupPresentCapabilitiesKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
    pub fn new() -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        DeviceGroupPresentCapabilitiesKhxBuilder {
            raw: vks::VkDeviceGroupPresentCapabilitiesKHX::default(),
            _p: PhantomData,
            set_mask: DeviceGroupPresentCapabilitiesKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn present_mask<'m>(mut self, present_mask: [u32; vks::VK_MAX_DEVICE_GROUP_SIZE_KHX]) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.presentMask = present_mask;
        self.set_mask |= DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PRESENTMASK;
        self
    }

    pub fn modes<'m>(mut self, modes: DeviceGroupPresentModeFlagsKhx) -> DeviceGroupPresentCapabilitiesKhxBuilder<'b> {
        self.raw.modes = modes.bits();
        self.set_mask |= DeviceGroupPresentCapabilitiesKhxFlags::FLAG_MODES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PNEXT != DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_present_mask<'a>(&'a self) -> Option<&[u32]> {
        if self.set_mask & DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PRESENTMASK != DeviceGroupPresentCapabilitiesKhxFlags::FLAG_PRESENTMASK { return None }
        Some( unsafe { slice::from_raw_parts(&self.raw.presentMask as *const _, vks::VK_MAX_DEVICE_GROUP_SIZE_KHX as usize) } )
    }

    pub fn get_modes<'a>(&'a self) -> Option<DeviceGroupPresentModeFlagsKhx> {
        if self.set_mask & DeviceGroupPresentCapabilitiesKhxFlags::FLAG_MODES != DeviceGroupPresentCapabilitiesKhxFlags::FLAG_MODES { return None }
        Some( DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupPresentCapabilitiesKhx::modes: error converting flags") )
    }

    pub fn build(self) -> DeviceGroupPresentCapabilitiesKhx<'b> {
        DeviceGroupPresentCapabilitiesKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSwapchainCreateInfoKhx<'s> {
    raw: vks::VkImageSwapchainCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> ImageSwapchainCreateInfoKhx<'s> {
    pub fn builder<'b>() -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        ImageSwapchainCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSwapchainCreateInfoKHX) -> ImageSwapchainCreateInfoKhx<'s> {
        ImageSwapchainCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageSwapchainCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<ImageSwapchainCreateInfoKhx<'s>> for vks::VkImageSwapchainCreateInfoKHX {
    fn from(f: ImageSwapchainCreateInfoKhx<'s>) -> vks::VkImageSwapchainCreateInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkImageSwapchainCreateInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageSwapchainCreateInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SWAPCHAIN			 = 0b100;
    }
}


/// A builder for `VkImageSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct ImageSwapchainCreateInfoKhxBuilder<'b> {
    raw: vks::VkImageSwapchainCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageSwapchainCreateInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> ImageSwapchainCreateInfoKhxBuilder<'b> {
    pub fn new() -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        ImageSwapchainCreateInfoKhxBuilder {
            raw: vks::VkImageSwapchainCreateInfoKHX::default(),
            _p: PhantomData,
            set_mask: ImageSwapchainCreateInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageSwapchainCreateInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> ImageSwapchainCreateInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self.set_mask |= ImageSwapchainCreateInfoKhxFlags::FLAG_SWAPCHAIN;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageSwapchainCreateInfoKhxFlags::FLAG_PNEXT != ImageSwapchainCreateInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_swapchain<'a>(&'a self) -> Option<vks::VkSwapchainKHR> {
        if self.set_mask & ImageSwapchainCreateInfoKhxFlags::FLAG_SWAPCHAIN != ImageSwapchainCreateInfoKhxFlags::FLAG_SWAPCHAIN { return None }
        Some( self.raw.swapchain )
    }

    pub fn build(self) -> ImageSwapchainCreateInfoKhx<'b> {
        ImageSwapchainCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBindImageMemorySwapchainInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BindImageMemorySwapchainInfoKhx<'s> {
    raw: vks::VkBindImageMemorySwapchainInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> BindImageMemorySwapchainInfoKhx<'s> {
    pub fn builder<'b>() -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        BindImageMemorySwapchainInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBindImageMemorySwapchainInfoKHX) -> BindImageMemorySwapchainInfoKhx<'s> {
        BindImageMemorySwapchainInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn image_index<'a>(&'a self) -> u32 {
        self.raw.imageIndex.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn set_image_index<'m>(&mut self, image_index: u32) {
        self.raw.imageIndex = image_index.into();
    }

    pub fn as_raw(&self) -> &vks::VkBindImageMemorySwapchainInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<BindImageMemorySwapchainInfoKhx<'s>> for vks::VkBindImageMemorySwapchainInfoKHX {
    fn from(f: BindImageMemorySwapchainInfoKhx<'s>) -> vks::VkBindImageMemorySwapchainInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkBindImageMemorySwapchainInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BindImageMemorySwapchainInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SWAPCHAIN			 = 0b100;
        const FLAG_IMAGEINDEX			 = 0b1000;
    }
}


/// A builder for `VkBindImageMemorySwapchainInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct BindImageMemorySwapchainInfoKhxBuilder<'b> {
    raw: vks::VkBindImageMemorySwapchainInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: BindImageMemorySwapchainInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> BindImageMemorySwapchainInfoKhxBuilder<'b> {
    pub fn new() -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        BindImageMemorySwapchainInfoKhxBuilder {
            raw: vks::VkBindImageMemorySwapchainInfoKHX::default(),
            _p: PhantomData,
            set_mask: BindImageMemorySwapchainInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BindImageMemorySwapchainInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> BindImageMemorySwapchainInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self.set_mask |= BindImageMemorySwapchainInfoKhxFlags::FLAG_SWAPCHAIN;
        self
    }

    pub fn image_index<'m>(mut self, image_index: u32) -> BindImageMemorySwapchainInfoKhxBuilder<'b> {
        self.raw.imageIndex = image_index.into();
        self.set_mask |= BindImageMemorySwapchainInfoKhxFlags::FLAG_IMAGEINDEX;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BindImageMemorySwapchainInfoKhxFlags::FLAG_PNEXT != BindImageMemorySwapchainInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_swapchain<'a>(&'a self) -> Option<vks::VkSwapchainKHR> {
        if self.set_mask & BindImageMemorySwapchainInfoKhxFlags::FLAG_SWAPCHAIN != BindImageMemorySwapchainInfoKhxFlags::FLAG_SWAPCHAIN { return None }
        Some( self.raw.swapchain )
    }

    pub fn get_image_index<'a>(&'a self) -> Option<u32> {
        if self.set_mask & BindImageMemorySwapchainInfoKhxFlags::FLAG_IMAGEINDEX != BindImageMemorySwapchainInfoKhxFlags::FLAG_IMAGEINDEX { return None }
        Some( self.raw.imageIndex.into() )
    }

    pub fn build(self) -> BindImageMemorySwapchainInfoKhx<'b> {
        BindImageMemorySwapchainInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkAcquireNextImageInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct AcquireNextImageInfoKhx<'s> {
    raw: vks::VkAcquireNextImageInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> AcquireNextImageInfoKhx<'s> {
    pub fn builder<'b>() -> AcquireNextImageInfoKhxBuilder<'b> {
        AcquireNextImageInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkAcquireNextImageInfoKHX) -> AcquireNextImageInfoKhx<'s> {
        AcquireNextImageInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn swapchain<'a>(&'a self) -> vks::VkSwapchainKHR {
        self.raw.swapchain
    }

    pub fn timeout<'a>(&'a self) -> u64 {
        self.raw.timeout.into()
    }

    pub fn semaphore<'a>(&'a self) -> vks::VkSemaphore {
        self.raw.semaphore
    }

    pub fn fence<'a>(&'a self) -> vks::VkFence {
        self.raw.fence
    }

    pub fn device_mask<'a>(&'a self) -> u32 {
        self.raw.deviceMask.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_swapchain<'m, H>(&mut self, swapchain: H)
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
    }

    pub fn set_timeout<'m>(&mut self, timeout: u64) {
        self.raw.timeout = timeout.into();
    }

    pub fn set_semaphore<'m, H>(&mut self, semaphore: H)
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
    }

    pub fn set_fence<'m, H>(&mut self, fence: H)
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
    }

    pub fn set_device_mask<'m>(&mut self, device_mask: u32) {
        self.raw.deviceMask = device_mask.into();
    }

    pub fn as_raw(&self) -> &vks::VkAcquireNextImageInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<AcquireNextImageInfoKhx<'s>> for vks::VkAcquireNextImageInfoKHX {
    fn from(f: AcquireNextImageInfoKhx<'s>) -> vks::VkAcquireNextImageInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkAcquireNextImageInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct AcquireNextImageInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SWAPCHAIN			 = 0b100;
        const FLAG_TIMEOUT			 = 0b1000;
        const FLAG_SEMAPHORE			 = 0b10000;
        const FLAG_FENCE			 = 0b100000;
        const FLAG_DEVICEMASK			 = 0b1000000;
    }
}


/// A builder for `VkAcquireNextImageInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct AcquireNextImageInfoKhxBuilder<'b> {
    raw: vks::VkAcquireNextImageInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: AcquireNextImageInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> AcquireNextImageInfoKhxBuilder<'b> {
    pub fn new() -> AcquireNextImageInfoKhxBuilder<'b> {
        AcquireNextImageInfoKhxBuilder {
            raw: vks::VkAcquireNextImageInfoKHX::default(),
            _p: PhantomData,
            set_mask: AcquireNextImageInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn swapchain<'m, H>(mut self, swapchain: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=SwapchainKhrHandle> {
        self.raw.swapchain = swapchain.handle().0;
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_SWAPCHAIN;
        self
    }

    pub fn timeout<'m>(mut self, timeout: u64) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.timeout = timeout.into();
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_TIMEOUT;
        self
    }

    pub fn semaphore<'m, H>(mut self, semaphore: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=SemaphoreHandle> {
        self.raw.semaphore = semaphore.handle().0;
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_SEMAPHORE;
        self
    }

    pub fn fence<'m, H>(mut self, fence: H) -> AcquireNextImageInfoKhxBuilder<'b>
            where H: Handle<Target=FenceHandle> {
        self.raw.fence = fence.handle().0;
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_FENCE;
        self
    }

    pub fn device_mask<'m>(mut self, device_mask: u32) -> AcquireNextImageInfoKhxBuilder<'b> {
        self.raw.deviceMask = device_mask.into();
        self.set_mask |= AcquireNextImageInfoKhxFlags::FLAG_DEVICEMASK;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_PNEXT != AcquireNextImageInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_swapchain<'a>(&'a self) -> Option<vks::VkSwapchainKHR> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_SWAPCHAIN != AcquireNextImageInfoKhxFlags::FLAG_SWAPCHAIN { return None }
        Some( self.raw.swapchain )
    }

    pub fn get_timeout<'a>(&'a self) -> Option<u64> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_TIMEOUT != AcquireNextImageInfoKhxFlags::FLAG_TIMEOUT { return None }
        Some( self.raw.timeout.into() )
    }

    pub fn get_semaphore<'a>(&'a self) -> Option<vks::VkSemaphore> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_SEMAPHORE != AcquireNextImageInfoKhxFlags::FLAG_SEMAPHORE { return None }
        Some( self.raw.semaphore )
    }

    pub fn get_fence<'a>(&'a self) -> Option<vks::VkFence> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_FENCE != AcquireNextImageInfoKhxFlags::FLAG_FENCE { return None }
        Some( self.raw.fence )
    }

    pub fn get_device_mask<'a>(&'a self) -> Option<u32> {
        if self.set_mask & AcquireNextImageInfoKhxFlags::FLAG_DEVICEMASK != AcquireNextImageInfoKhxFlags::FLAG_DEVICEMASK { return None }
        Some( self.raw.deviceMask.into() )
    }

    pub fn build(self) -> AcquireNextImageInfoKhx<'b> {
        AcquireNextImageInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupDeviceCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupDeviceCreateInfoKhx<'s> {
    raw: vks::VkDeviceGroupDeviceCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupDeviceCreateInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        DeviceGroupDeviceCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupDeviceCreateInfoKHX) -> DeviceGroupDeviceCreateInfoKhx<'s> {
        DeviceGroupDeviceCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn physical_devices<'a>(&'a self) -> &'a [vks::VkPhysicalDevice] {
        unsafe { slice::from_raw_parts(self.raw.pPhysicalDevices as *const _, self.raw.physicalDeviceCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_physical_devices<'m, 'a>(&mut self, physical_devices: &'a [PhysicalDeviceHandle])
            where 'a: 's {
        assert!(self.raw.physicalDeviceCount == 0 || self.raw.physicalDeviceCount == physical_devices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupDeviceCreateInfoKhx::physical_devices`.");
        self.raw.physicalDeviceCount = physical_devices.len() as _;
        self.raw.pPhysicalDevices = physical_devices.as_ptr() as *const vks::VkPhysicalDevice;
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupDeviceCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupDeviceCreateInfoKhx<'s>> for vks::VkDeviceGroupDeviceCreateInfoKHX {
    fn from(f: DeviceGroupDeviceCreateInfoKhx<'s>) -> vks::VkDeviceGroupDeviceCreateInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGroupDeviceCreateInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGroupDeviceCreateInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PHYSICALDEVICECOUNT			 = 0b100;
        const FLAG_PPHYSICALDEVICES			 = 0b1000;
    }
}


/// A builder for `VkDeviceGroupDeviceCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupDeviceCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGroupDeviceCreateInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        DeviceGroupDeviceCreateInfoKhxBuilder {
            raw: vks::VkDeviceGroupDeviceCreateInfoKHX::default(),
            _p: PhantomData,
            set_mask: DeviceGroupDeviceCreateInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupDeviceCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn physical_devices<'m, 'a>(mut self, physical_devices: &'a [PhysicalDeviceHandle]) -> DeviceGroupDeviceCreateInfoKhxBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.physicalDeviceCount == 0 || self.raw.physicalDeviceCount == physical_devices.len() as _, 
            "count inconsistency found when specifying `DeviceGroupDeviceCreateInfoKhx::physical_devices`.");
        self.raw.physicalDeviceCount = physical_devices.len() as _;
        self.set_mask |= DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PHYSICALDEVICECOUNT;
        self.raw.pPhysicalDevices = physical_devices.as_ptr() as *const vks::VkPhysicalDevice;
        self.set_mask |= DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PPHYSICALDEVICES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PNEXT != DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_physical_devices<'a>(&'a self) -> Option<&'a [vks::VkPhysicalDevice]> {
        if self.set_mask & DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PPHYSICALDEVICES != DeviceGroupDeviceCreateInfoKhxFlags::FLAG_PPHYSICALDEVICES { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pPhysicalDevices as *const _, self.raw.physicalDeviceCount as usize) } )
    }

    pub fn build(self) -> DeviceGroupDeviceCreateInfoKhx<'b> {
        DeviceGroupDeviceCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDeviceGroupSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DeviceGroupSwapchainCreateInfoKhx<'s> {
    raw: vks::VkDeviceGroupSwapchainCreateInfoKHX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> DeviceGroupSwapchainCreateInfoKhx<'s> {
    pub fn builder<'b>() -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        DeviceGroupSwapchainCreateInfoKhxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDeviceGroupSwapchainCreateInfoKHX) -> DeviceGroupSwapchainCreateInfoKhx<'s> {
        DeviceGroupSwapchainCreateInfoKhx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn modes<'a>(&'a self) -> DeviceGroupPresentModeFlagsKhx {
        DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupSwapchainCreateInfoKhx::modes: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_modes<'m>(&mut self, modes: DeviceGroupPresentModeFlagsKhx) {
        self.raw.modes = modes.bits();
    }

    pub fn as_raw(&self) -> &vks::VkDeviceGroupSwapchainCreateInfoKHX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<DeviceGroupSwapchainCreateInfoKhx<'s>> for vks::VkDeviceGroupSwapchainCreateInfoKHX {
    fn from(f: DeviceGroupSwapchainCreateInfoKhx<'s>) -> vks::VkDeviceGroupSwapchainCreateInfoKHX {
        f.raw
    }
}


/// Bitflags for `VkDeviceGroupSwapchainCreateInfoKHX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DeviceGroupSwapchainCreateInfoKhxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MODES			 = 0b100;
    }
}


/// A builder for `VkDeviceGroupSwapchainCreateInfoKHX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
    raw: vks::VkDeviceGroupSwapchainCreateInfoKHX,
    _p: PhantomData<&'b ()>, 
    set_mask: DeviceGroupSwapchainCreateInfoKhxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
    pub fn new() -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        DeviceGroupSwapchainCreateInfoKhxBuilder {
            raw: vks::VkDeviceGroupSwapchainCreateInfoKHX::default(),
            _p: PhantomData,
            set_mask: DeviceGroupSwapchainCreateInfoKhxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_PNEXT;
        self
    }

    pub fn modes<'m>(mut self, modes: DeviceGroupPresentModeFlagsKhx) -> DeviceGroupSwapchainCreateInfoKhxBuilder<'b> {
        self.raw.modes = modes.bits();
        self.set_mask |= DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_MODES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_PNEXT != DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_modes<'a>(&'a self) -> Option<DeviceGroupPresentModeFlagsKhx> {
        if self.set_mask & DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_MODES != DeviceGroupSwapchainCreateInfoKhxFlags::FLAG_MODES { return None }
        Some( DeviceGroupPresentModeFlagsKhx::from_bits(self.raw.modes)
            .expect("DeviceGroupSwapchainCreateInfoKhx::modes: error converting flags") )
    }

    pub fn build(self) -> DeviceGroupSwapchainCreateInfoKhx<'b> {
        DeviceGroupSwapchainCreateInfoKhx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkDescriptorUpdateTemplateEntryKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorUpdateTemplateEntryKhr {
    raw: vks::VkDescriptorUpdateTemplateEntryKHR,
}

impl DescriptorUpdateTemplateEntryKhr {
    pub fn builder() -> DescriptorUpdateTemplateEntryKhrBuilder {
        DescriptorUpdateTemplateEntryKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorUpdateTemplateEntryKHR) -> DescriptorUpdateTemplateEntryKhr {
        DescriptorUpdateTemplateEntryKhr { raw, }
    }

    pub fn dst_binding<'a>(&'a self) -> u32 {
        self.raw.dstBinding.into()
    }

    pub fn dst_array_element<'a>(&'a self) -> u32 {
        self.raw.dstArrayElement.into()
    }

    pub fn descriptor_count<'a>(&'a self) -> u32 {
        self.raw.descriptorCount.into()
    }

    pub fn descriptor_type<'a>(&'a self) -> DescriptorType {
        self.raw.descriptorType.into()
    }

    pub fn offset<'a>(&'a self) -> usize {
        self.raw.offset.into()
    }

    pub fn stride<'a>(&'a self) -> usize {
        self.raw.stride.into()
    }

    pub fn set_dst_binding<'m>(&mut self, dst_binding: u32) {
        self.raw.dstBinding = dst_binding.into();
    }

    pub fn set_dst_array_element<'m>(&mut self, dst_array_element: u32) {
        self.raw.dstArrayElement = dst_array_element.into();
    }

    pub fn set_descriptor_count<'m>(&mut self, descriptor_count: u32) {
        self.raw.descriptorCount = descriptor_count.into();
    }

    pub fn set_descriptor_type<'m>(&mut self, descriptor_type: DescriptorType) {
        self.raw.descriptorType = descriptor_type.into();
    }

    pub fn set_offset<'m>(&mut self, offset: usize) {
        self.raw.offset = offset.into();
    }

    pub fn set_stride<'m>(&mut self, stride: usize) {
        self.raw.stride = stride.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorUpdateTemplateEntryKHR {
        &self.raw
    }
}

impl From<DescriptorUpdateTemplateEntryKhr> for vks::VkDescriptorUpdateTemplateEntryKHR {
    fn from(f: DescriptorUpdateTemplateEntryKhr) -> vks::VkDescriptorUpdateTemplateEntryKHR {
        f.raw
    }
}


/// Bitflags for `VkDescriptorUpdateTemplateEntryKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorUpdateTemplateEntryKhrFlags: u32 {
        const FLAG_DSTBINDING			 = 0b1;
        const FLAG_DSTARRAYELEMENT			 = 0b10;
        const FLAG_DESCRIPTORCOUNT			 = 0b100;
        const FLAG_DESCRIPTORTYPE			 = 0b1000;
        const FLAG_OFFSET			 = 0b10000;
        const FLAG_STRIDE			 = 0b100000;
    }
}


/// A builder for `VkDescriptorUpdateTemplateEntryKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorUpdateTemplateEntryKhrBuilder {
    raw: vks::VkDescriptorUpdateTemplateEntryKHR,
    set_mask: DescriptorUpdateTemplateEntryKhrFlags,
}

impl DescriptorUpdateTemplateEntryKhrBuilder {
    pub fn new() -> DescriptorUpdateTemplateEntryKhrBuilder {
        DescriptorUpdateTemplateEntryKhrBuilder {
            raw: vks::VkDescriptorUpdateTemplateEntryKHR::default(),
            set_mask: DescriptorUpdateTemplateEntryKhrFlags::default(),
        }
    }

    pub fn dst_binding<'m>(mut self, dst_binding: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.dstBinding = dst_binding.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTBINDING;
        self
    }

    pub fn dst_array_element<'m>(mut self, dst_array_element: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.dstArrayElement = dst_array_element.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTARRAYELEMENT;
        self
    }

    pub fn descriptor_count<'m>(mut self, descriptor_count: u32) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.descriptorCount = descriptor_count.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORCOUNT;
        self
    }

    pub fn descriptor_type<'m>(mut self, descriptor_type: DescriptorType) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.descriptorType = descriptor_type.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORTYPE;
        self
    }

    pub fn offset<'m>(mut self, offset: usize) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.offset = offset.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_OFFSET;
        self
    }

    pub fn stride<'m>(mut self, stride: usize) -> DescriptorUpdateTemplateEntryKhrBuilder {
        self.raw.stride = stride.into();
        self.set_mask |= DescriptorUpdateTemplateEntryKhrFlags::FLAG_STRIDE;
        self
    }

    pub fn get_dst_binding<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTBINDING != DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTBINDING { return None }
        Some( self.raw.dstBinding.into() )
    }

    pub fn get_dst_array_element<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTARRAYELEMENT != DescriptorUpdateTemplateEntryKhrFlags::FLAG_DSTARRAYELEMENT { return None }
        Some( self.raw.dstArrayElement.into() )
    }

    pub fn get_descriptor_count<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORCOUNT != DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORCOUNT { return None }
        Some( self.raw.descriptorCount.into() )
    }

    pub fn get_descriptor_type<'a>(&'a self) -> Option<DescriptorType> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORTYPE != DescriptorUpdateTemplateEntryKhrFlags::FLAG_DESCRIPTORTYPE { return None }
        Some( self.raw.descriptorType.into() )
    }

    pub fn get_offset<'a>(&'a self) -> Option<usize> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_OFFSET != DescriptorUpdateTemplateEntryKhrFlags::FLAG_OFFSET { return None }
        Some( self.raw.offset.into() )
    }

    pub fn get_stride<'a>(&'a self) -> Option<usize> {
        if self.set_mask & DescriptorUpdateTemplateEntryKhrFlags::FLAG_STRIDE != DescriptorUpdateTemplateEntryKhrFlags::FLAG_STRIDE { return None }
        Some( self.raw.stride.into() )
    }

    pub fn build(self) -> DescriptorUpdateTemplateEntryKhr {
        DescriptorUpdateTemplateEntryKhr {
            raw: self.raw,
        }
    }
}


/// A `VkDescriptorUpdateTemplateCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct DescriptorUpdateTemplateCreateInfoKhr<'s> {
    raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> DescriptorUpdateTemplateCreateInfoKhr<'s> {
    pub fn builder<'b>() -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        DescriptorUpdateTemplateCreateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR) -> DescriptorUpdateTemplateCreateInfoKhr<'s> {
        DescriptorUpdateTemplateCreateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> DescriptorUpdateTemplateCreateFlagsKhr {
        DescriptorUpdateTemplateCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DescriptorUpdateTemplateCreateInfoKhr::flags: error converting flags")
    }

    pub fn descriptor_update_entries<'a>(&'a self) -> &'a [DescriptorUpdateTemplateEntryKhr] {
        unsafe { slice::from_raw_parts(self.raw.pDescriptorUpdateEntries as *const _, self.raw.descriptorUpdateEntryCount as usize) }
    }

    pub fn template_type<'a>(&'a self) -> DescriptorUpdateTemplateTypeKhr {
        self.raw.templateType.into()
    }

    pub fn descriptor_set_layout<'a>(&'a self) -> vks::VkDescriptorSetLayout {
        self.raw.descriptorSetLayout
    }

    pub fn pipeline_bind_point<'a>(&'a self) -> PipelineBindPoint {
        self.raw.pipelineBindPoint.into()
    }

    pub fn pipeline_layout<'a>(&'a self) -> vks::VkPipelineLayout {
        self.raw.pipelineLayout
    }

    pub fn set<'a>(&'a self) -> u32 {
        self.raw.set.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: DescriptorUpdateTemplateCreateFlagsKhr) {
        self.raw.flags = flags.bits();
    }

    pub fn set_descriptor_update_entries<'m, 'a>(&mut self, descriptor_update_entries: &'a [DescriptorUpdateTemplateEntryKhr])
            where 'a: 's {
        assert!(self.raw.descriptorUpdateEntryCount == 0 || self.raw.descriptorUpdateEntryCount == descriptor_update_entries.len() as _, 
            "count inconsistency found when specifying `DescriptorUpdateTemplateCreateInfoKhr::descriptor_update_entries`.");
        self.raw.descriptorUpdateEntryCount = descriptor_update_entries.len() as _;
        self.raw.pDescriptorUpdateEntries = descriptor_update_entries.as_ptr() as *const vks::VkDescriptorUpdateTemplateEntryKHR;
    }

    pub fn set_template_type<'m>(&mut self, template_type: DescriptorUpdateTemplateTypeKhr) {
        self.raw.templateType = template_type.into();
    }

    pub fn set_descriptor_set_layout<'m, H>(&mut self, descriptor_set_layout: H)
            where H: Handle<Target=DescriptorSetLayoutHandle> {
        self.raw.descriptorSetLayout = descriptor_set_layout.handle().0;
    }

    pub fn set_pipeline_bind_point<'m>(&mut self, pipeline_bind_point: PipelineBindPoint) {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
    }

    pub fn set_pipeline_layout<'m, H>(&mut self, pipeline_layout: H)
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
    }

    pub fn set_set<'m>(&mut self, set: u32) {
        self.raw.set = set.into();
    }

    pub fn as_raw(&self) -> &vks::VkDescriptorUpdateTemplateCreateInfoKHR {
        &self.raw
    }
}

impl<'s> From<DescriptorUpdateTemplateCreateInfoKhr<'s>> for vks::VkDescriptorUpdateTemplateCreateInfoKHR {
    fn from(f: DescriptorUpdateTemplateCreateInfoKhr<'s>) -> vks::VkDescriptorUpdateTemplateCreateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkDescriptorUpdateTemplateCreateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct DescriptorUpdateTemplateCreateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DESCRIPTORUPDATEENTRYCOUNT			 = 0b1000;
        const FLAG_PDESCRIPTORUPDATEENTRIES			 = 0b10000;
        const FLAG_TEMPLATETYPE			 = 0b100000;
        const FLAG_DESCRIPTORSETLAYOUT			 = 0b1000000;
        const FLAG_PIPELINEBINDPOINT			 = 0b10000000;
        const FLAG_PIPELINELAYOUT			 = 0b100000000;
        const FLAG_SET			 = 0b1000000000;
    }
}


/// A builder for `VkDescriptorUpdateTemplateCreateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
    raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: DescriptorUpdateTemplateCreateInfoKhrFlags,
}

impl<'b> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
    pub fn new() -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        DescriptorUpdateTemplateCreateInfoKhrBuilder {
            raw: vks::VkDescriptorUpdateTemplateCreateInfoKHR::default(),
            _p: PhantomData,
            set_mask: DescriptorUpdateTemplateCreateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: DescriptorUpdateTemplateCreateFlagsKhr) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_FLAGS;
        self
    }

    pub fn descriptor_update_entries<'m, 'a>(mut self, descriptor_update_entries: &'a [DescriptorUpdateTemplateEntryKhr]) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.descriptorUpdateEntryCount == 0 || self.raw.descriptorUpdateEntryCount == descriptor_update_entries.len() as _, 
            "count inconsistency found when specifying `DescriptorUpdateTemplateCreateInfoKhr::descriptor_update_entries`.");
        self.raw.descriptorUpdateEntryCount = descriptor_update_entries.len() as _;
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_DESCRIPTORUPDATEENTRYCOUNT;
        self.raw.pDescriptorUpdateEntries = descriptor_update_entries.as_ptr() as *const vks::VkDescriptorUpdateTemplateEntryKHR;
        self
    }

    pub fn template_type<'m>(mut self, template_type: DescriptorUpdateTemplateTypeKhr) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.templateType = template_type.into();
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_TEMPLATETYPE;
        self
    }

    pub fn descriptor_set_layout<'m, H>(mut self, descriptor_set_layout: H) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where H: Handle<Target=DescriptorSetLayoutHandle> {
        self.raw.descriptorSetLayout = descriptor_set_layout.handle().0;
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_DESCRIPTORSETLAYOUT;
        self
    }

    pub fn pipeline_bind_point<'m>(mut self, pipeline_bind_point: PipelineBindPoint) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.pipelineBindPoint = pipeline_bind_point.into();
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINEBINDPOINT;
        self
    }

    pub fn pipeline_layout<'m, H>(mut self, pipeline_layout: H) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b>
            where H: Handle<Target=PipelineLayoutHandle> {
        self.raw.pipelineLayout = pipeline_layout.handle().0;
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINELAYOUT;
        self
    }

    pub fn set<'m>(mut self, set: u32) -> DescriptorUpdateTemplateCreateInfoKhrBuilder<'b> {
        self.raw.set = set.into();
        self.set_mask |= DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_SET;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PNEXT != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<DescriptorUpdateTemplateCreateFlagsKhr> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_FLAGS != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_FLAGS { return None }
        Some( DescriptorUpdateTemplateCreateFlagsKhr::from_bits(self.raw.flags)
            .expect("DescriptorUpdateTemplateCreateInfoKhr::flags: error converting flags") )
    }

    pub fn get_descriptor_update_entries<'a>(&'a self) -> Option<&'a [DescriptorUpdateTemplateEntryKhr]> {
        if self.raw.pDescriptorUpdateEntries.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pDescriptorUpdateEntries as *const _, self.raw.descriptorUpdateEntryCount as usize) } )
    }

    pub fn get_template_type<'a>(&'a self) -> Option<DescriptorUpdateTemplateTypeKhr> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_TEMPLATETYPE != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_TEMPLATETYPE { return None }
        Some( self.raw.templateType.into() )
    }

    pub fn get_descriptor_set_layout<'a>(&'a self) -> Option<vks::VkDescriptorSetLayout> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_DESCRIPTORSETLAYOUT != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_DESCRIPTORSETLAYOUT { return None }
        Some( self.raw.descriptorSetLayout )
    }

    pub fn get_pipeline_bind_point<'a>(&'a self) -> Option<PipelineBindPoint> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINEBINDPOINT != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINEBINDPOINT { return None }
        Some( self.raw.pipelineBindPoint.into() )
    }

    pub fn get_pipeline_layout<'a>(&'a self) -> Option<vks::VkPipelineLayout> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINELAYOUT != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_PIPELINELAYOUT { return None }
        Some( self.raw.pipelineLayout )
    }

    pub fn get_set<'a>(&'a self) -> Option<u32> {
        if self.set_mask & DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_SET != DescriptorUpdateTemplateCreateInfoKhrFlags::FLAG_SET { return None }
        Some( self.raw.set.into() )
    }

    pub fn build(self) -> DescriptorUpdateTemplateCreateInfoKhr<'b> {
        DescriptorUpdateTemplateCreateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkXYColorEXT`.
///
/// Chromaticity coordinate
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct XYColorExt {
    raw: vks::VkXYColorEXT,
}

impl XYColorExt {
    pub fn builder() -> XYColorExtBuilder {
        XYColorExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkXYColorEXT) -> XYColorExt {
        XYColorExt { raw, }
    }

    pub fn x<'a>(&'a self) -> f32 {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> f32 {
        self.raw.y.into()
    }

    pub fn set_x<'m>(&mut self, x: f32) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: f32) {
        self.raw.y = y.into();
    }

    pub fn as_raw(&self) -> &vks::VkXYColorEXT {
        &self.raw
    }
}

impl From<XYColorExt> for vks::VkXYColorEXT {
    fn from(f: XYColorExt) -> vks::VkXYColorEXT {
        f.raw
    }
}


/// Bitflags for `VkXYColorEXT`.
///
/// Chromaticity coordinate
bitflags! {
    #[derive(Default)]
    pub struct XYColorExtFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
    }
}


/// A builder for `VkXYColorEXT`.
///
/// Chromaticity coordinate
#[derive(Debug, Clone, Default)]
pub struct XYColorExtBuilder {
    raw: vks::VkXYColorEXT,
    set_mask: XYColorExtFlags,
}

impl XYColorExtBuilder {
    pub fn new() -> XYColorExtBuilder {
        XYColorExtBuilder {
            raw: vks::VkXYColorEXT::default(),
            set_mask: XYColorExtFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: f32) -> XYColorExtBuilder {
        self.raw.x = x.into();
        self.set_mask |= XYColorExtFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: f32) -> XYColorExtBuilder {
        self.raw.y = y.into();
        self.set_mask |= XYColorExtFlags::FLAG_Y;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<f32> {
        if self.set_mask & XYColorExtFlags::FLAG_X != XYColorExtFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<f32> {
        if self.set_mask & XYColorExtFlags::FLAG_Y != XYColorExtFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn build(self) -> XYColorExt {
        XYColorExt {
            raw: self.raw,
        }
    }
}


/// A `VkHdrMetadataEXT`.
///
///  From CTA 861.3
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct HdrMetadataExt<'s> {
    raw: vks::VkHdrMetadataEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> HdrMetadataExt<'s> {
    pub fn builder<'b>() -> HdrMetadataExtBuilder<'b> {
        HdrMetadataExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkHdrMetadataEXT) -> HdrMetadataExt<'s> {
        HdrMetadataExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn display_primary_red<'a>(&'a self) -> &'a XYColorExt {
         unsafe { &*(&self.raw.displayPrimaryRed as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_red_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryRed as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn display_primary_green<'a>(&'a self) -> &'a XYColorExt {
         unsafe { &*(&self.raw.displayPrimaryGreen as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_green_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryGreen as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn display_primary_blue<'a>(&'a self) -> &'a XYColorExt {
         unsafe { &*(&self.raw.displayPrimaryBlue as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn display_primary_blue_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.displayPrimaryBlue as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn white_point<'a>(&'a self) -> &'a XYColorExt {
         unsafe { &*(&self.raw.whitePoint as *const vks::VkXYColorEXT as *const XYColorExt) }
    }

    pub fn white_point_mut<'a>(&'a mut self) -> &'a mut XYColorExt {
        unsafe { &mut *(&mut self.raw.whitePoint as *mut  vks::VkXYColorEXT as *mut XYColorExt) }
    }

    pub fn max_luminance<'a>(&'a self) -> f32 {
        self.raw.maxLuminance.into()
    }

    pub fn min_luminance<'a>(&'a self) -> f32 {
        self.raw.minLuminance.into()
    }

    pub fn max_content_light_level<'a>(&'a self) -> f32 {
        self.raw.maxContentLightLevel.into()
    }

    pub fn max_frame_average_light_level<'a>(&'a self) -> f32 {
        self.raw.maxFrameAverageLightLevel.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_display_primary_red<'m>(&mut self, display_primary_red: XYColorExt) {
        self.raw.displayPrimaryRed = display_primary_red.raw;
    }

    pub fn set_display_primary_green<'m>(&mut self, display_primary_green: XYColorExt) {
        self.raw.displayPrimaryGreen = display_primary_green.raw;
    }

    pub fn set_display_primary_blue<'m>(&mut self, display_primary_blue: XYColorExt) {
        self.raw.displayPrimaryBlue = display_primary_blue.raw;
    }

    pub fn set_white_point<'m>(&mut self, white_point: XYColorExt) {
        self.raw.whitePoint = white_point.raw;
    }

    pub fn set_max_luminance<'m>(&mut self, max_luminance: f32) {
        self.raw.maxLuminance = max_luminance.into();
    }

    pub fn set_min_luminance<'m>(&mut self, min_luminance: f32) {
        self.raw.minLuminance = min_luminance.into();
    }

    pub fn set_max_content_light_level<'m>(&mut self, max_content_light_level: f32) {
        self.raw.maxContentLightLevel = max_content_light_level.into();
    }

    pub fn set_max_frame_average_light_level<'m>(&mut self, max_frame_average_light_level: f32) {
        self.raw.maxFrameAverageLightLevel = max_frame_average_light_level.into();
    }

    pub fn as_raw(&self) -> &vks::VkHdrMetadataEXT {
        &self.raw
    }
}

impl<'s> From<HdrMetadataExt<'s>> for vks::VkHdrMetadataEXT {
    fn from(f: HdrMetadataExt<'s>) -> vks::VkHdrMetadataEXT {
        f.raw
    }
}


/// Bitflags for `VkHdrMetadataEXT`.
///
///  From CTA 861.3
bitflags! {
    #[derive(Default)]
    pub struct HdrMetadataExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_DISPLAYPRIMARYRED			 = 0b100;
        const FLAG_DISPLAYPRIMARYGREEN			 = 0b1000;
        const FLAG_DISPLAYPRIMARYBLUE			 = 0b10000;
        const FLAG_WHITEPOINT			 = 0b100000;
        const FLAG_MAXLUMINANCE			 = 0b1000000;
        const FLAG_MINLUMINANCE			 = 0b10000000;
        const FLAG_MAXCONTENTLIGHTLEVEL			 = 0b100000000;
        const FLAG_MAXFRAMEAVERAGELIGHTLEVEL			 = 0b1000000000;
    }
}


/// A builder for `VkHdrMetadataEXT`.
///
///  From CTA 861.3
#[derive(Debug, Clone, Default)]
pub struct HdrMetadataExtBuilder<'b> {
    raw: vks::VkHdrMetadataEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: HdrMetadataExtFlags,
}

impl<'b> HdrMetadataExtBuilder<'b> {
    pub fn new() -> HdrMetadataExtBuilder<'b> {
        HdrMetadataExtBuilder {
            raw: vks::VkHdrMetadataEXT::default(),
            _p: PhantomData,
            set_mask: HdrMetadataExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> HdrMetadataExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= HdrMetadataExtFlags::FLAG_PNEXT;
        self
    }

    pub fn display_primary_red<'m>(mut self, display_primary_red: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryRed = display_primary_red.raw;
        self.set_mask |= HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYRED;
        self
    }

    pub fn display_primary_green<'m>(mut self, display_primary_green: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryGreen = display_primary_green.raw;
        self.set_mask |= HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYGREEN;
        self
    }

    pub fn display_primary_blue<'m>(mut self, display_primary_blue: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.displayPrimaryBlue = display_primary_blue.raw;
        self.set_mask |= HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYBLUE;
        self
    }

    pub fn white_point<'m>(mut self, white_point: XYColorExt) -> HdrMetadataExtBuilder<'b> {
        self.raw.whitePoint = white_point.raw;
        self.set_mask |= HdrMetadataExtFlags::FLAG_WHITEPOINT;
        self
    }

    pub fn max_luminance<'m>(mut self, max_luminance: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxLuminance = max_luminance.into();
        self.set_mask |= HdrMetadataExtFlags::FLAG_MAXLUMINANCE;
        self
    }

    pub fn min_luminance<'m>(mut self, min_luminance: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.minLuminance = min_luminance.into();
        self.set_mask |= HdrMetadataExtFlags::FLAG_MINLUMINANCE;
        self
    }

    pub fn max_content_light_level<'m>(mut self, max_content_light_level: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxContentLightLevel = max_content_light_level.into();
        self.set_mask |= HdrMetadataExtFlags::FLAG_MAXCONTENTLIGHTLEVEL;
        self
    }

    pub fn max_frame_average_light_level<'m>(mut self, max_frame_average_light_level: f32) -> HdrMetadataExtBuilder<'b> {
        self.raw.maxFrameAverageLightLevel = max_frame_average_light_level.into();
        self.set_mask |= HdrMetadataExtFlags::FLAG_MAXFRAMEAVERAGELIGHTLEVEL;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_PNEXT != HdrMetadataExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_display_primary_red<'a>(&'a self) -> Option<&'a XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYRED != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYRED { return None }
        Some(  unsafe { &*(&self.raw.displayPrimaryRed as *const vks::VkXYColorEXT as *const XYColorExt) } )
    }

    pub fn get_display_primary_red_mut<'a>(&'a mut self) -> Option<&'a mut XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYRED != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYRED { return None }
        Some( unsafe { &mut *(&mut self.raw.displayPrimaryRed as *mut  vks::VkXYColorEXT as *mut XYColorExt) } )
    }

    pub fn get_display_primary_green<'a>(&'a self) -> Option<&'a XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYGREEN != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYGREEN { return None }
        Some(  unsafe { &*(&self.raw.displayPrimaryGreen as *const vks::VkXYColorEXT as *const XYColorExt) } )
    }

    pub fn get_display_primary_green_mut<'a>(&'a mut self) -> Option<&'a mut XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYGREEN != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYGREEN { return None }
        Some( unsafe { &mut *(&mut self.raw.displayPrimaryGreen as *mut  vks::VkXYColorEXT as *mut XYColorExt) } )
    }

    pub fn get_display_primary_blue<'a>(&'a self) -> Option<&'a XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYBLUE != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYBLUE { return None }
        Some(  unsafe { &*(&self.raw.displayPrimaryBlue as *const vks::VkXYColorEXT as *const XYColorExt) } )
    }

    pub fn get_display_primary_blue_mut<'a>(&'a mut self) -> Option<&'a mut XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYBLUE != HdrMetadataExtFlags::FLAG_DISPLAYPRIMARYBLUE { return None }
        Some( unsafe { &mut *(&mut self.raw.displayPrimaryBlue as *mut  vks::VkXYColorEXT as *mut XYColorExt) } )
    }

    pub fn get_white_point<'a>(&'a self) -> Option<&'a XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_WHITEPOINT != HdrMetadataExtFlags::FLAG_WHITEPOINT { return None }
        Some(  unsafe { &*(&self.raw.whitePoint as *const vks::VkXYColorEXT as *const XYColorExt) } )
    }

    pub fn get_white_point_mut<'a>(&'a mut self) -> Option<&'a mut XYColorExt> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_WHITEPOINT != HdrMetadataExtFlags::FLAG_WHITEPOINT { return None }
        Some( unsafe { &mut *(&mut self.raw.whitePoint as *mut  vks::VkXYColorEXT as *mut XYColorExt) } )
    }

    pub fn get_max_luminance<'a>(&'a self) -> Option<f32> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_MAXLUMINANCE != HdrMetadataExtFlags::FLAG_MAXLUMINANCE { return None }
        Some( self.raw.maxLuminance.into() )
    }

    pub fn get_min_luminance<'a>(&'a self) -> Option<f32> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_MINLUMINANCE != HdrMetadataExtFlags::FLAG_MINLUMINANCE { return None }
        Some( self.raw.minLuminance.into() )
    }

    pub fn get_max_content_light_level<'a>(&'a self) -> Option<f32> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_MAXCONTENTLIGHTLEVEL != HdrMetadataExtFlags::FLAG_MAXCONTENTLIGHTLEVEL { return None }
        Some( self.raw.maxContentLightLevel.into() )
    }

    pub fn get_max_frame_average_light_level<'a>(&'a self) -> Option<f32> {
        if self.set_mask & HdrMetadataExtFlags::FLAG_MAXFRAMEAVERAGELIGHTLEVEL != HdrMetadataExtFlags::FLAG_MAXFRAMEAVERAGELIGHTLEVEL { return None }
        Some( self.raw.maxFrameAverageLightLevel.into() )
    }

    pub fn build(self) -> HdrMetadataExt<'b> {
        HdrMetadataExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkRefreshCycleDurationGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct RefreshCycleDurationGoogle {
    raw: vks::VkRefreshCycleDurationGOOGLE,
}

impl RefreshCycleDurationGoogle {
    pub fn builder() -> RefreshCycleDurationGoogleBuilder {
        RefreshCycleDurationGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkRefreshCycleDurationGOOGLE) -> RefreshCycleDurationGoogle {
        RefreshCycleDurationGoogle { raw, }
    }

    pub fn refresh_duration<'a>(&'a self) -> u64 {
        self.raw.refreshDuration.into()
    }

    pub fn set_refresh_duration<'m>(&mut self, refresh_duration: u64) {
        self.raw.refreshDuration = refresh_duration.into();
    }

    pub fn as_raw(&self) -> &vks::VkRefreshCycleDurationGOOGLE {
        &self.raw
    }
}

impl From<RefreshCycleDurationGoogle> for vks::VkRefreshCycleDurationGOOGLE {
    fn from(f: RefreshCycleDurationGoogle) -> vks::VkRefreshCycleDurationGOOGLE {
        f.raw
    }
}


/// Bitflags for `VkRefreshCycleDurationGOOGLE`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct RefreshCycleDurationGoogleFlags: u32 {
        const FLAG_REFRESHDURATION			 = 0b1;
    }
}


/// A builder for `VkRefreshCycleDurationGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct RefreshCycleDurationGoogleBuilder {
    raw: vks::VkRefreshCycleDurationGOOGLE,
    set_mask: RefreshCycleDurationGoogleFlags,
}

impl RefreshCycleDurationGoogleBuilder {
    pub fn new() -> RefreshCycleDurationGoogleBuilder {
        RefreshCycleDurationGoogleBuilder {
            raw: vks::VkRefreshCycleDurationGOOGLE::default(),
            set_mask: RefreshCycleDurationGoogleFlags::default(),
        }
    }

    pub fn refresh_duration<'m>(mut self, refresh_duration: u64) -> RefreshCycleDurationGoogleBuilder {
        self.raw.refreshDuration = refresh_duration.into();
        self.set_mask |= RefreshCycleDurationGoogleFlags::FLAG_REFRESHDURATION;
        self
    }

    pub fn get_refresh_duration<'a>(&'a self) -> Option<u64> {
        if self.set_mask & RefreshCycleDurationGoogleFlags::FLAG_REFRESHDURATION != RefreshCycleDurationGoogleFlags::FLAG_REFRESHDURATION { return None }
        Some( self.raw.refreshDuration.into() )
    }

    pub fn build(self) -> RefreshCycleDurationGoogle {
        RefreshCycleDurationGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkPastPresentationTimingGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PastPresentationTimingGoogle {
    raw: vks::VkPastPresentationTimingGOOGLE,
}

impl PastPresentationTimingGoogle {
    pub fn builder() -> PastPresentationTimingGoogleBuilder {
        PastPresentationTimingGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPastPresentationTimingGOOGLE) -> PastPresentationTimingGoogle {
        PastPresentationTimingGoogle { raw, }
    }

    pub fn present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn actual_present_time<'a>(&'a self) -> u64 {
        self.raw.actualPresentTime.into()
    }

    pub fn earliest_present_time<'a>(&'a self) -> u64 {
        self.raw.earliestPresentTime.into()
    }

    pub fn present_margin<'a>(&'a self) -> u64 {
        self.raw.presentMargin.into()
    }

    pub fn set_present_id<'m>(&mut self, present_id: u32) {
        self.raw.presentID = present_id.into();
    }

    pub fn set_desired_present_time<'m>(&mut self, desired_present_time: u64) {
        self.raw.desiredPresentTime = desired_present_time.into();
    }

    pub fn set_actual_present_time<'m>(&mut self, actual_present_time: u64) {
        self.raw.actualPresentTime = actual_present_time.into();
    }

    pub fn set_earliest_present_time<'m>(&mut self, earliest_present_time: u64) {
        self.raw.earliestPresentTime = earliest_present_time.into();
    }

    pub fn set_present_margin<'m>(&mut self, present_margin: u64) {
        self.raw.presentMargin = present_margin.into();
    }

    pub fn as_raw(&self) -> &vks::VkPastPresentationTimingGOOGLE {
        &self.raw
    }
}

impl From<PastPresentationTimingGoogle> for vks::VkPastPresentationTimingGOOGLE {
    fn from(f: PastPresentationTimingGoogle) -> vks::VkPastPresentationTimingGOOGLE {
        f.raw
    }
}


/// Bitflags for `VkPastPresentationTimingGOOGLE`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PastPresentationTimingGoogleFlags: u32 {
        const FLAG_PRESENTID			 = 0b1;
        const FLAG_DESIREDPRESENTTIME			 = 0b10;
        const FLAG_ACTUALPRESENTTIME			 = 0b100;
        const FLAG_EARLIESTPRESENTTIME			 = 0b1000;
        const FLAG_PRESENTMARGIN			 = 0b10000;
    }
}


/// A builder for `VkPastPresentationTimingGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PastPresentationTimingGoogleBuilder {
    raw: vks::VkPastPresentationTimingGOOGLE,
    set_mask: PastPresentationTimingGoogleFlags,
}

impl PastPresentationTimingGoogleBuilder {
    pub fn new() -> PastPresentationTimingGoogleBuilder {
        PastPresentationTimingGoogleBuilder {
            raw: vks::VkPastPresentationTimingGOOGLE::default(),
            set_mask: PastPresentationTimingGoogleFlags::default(),
        }
    }

    pub fn present_id<'m>(mut self, present_id: u32) -> PastPresentationTimingGoogleBuilder {
        self.raw.presentID = present_id.into();
        self.set_mask |= PastPresentationTimingGoogleFlags::FLAG_PRESENTID;
        self
    }

    pub fn desired_present_time<'m>(mut self, desired_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.desiredPresentTime = desired_present_time.into();
        self.set_mask |= PastPresentationTimingGoogleFlags::FLAG_DESIREDPRESENTTIME;
        self
    }

    pub fn actual_present_time<'m>(mut self, actual_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.actualPresentTime = actual_present_time.into();
        self.set_mask |= PastPresentationTimingGoogleFlags::FLAG_ACTUALPRESENTTIME;
        self
    }

    pub fn earliest_present_time<'m>(mut self, earliest_present_time: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.earliestPresentTime = earliest_present_time.into();
        self.set_mask |= PastPresentationTimingGoogleFlags::FLAG_EARLIESTPRESENTTIME;
        self
    }

    pub fn present_margin<'m>(mut self, present_margin: u64) -> PastPresentationTimingGoogleBuilder {
        self.raw.presentMargin = present_margin.into();
        self.set_mask |= PastPresentationTimingGoogleFlags::FLAG_PRESENTMARGIN;
        self
    }

    pub fn get_present_id<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PastPresentationTimingGoogleFlags::FLAG_PRESENTID != PastPresentationTimingGoogleFlags::FLAG_PRESENTID { return None }
        Some( self.raw.presentID.into() )
    }

    pub fn get_desired_present_time<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PastPresentationTimingGoogleFlags::FLAG_DESIREDPRESENTTIME != PastPresentationTimingGoogleFlags::FLAG_DESIREDPRESENTTIME { return None }
        Some( self.raw.desiredPresentTime.into() )
    }

    pub fn get_actual_present_time<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PastPresentationTimingGoogleFlags::FLAG_ACTUALPRESENTTIME != PastPresentationTimingGoogleFlags::FLAG_ACTUALPRESENTTIME { return None }
        Some( self.raw.actualPresentTime.into() )
    }

    pub fn get_earliest_present_time<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PastPresentationTimingGoogleFlags::FLAG_EARLIESTPRESENTTIME != PastPresentationTimingGoogleFlags::FLAG_EARLIESTPRESENTTIME { return None }
        Some( self.raw.earliestPresentTime.into() )
    }

    pub fn get_present_margin<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PastPresentationTimingGoogleFlags::FLAG_PRESENTMARGIN != PastPresentationTimingGoogleFlags::FLAG_PRESENTMARGIN { return None }
        Some( self.raw.presentMargin.into() )
    }

    pub fn build(self) -> PastPresentationTimingGoogle {
        PastPresentationTimingGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkPresentTimesInfoGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentTimesInfoGoogle<'s> {
    raw: vks::VkPresentTimesInfoGOOGLE,
    _p: PhantomData<&'s ()>,
}

impl<'s> PresentTimesInfoGoogle<'s> {
    pub fn builder<'b>() -> PresentTimesInfoGoogleBuilder<'b> {
        PresentTimesInfoGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentTimesInfoGOOGLE) -> PresentTimesInfoGoogle<'s> {
        PresentTimesInfoGoogle { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn times<'a>(&'a self) -> &'a [PresentTimeGoogle] {
        unsafe { slice::from_raw_parts(self.raw.pTimes as *const _, self.raw.swapchainCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_times<'m, 'a>(&mut self, times: &'a [PresentTimeGoogle])
            where 'a: 's {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == times.len() as _, 
            "count inconsistency found when specifying `PresentTimesInfoGoogle::times`.");
        self.raw.swapchainCount = times.len() as _;
        self.raw.pTimes = times.as_ptr() as *const vks::VkPresentTimeGOOGLE;
    }

    pub fn as_raw(&self) -> &vks::VkPresentTimesInfoGOOGLE {
        &self.raw
    }
}

impl<'s> From<PresentTimesInfoGoogle<'s>> for vks::VkPresentTimesInfoGOOGLE {
    fn from(f: PresentTimesInfoGoogle<'s>) -> vks::VkPresentTimesInfoGOOGLE {
        f.raw
    }
}


/// Bitflags for `VkPresentTimesInfoGOOGLE`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PresentTimesInfoGoogleFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SWAPCHAINCOUNT			 = 0b100;
        const FLAG_PTIMES			 = 0b1000;
    }
}


/// A builder for `VkPresentTimesInfoGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentTimesInfoGoogleBuilder<'b> {
    raw: vks::VkPresentTimesInfoGOOGLE,
    _p: PhantomData<&'b ()>, 
    set_mask: PresentTimesInfoGoogleFlags,
}

impl<'b> PresentTimesInfoGoogleBuilder<'b> {
    pub fn new() -> PresentTimesInfoGoogleBuilder<'b> {
        PresentTimesInfoGoogleBuilder {
            raw: vks::VkPresentTimesInfoGOOGLE::default(),
            _p: PhantomData,
            set_mask: PresentTimesInfoGoogleFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PresentTimesInfoGoogleBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PresentTimesInfoGoogleFlags::FLAG_PNEXT;
        self
    }

    pub fn times<'m, 'a>(mut self, times: &'a [PresentTimeGoogle]) -> PresentTimesInfoGoogleBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.swapchainCount == 0 || self.raw.swapchainCount == times.len() as _, 
            "count inconsistency found when specifying `PresentTimesInfoGoogle::times`.");
        self.raw.swapchainCount = times.len() as _;
        self.set_mask |= PresentTimesInfoGoogleFlags::FLAG_SWAPCHAINCOUNT;
        self.raw.pTimes = times.as_ptr() as *const vks::VkPresentTimeGOOGLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PresentTimesInfoGoogleFlags::FLAG_PNEXT != PresentTimesInfoGoogleFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_times<'a>(&'a self) -> Option<&'a [PresentTimeGoogle]> {
        if self.raw.pTimes.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pTimes as *const _, self.raw.swapchainCount as usize) } )
    }

    pub fn build(self) -> PresentTimesInfoGoogle<'b> {
        PresentTimesInfoGoogle {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPresentTimeGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PresentTimeGoogle {
    raw: vks::VkPresentTimeGOOGLE,
}

impl PresentTimeGoogle {
    pub fn builder() -> PresentTimeGoogleBuilder {
        PresentTimeGoogleBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPresentTimeGOOGLE) -> PresentTimeGoogle {
        PresentTimeGoogle { raw, }
    }

    pub fn present_id<'a>(&'a self) -> u32 {
        self.raw.presentID.into()
    }

    pub fn desired_present_time<'a>(&'a self) -> u64 {
        self.raw.desiredPresentTime.into()
    }

    pub fn set_present_id<'m>(&mut self, present_id: u32) {
        self.raw.presentID = present_id.into();
    }

    pub fn set_desired_present_time<'m>(&mut self, desired_present_time: u64) {
        self.raw.desiredPresentTime = desired_present_time.into();
    }

    pub fn as_raw(&self) -> &vks::VkPresentTimeGOOGLE {
        &self.raw
    }
}

impl From<PresentTimeGoogle> for vks::VkPresentTimeGOOGLE {
    fn from(f: PresentTimeGoogle) -> vks::VkPresentTimeGOOGLE {
        f.raw
    }
}


/// Bitflags for `VkPresentTimeGOOGLE`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PresentTimeGoogleFlags: u32 {
        const FLAG_PRESENTID			 = 0b1;
        const FLAG_DESIREDPRESENTTIME			 = 0b10;
    }
}


/// A builder for `VkPresentTimeGOOGLE`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PresentTimeGoogleBuilder {
    raw: vks::VkPresentTimeGOOGLE,
    set_mask: PresentTimeGoogleFlags,
}

impl PresentTimeGoogleBuilder {
    pub fn new() -> PresentTimeGoogleBuilder {
        PresentTimeGoogleBuilder {
            raw: vks::VkPresentTimeGOOGLE::default(),
            set_mask: PresentTimeGoogleFlags::default(),
        }
    }

    pub fn present_id<'m>(mut self, present_id: u32) -> PresentTimeGoogleBuilder {
        self.raw.presentID = present_id.into();
        self.set_mask |= PresentTimeGoogleFlags::FLAG_PRESENTID;
        self
    }

    pub fn desired_present_time<'m>(mut self, desired_present_time: u64) -> PresentTimeGoogleBuilder {
        self.raw.desiredPresentTime = desired_present_time.into();
        self.set_mask |= PresentTimeGoogleFlags::FLAG_DESIREDPRESENTTIME;
        self
    }

    pub fn get_present_id<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PresentTimeGoogleFlags::FLAG_PRESENTID != PresentTimeGoogleFlags::FLAG_PRESENTID { return None }
        Some( self.raw.presentID.into() )
    }

    pub fn get_desired_present_time<'a>(&'a self) -> Option<u64> {
        if self.set_mask & PresentTimeGoogleFlags::FLAG_DESIREDPRESENTTIME != PresentTimeGoogleFlags::FLAG_DESIREDPRESENTTIME { return None }
        Some( self.raw.desiredPresentTime.into() )
    }

    pub fn build(self) -> PresentTimeGoogle {
        PresentTimeGoogle {
            raw: self.raw,
        }
    }
}


/// A `VkIOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct IosSurfaceCreateInfoMvk<'s> {
    raw: vks::VkIOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'s ()>,
}

impl<'s> IosSurfaceCreateInfoMvk<'s> {
    pub fn builder<'b>() -> IosSurfaceCreateInfoMvkBuilder<'b> {
        IosSurfaceCreateInfoMvkBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkIOSSurfaceCreateInfoMVK) -> IosSurfaceCreateInfoMvk<'s> {
        IosSurfaceCreateInfoMvk { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> IosSurfaceCreateFlagsMvk {
        IosSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("IosSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: IosSurfaceCreateFlagsMvk) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_view<'m>(&mut self, view: *const c_void) {
        self.raw.pView = view;
    }

    pub fn as_raw(&self) -> &vks::VkIOSSurfaceCreateInfoMVK {
        &self.raw
    }
}

impl<'s> From<IosSurfaceCreateInfoMvk<'s>> for vks::VkIOSSurfaceCreateInfoMVK {
    fn from(f: IosSurfaceCreateInfoMvk<'s>) -> vks::VkIOSSurfaceCreateInfoMVK {
        f.raw
    }
}


/// Bitflags for `VkIOSSurfaceCreateInfoMVK`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct IosSurfaceCreateInfoMvkFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PVIEW			 = 0b1000;
    }
}


/// A builder for `VkIOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct IosSurfaceCreateInfoMvkBuilder<'b> {
    raw: vks::VkIOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'b ()>, 
    set_mask: IosSurfaceCreateInfoMvkFlags,
}

impl<'b> IosSurfaceCreateInfoMvkBuilder<'b> {
    pub fn new() -> IosSurfaceCreateInfoMvkBuilder<'b> {
        IosSurfaceCreateInfoMvkBuilder {
            raw: vks::VkIOSSurfaceCreateInfoMVK::default(),
            _p: PhantomData,
            set_mask: IosSurfaceCreateInfoMvkFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= IosSurfaceCreateInfoMvkFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: IosSurfaceCreateFlagsMvk) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= IosSurfaceCreateInfoMvkFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn view<'m>(mut self, view: *const c_void) -> IosSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pView = view;
        self.set_mask |= IosSurfaceCreateInfoMvkFlags::FLAG_PVIEW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & IosSurfaceCreateInfoMvkFlags::FLAG_PNEXT != IosSurfaceCreateInfoMvkFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<IosSurfaceCreateFlagsMvk> {
        if self.set_mask & IosSurfaceCreateInfoMvkFlags::FLAG_FLAGS != IosSurfaceCreateInfoMvkFlags::FLAG_FLAGS { return None }
        Some( IosSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("IosSurfaceCreateInfoMvk::flags: error converting flags") )
    }

    pub fn get_view<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & IosSurfaceCreateInfoMvkFlags::FLAG_PVIEW != IosSurfaceCreateInfoMvkFlags::FLAG_PVIEW { return None }
        Some( self.raw.pView )
    }

    pub fn build(self) -> IosSurfaceCreateInfoMvk<'b> {
        IosSurfaceCreateInfoMvk {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMacOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MacOsSurfaceCreateInfoMvk<'s> {
    raw: vks::VkMacOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'s ()>,
}

impl<'s> MacOsSurfaceCreateInfoMvk<'s> {
    pub fn builder<'b>() -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        MacOsSurfaceCreateInfoMvkBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMacOSSurfaceCreateInfoMVK) -> MacOsSurfaceCreateInfoMvk<'s> {
        MacOsSurfaceCreateInfoMvk { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> MacOsSurfaceCreateFlagsMvk {
        MacOsSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("MacOsSurfaceCreateInfoMvk::flags: error converting flags")
    }

    pub fn view<'a>(&'a self) -> *const c_void {
        self.raw.pView
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: MacOsSurfaceCreateFlagsMvk) {
        self.raw.flags = flags.bits();
    }

    pub unsafe fn set_view<'m>(&mut self, view: *const c_void) {
        self.raw.pView = view;
    }

    pub fn as_raw(&self) -> &vks::VkMacOSSurfaceCreateInfoMVK {
        &self.raw
    }
}

impl<'s> From<MacOsSurfaceCreateInfoMvk<'s>> for vks::VkMacOSSurfaceCreateInfoMVK {
    fn from(f: MacOsSurfaceCreateInfoMvk<'s>) -> vks::VkMacOSSurfaceCreateInfoMVK {
        f.raw
    }
}


/// Bitflags for `VkMacOSSurfaceCreateInfoMVK`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MacOsSurfaceCreateInfoMvkFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_PVIEW			 = 0b1000;
    }
}


/// A builder for `VkMacOSSurfaceCreateInfoMVK`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MacOsSurfaceCreateInfoMvkBuilder<'b> {
    raw: vks::VkMacOSSurfaceCreateInfoMVK,
    _p: PhantomData<&'b ()>, 
    set_mask: MacOsSurfaceCreateInfoMvkFlags,
}

impl<'b> MacOsSurfaceCreateInfoMvkBuilder<'b> {
    pub fn new() -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        MacOsSurfaceCreateInfoMvkBuilder {
            raw: vks::VkMacOSSurfaceCreateInfoMVK::default(),
            _p: PhantomData,
            set_mask: MacOsSurfaceCreateInfoMvkFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MacOsSurfaceCreateInfoMvkFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: MacOsSurfaceCreateFlagsMvk) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= MacOsSurfaceCreateInfoMvkFlags::FLAG_FLAGS;
        self
    }

    pub unsafe fn view<'m>(mut self, view: *const c_void) -> MacOsSurfaceCreateInfoMvkBuilder<'b> {
        self.raw.pView = view;
        self.set_mask |= MacOsSurfaceCreateInfoMvkFlags::FLAG_PVIEW;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MacOsSurfaceCreateInfoMvkFlags::FLAG_PNEXT != MacOsSurfaceCreateInfoMvkFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<MacOsSurfaceCreateFlagsMvk> {
        if self.set_mask & MacOsSurfaceCreateInfoMvkFlags::FLAG_FLAGS != MacOsSurfaceCreateInfoMvkFlags::FLAG_FLAGS { return None }
        Some( MacOsSurfaceCreateFlagsMvk::from_bits(self.raw.flags)
            .expect("MacOsSurfaceCreateInfoMvk::flags: error converting flags") )
    }

    pub fn get_view<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MacOsSurfaceCreateInfoMvkFlags::FLAG_PVIEW != MacOsSurfaceCreateInfoMvkFlags::FLAG_PVIEW { return None }
        Some( self.raw.pView )
    }

    pub fn build(self) -> MacOsSurfaceCreateInfoMvk<'b> {
        MacOsSurfaceCreateInfoMvk {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViewportWScalingNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViewportWScalingNv {
    raw: vks::VkViewportWScalingNV,
}

impl ViewportWScalingNv {
    pub fn builder() -> ViewportWScalingNvBuilder {
        ViewportWScalingNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewportWScalingNV) -> ViewportWScalingNv {
        ViewportWScalingNv { raw, }
    }

    pub fn xcoeff<'a>(&'a self) -> f32 {
        self.raw.xcoeff.into()
    }

    pub fn ycoeff<'a>(&'a self) -> f32 {
        self.raw.ycoeff.into()
    }

    pub fn set_xcoeff<'m>(&mut self, xcoeff: f32) {
        self.raw.xcoeff = xcoeff.into();
    }

    pub fn set_ycoeff<'m>(&mut self, ycoeff: f32) {
        self.raw.ycoeff = ycoeff.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewportWScalingNV {
        &self.raw
    }
}

impl From<ViewportWScalingNv> for vks::VkViewportWScalingNV {
    fn from(f: ViewportWScalingNv) -> vks::VkViewportWScalingNV {
        f.raw
    }
}


/// Bitflags for `VkViewportWScalingNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ViewportWScalingNvFlags: u32 {
        const FLAG_XCOEFF			 = 0b1;
        const FLAG_YCOEFF			 = 0b10;
    }
}


/// A builder for `VkViewportWScalingNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportWScalingNvBuilder {
    raw: vks::VkViewportWScalingNV,
    set_mask: ViewportWScalingNvFlags,
}

impl ViewportWScalingNvBuilder {
    pub fn new() -> ViewportWScalingNvBuilder {
        ViewportWScalingNvBuilder {
            raw: vks::VkViewportWScalingNV::default(),
            set_mask: ViewportWScalingNvFlags::default(),
        }
    }

    pub fn xcoeff<'m>(mut self, xcoeff: f32) -> ViewportWScalingNvBuilder {
        self.raw.xcoeff = xcoeff.into();
        self.set_mask |= ViewportWScalingNvFlags::FLAG_XCOEFF;
        self
    }

    pub fn ycoeff<'m>(mut self, ycoeff: f32) -> ViewportWScalingNvBuilder {
        self.raw.ycoeff = ycoeff.into();
        self.set_mask |= ViewportWScalingNvFlags::FLAG_YCOEFF;
        self
    }

    pub fn get_xcoeff<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportWScalingNvFlags::FLAG_XCOEFF != ViewportWScalingNvFlags::FLAG_XCOEFF { return None }
        Some( self.raw.xcoeff.into() )
    }

    pub fn get_ycoeff<'a>(&'a self) -> Option<f32> {
        if self.set_mask & ViewportWScalingNvFlags::FLAG_YCOEFF != ViewportWScalingNvFlags::FLAG_YCOEFF { return None }
        Some( self.raw.ycoeff.into() )
    }

    pub fn build(self) -> ViewportWScalingNv {
        ViewportWScalingNv {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineViewportWScalingStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportWScalingStateCreateInfoNv<'s> {
    raw: vks::VkPipelineViewportWScalingStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportWScalingStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        PipelineViewportWScalingStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportWScalingStateCreateInfoNV) -> PipelineViewportWScalingStateCreateInfoNv<'s> {
        PipelineViewportWScalingStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn viewport_wscaling_enable<'a>(&'a self) -> bool {
        self.raw.viewportWScalingEnable != 0
    }

    pub fn viewport_wscalings<'a>(&'a self) -> &'a [ViewportWScalingNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportWScalings as *const _, self.raw.viewportCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_viewport_wscaling_enable<'m>(&mut self, viewport_wscaling_enable: bool) {
        self.raw.viewportWScalingEnable = viewport_wscaling_enable as u32;
    }

    pub fn set_viewport_wscalings<'m, 'a>(&mut self, viewport_wscalings: &'a [ViewportWScalingNv])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_wscalings.len() as _, 
            "count inconsistency found when specifying `PipelineViewportWScalingStateCreateInfoNv::viewport_wscalings`.");
        self.raw.viewportCount = viewport_wscalings.len() as _;
        self.raw.pViewportWScalings = viewport_wscalings.as_ptr() as *const vks::VkViewportWScalingNV;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportWScalingStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineViewportWScalingStateCreateInfoNv<'s>> for vks::VkPipelineViewportWScalingStateCreateInfoNV {
    fn from(f: PipelineViewportWScalingStateCreateInfoNv<'s>) -> vks::VkPipelineViewportWScalingStateCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkPipelineViewportWScalingStateCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineViewportWScalingStateCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_VIEWPORTWSCALINGENABLE			 = 0b100;
        const FLAG_VIEWPORTCOUNT			 = 0b1000;
        const FLAG_PVIEWPORTWSCALINGS			 = 0b10000;
    }
}


/// A builder for `VkPipelineViewportWScalingStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineViewportWScalingStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineViewportWScalingStateCreateInfoNvFlags,
}

impl<'b> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        PipelineViewportWScalingStateCreateInfoNvBuilder {
            raw: vks::VkPipelineViewportWScalingStateCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: PipelineViewportWScalingStateCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn viewport_wscaling_enable<'m>(mut self, viewport_wscaling_enable: bool) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b> {
        self.raw.viewportWScalingEnable = viewport_wscaling_enable as u32;
        self.set_mask |= PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_VIEWPORTWSCALINGENABLE;
        self
    }

    pub fn viewport_wscalings<'m, 'a>(mut self, viewport_wscalings: &'a [ViewportWScalingNv]) -> PipelineViewportWScalingStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_wscalings.len() as _, 
            "count inconsistency found when specifying `PipelineViewportWScalingStateCreateInfoNv::viewport_wscalings`.");
        self.raw.viewportCount = viewport_wscalings.len() as _;
        self.set_mask |= PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_VIEWPORTCOUNT;
        self.raw.pViewportWScalings = viewport_wscalings.as_ptr() as *const vks::VkViewportWScalingNV;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_PNEXT != PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_viewport_wscaling_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_VIEWPORTWSCALINGENABLE != PipelineViewportWScalingStateCreateInfoNvFlags::FLAG_VIEWPORTWSCALINGENABLE { return None }
        Some( self.raw.viewportWScalingEnable != 0 )
    }

    pub fn get_viewport_wscalings<'a>(&'a self) -> Option<&'a [ViewportWScalingNv]> {
        if self.raw.pViewportWScalings.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pViewportWScalings as *const _, self.raw.viewportCount as usize) } )
    }

    pub fn build(self) -> PipelineViewportWScalingStateCreateInfoNv<'b> {
        PipelineViewportWScalingStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkViewportSwizzleNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ViewportSwizzleNv {
    raw: vks::VkViewportSwizzleNV,
}

impl ViewportSwizzleNv {
    pub fn builder() -> ViewportSwizzleNvBuilder {
        ViewportSwizzleNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkViewportSwizzleNV) -> ViewportSwizzleNv {
        ViewportSwizzleNv { raw, }
    }

    pub fn x<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.x.into()
    }

    pub fn y<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.y.into()
    }

    pub fn z<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.z.into()
    }

    pub fn w<'a>(&'a self) -> ViewportCoordinateSwizzleNv {
        self.raw.w.into()
    }

    pub fn set_x<'m>(&mut self, x: ViewportCoordinateSwizzleNv) {
        self.raw.x = x.into();
    }

    pub fn set_y<'m>(&mut self, y: ViewportCoordinateSwizzleNv) {
        self.raw.y = y.into();
    }

    pub fn set_z<'m>(&mut self, z: ViewportCoordinateSwizzleNv) {
        self.raw.z = z.into();
    }

    pub fn set_w<'m>(&mut self, w: ViewportCoordinateSwizzleNv) {
        self.raw.w = w.into();
    }

    pub fn as_raw(&self) -> &vks::VkViewportSwizzleNV {
        &self.raw
    }
}

impl From<ViewportSwizzleNv> for vks::VkViewportSwizzleNV {
    fn from(f: ViewportSwizzleNv) -> vks::VkViewportSwizzleNV {
        f.raw
    }
}


/// Bitflags for `VkViewportSwizzleNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ViewportSwizzleNvFlags: u32 {
        const FLAG_X			 = 0b1;
        const FLAG_Y			 = 0b10;
        const FLAG_Z			 = 0b100;
        const FLAG_W			 = 0b1000;
    }
}


/// A builder for `VkViewportSwizzleNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ViewportSwizzleNvBuilder {
    raw: vks::VkViewportSwizzleNV,
    set_mask: ViewportSwizzleNvFlags,
}

impl ViewportSwizzleNvBuilder {
    pub fn new() -> ViewportSwizzleNvBuilder {
        ViewportSwizzleNvBuilder {
            raw: vks::VkViewportSwizzleNV::default(),
            set_mask: ViewportSwizzleNvFlags::default(),
        }
    }

    pub fn x<'m>(mut self, x: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.x = x.into();
        self.set_mask |= ViewportSwizzleNvFlags::FLAG_X;
        self
    }

    pub fn y<'m>(mut self, y: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.y = y.into();
        self.set_mask |= ViewportSwizzleNvFlags::FLAG_Y;
        self
    }

    pub fn z<'m>(mut self, z: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.z = z.into();
        self.set_mask |= ViewportSwizzleNvFlags::FLAG_Z;
        self
    }

    pub fn w<'m>(mut self, w: ViewportCoordinateSwizzleNv) -> ViewportSwizzleNvBuilder {
        self.raw.w = w.into();
        self.set_mask |= ViewportSwizzleNvFlags::FLAG_W;
        self
    }

    pub fn get_x<'a>(&'a self) -> Option<ViewportCoordinateSwizzleNv> {
        if self.set_mask & ViewportSwizzleNvFlags::FLAG_X != ViewportSwizzleNvFlags::FLAG_X { return None }
        Some( self.raw.x.into() )
    }

    pub fn get_y<'a>(&'a self) -> Option<ViewportCoordinateSwizzleNv> {
        if self.set_mask & ViewportSwizzleNvFlags::FLAG_Y != ViewportSwizzleNvFlags::FLAG_Y { return None }
        Some( self.raw.y.into() )
    }

    pub fn get_z<'a>(&'a self) -> Option<ViewportCoordinateSwizzleNv> {
        if self.set_mask & ViewportSwizzleNvFlags::FLAG_Z != ViewportSwizzleNvFlags::FLAG_Z { return None }
        Some( self.raw.z.into() )
    }

    pub fn get_w<'a>(&'a self) -> Option<ViewportCoordinateSwizzleNv> {
        if self.set_mask & ViewportSwizzleNvFlags::FLAG_W != ViewportSwizzleNvFlags::FLAG_W { return None }
        Some( self.raw.w.into() )
    }

    pub fn build(self) -> ViewportSwizzleNv {
        ViewportSwizzleNv {
            raw: self.raw,
        }
    }
}


/// A `VkPipelineViewportSwizzleStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineViewportSwizzleStateCreateInfoNv<'s> {
    raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineViewportSwizzleStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        PipelineViewportSwizzleStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV) -> PipelineViewportSwizzleStateCreateInfoNv<'s> {
        PipelineViewportSwizzleStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineViewportSwizzleStateCreateFlagsNv {
        PipelineViewportSwizzleStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineViewportSwizzleStateCreateInfoNv::flags: error converting flags")
    }

    pub fn viewport_swizzles<'a>(&'a self) -> &'a [ViewportSwizzleNv] {
        unsafe { slice::from_raw_parts(self.raw.pViewportSwizzles as *const _, self.raw.viewportCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineViewportSwizzleStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_viewport_swizzles<'m, 'a>(&mut self, viewport_swizzles: &'a [ViewportSwizzleNv])
            where 'a: 's {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_swizzles.len() as _, 
            "count inconsistency found when specifying `PipelineViewportSwizzleStateCreateInfoNv::viewport_swizzles`.");
        self.raw.viewportCount = viewport_swizzles.len() as _;
        self.raw.pViewportSwizzles = viewport_swizzles.as_ptr() as *const vks::VkViewportSwizzleNV;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineViewportSwizzleStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineViewportSwizzleStateCreateInfoNv<'s>> for vks::VkPipelineViewportSwizzleStateCreateInfoNV {
    fn from(f: PipelineViewportSwizzleStateCreateInfoNv<'s>) -> vks::VkPipelineViewportSwizzleStateCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkPipelineViewportSwizzleStateCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineViewportSwizzleStateCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_VIEWPORTCOUNT			 = 0b1000;
        const FLAG_PVIEWPORTSWIZZLES			 = 0b10000;
    }
}


/// A builder for `VkPipelineViewportSwizzleStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineViewportSwizzleStateCreateInfoNvFlags,
}

impl<'b> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        PipelineViewportSwizzleStateCreateInfoNvBuilder {
            raw: vks::VkPipelineViewportSwizzleStateCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: PipelineViewportSwizzleStateCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineViewportSwizzleStateCreateFlagsNv) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_FLAGS;
        self
    }

    pub fn viewport_swizzles<'m, 'a>(mut self, viewport_swizzles: &'a [ViewportSwizzleNv]) -> PipelineViewportSwizzleStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.viewportCount == 0 || self.raw.viewportCount == viewport_swizzles.len() as _, 
            "count inconsistency found when specifying `PipelineViewportSwizzleStateCreateInfoNv::viewport_swizzles`.");
        self.raw.viewportCount = viewport_swizzles.len() as _;
        self.set_mask |= PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_VIEWPORTCOUNT;
        self.raw.pViewportSwizzles = viewport_swizzles.as_ptr() as *const vks::VkViewportSwizzleNV;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_PNEXT != PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineViewportSwizzleStateCreateFlagsNv> {
        if self.set_mask & PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_FLAGS != PipelineViewportSwizzleStateCreateInfoNvFlags::FLAG_FLAGS { return None }
        Some( PipelineViewportSwizzleStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineViewportSwizzleStateCreateInfoNv::flags: error converting flags") )
    }

    pub fn get_viewport_swizzles<'a>(&'a self) -> Option<&'a [ViewportSwizzleNv]> {
        if self.raw.pViewportSwizzles.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pViewportSwizzles as *const _, self.raw.viewportCount as usize) } )
    }

    pub fn build(self) -> PipelineViewportSwizzleStateCreateInfoNv<'b> {
        PipelineViewportSwizzleStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceDiscardRectanglePropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT) -> PhysicalDeviceDiscardRectanglePropertiesExt<'s> {
        PhysicalDeviceDiscardRectanglePropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn max_discard_rectangles<'a>(&'a self) -> u32 {
        self.raw.maxDiscardRectangles.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_max_discard_rectangles<'m>(&mut self, max_discard_rectangles: u32) {
        self.raw.maxDiscardRectangles = max_discard_rectangles.into();
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceDiscardRectanglePropertiesExt<'s>> for vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    fn from(f: PhysicalDeviceDiscardRectanglePropertiesExt<'s>) -> vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceDiscardRectanglePropertiesEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceDiscardRectanglePropertiesExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MAXDISCARDRECTANGLES			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceDiscardRectanglePropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceDiscardRectanglePropertiesExtFlags,
}

impl<'b> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceDiscardRectanglePropertiesEXT::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceDiscardRectanglePropertiesExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_PNEXT;
        self
    }

    pub fn max_discard_rectangles<'m>(mut self, max_discard_rectangles: u32) -> PhysicalDeviceDiscardRectanglePropertiesExtBuilder<'b> {
        self.raw.maxDiscardRectangles = max_discard_rectangles.into();
        self.set_mask |= PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_MAXDISCARDRECTANGLES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_PNEXT != PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_max_discard_rectangles<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_MAXDISCARDRECTANGLES != PhysicalDeviceDiscardRectanglePropertiesExtFlags::FLAG_MAXDISCARDRECTANGLES { return None }
        Some( self.raw.maxDiscardRectangles.into() )
    }

    pub fn build(self) -> PhysicalDeviceDiscardRectanglePropertiesExt<'b> {
        PhysicalDeviceDiscardRectanglePropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineDiscardRectangleStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineDiscardRectangleStateCreateInfoExt<'s> {
    raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineDiscardRectangleStateCreateInfoExt<'s> {
    pub fn builder<'b>() -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        PipelineDiscardRectangleStateCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT) -> PipelineDiscardRectangleStateCreateInfoExt<'s> {
        PipelineDiscardRectangleStateCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineDiscardRectangleStateCreateFlagsExt {
        PipelineDiscardRectangleStateCreateFlagsExt::from_bits(self.raw.flags)
            .expect("PipelineDiscardRectangleStateCreateInfoExt::flags: error converting flags")
    }

    pub fn discard_rectangle_mode<'a>(&'a self) -> DiscardRectangleModeExt {
        self.raw.discardRectangleMode.into()
    }

    pub fn discard_rectangles<'a>(&'a self) -> &'a [Rect2d] {
        unsafe { slice::from_raw_parts(self.raw.pDiscardRectangles as *const _, self.raw.discardRectangleCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineDiscardRectangleStateCreateFlagsExt) {
        self.raw.flags = flags.bits();
    }

    pub fn set_discard_rectangle_mode<'m>(&mut self, discard_rectangle_mode: DiscardRectangleModeExt) {
        self.raw.discardRectangleMode = discard_rectangle_mode.into();
    }

    pub fn set_discard_rectangles<'m, 'a>(&mut self, discard_rectangles: &'a [Rect2d])
            where 'a: 's {
        assert!(self.raw.discardRectangleCount == 0 || self.raw.discardRectangleCount == discard_rectangles.len() as _, 
            "count inconsistency found when specifying `PipelineDiscardRectangleStateCreateInfoExt::discard_rectangles`.");
        self.raw.discardRectangleCount = discard_rectangles.len() as _;
        self.raw.pDiscardRectangles = discard_rectangles.as_ptr() as *const vks::VkRect2D;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<PipelineDiscardRectangleStateCreateInfoExt<'s>> for vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
    fn from(f: PipelineDiscardRectangleStateCreateInfoExt<'s>) -> vks::VkPipelineDiscardRectangleStateCreateInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkPipelineDiscardRectangleStateCreateInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineDiscardRectangleStateCreateInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_DISCARDRECTANGLEMODE			 = 0b1000;
        const FLAG_DISCARDRECTANGLECOUNT			 = 0b10000;
        const FLAG_PDISCARDRECTANGLES			 = 0b100000;
    }
}


/// A builder for `VkPipelineDiscardRectangleStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
    raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineDiscardRectangleStateCreateInfoExtFlags,
}

impl<'b> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
    pub fn new() -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        PipelineDiscardRectangleStateCreateInfoExtBuilder {
            raw: vks::VkPipelineDiscardRectangleStateCreateInfoEXT::default(),
            _p: PhantomData,
            set_mask: PipelineDiscardRectangleStateCreateInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineDiscardRectangleStateCreateFlagsExt) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_FLAGS;
        self
    }

    pub fn discard_rectangle_mode<'m>(mut self, discard_rectangle_mode: DiscardRectangleModeExt) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b> {
        self.raw.discardRectangleMode = discard_rectangle_mode.into();
        self.set_mask |= PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_DISCARDRECTANGLEMODE;
        self
    }

    pub fn discard_rectangles<'m, 'a>(mut self, discard_rectangles: &'a [Rect2d]) -> PipelineDiscardRectangleStateCreateInfoExtBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.discardRectangleCount == 0 || self.raw.discardRectangleCount == discard_rectangles.len() as _, 
            "count inconsistency found when specifying `PipelineDiscardRectangleStateCreateInfoExt::discard_rectangles`.");
        self.raw.discardRectangleCount = discard_rectangles.len() as _;
        self.set_mask |= PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_DISCARDRECTANGLECOUNT;
        self.raw.pDiscardRectangles = discard_rectangles.as_ptr() as *const vks::VkRect2D;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_PNEXT != PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineDiscardRectangleStateCreateFlagsExt> {
        if self.set_mask & PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_FLAGS != PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_FLAGS { return None }
        Some( PipelineDiscardRectangleStateCreateFlagsExt::from_bits(self.raw.flags)
            .expect("PipelineDiscardRectangleStateCreateInfoExt::flags: error converting flags") )
    }

    pub fn get_discard_rectangle_mode<'a>(&'a self) -> Option<DiscardRectangleModeExt> {
        if self.set_mask & PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_DISCARDRECTANGLEMODE != PipelineDiscardRectangleStateCreateInfoExtFlags::FLAG_DISCARDRECTANGLEMODE { return None }
        Some( self.raw.discardRectangleMode.into() )
    }

    pub fn get_discard_rectangles<'a>(&'a self) -> Option<&'a [Rect2d]> {
        if self.raw.pDiscardRectangles.is_null() { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pDiscardRectangles as *const _, self.raw.discardRectangleCount as usize) } )
    }

    pub fn build(self) -> PipelineDiscardRectangleStateCreateInfoExt<'b> {
        PipelineDiscardRectangleStateCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
    raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
    _p: PhantomData<&'s ()>,
}

#[cfg(feature = "experimental")]
impl<'s> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
    pub fn builder<'b>() -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn per_view_position_all_components<'a>(&'a self) -> bool {
        self.raw.perViewPositionAllComponents != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_per_view_position_all_components<'m>(&mut self, per_view_position_all_components: bool) {
        self.raw.perViewPositionAllComponents = per_view_position_all_components as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        &self.raw
    }
}

#[cfg(feature = "experimental")]
impl<'s> From<PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s>> for vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn from(f: PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'s>) -> vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PERVIEWPOSITIONALLCOMPONENTS			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX`.
///
/// 
#[cfg(feature = "experimental")]
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
    raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags,
}

#[cfg(feature = "experimental")]
impl<'b> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
    pub fn new() -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder {
            raw: vks::VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PNEXT;
        self
    }

    pub fn per_view_position_all_components<'m>(mut self, per_view_position_all_components: bool) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxBuilder<'b> {
        self.raw.perViewPositionAllComponents = per_view_position_all_components as u32;
        self.set_mask |= PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PERVIEWPOSITIONALLCOMPONENTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PNEXT != PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_per_view_position_all_components<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PERVIEWPOSITIONALLCOMPONENTS != PhysicalDeviceMultiviewPerViewAttributesPropertiesNvxFlags::FLAG_PERVIEWPOSITIONALLCOMPONENTS { return None }
        Some( self.raw.perViewPositionAllComponents != 0 )
    }

    pub fn build(self) -> PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx<'b> {
        PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSurfaceInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSurfaceInfo2Khr<'s> {
    raw: vks::VkPhysicalDeviceSurfaceInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSurfaceInfo2Khr<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        PhysicalDeviceSurfaceInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSurfaceInfo2KHR) -> PhysicalDeviceSurfaceInfo2Khr<'s> {
        PhysicalDeviceSurfaceInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn surface<'a>(&'a self) -> vks::VkSurfaceKHR {
        self.raw.surface
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface<'m, H>(&mut self, surface: H)
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSurfaceInfo2KHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSurfaceInfo2Khr<'s>> for vks::VkPhysicalDeviceSurfaceInfo2KHR {
    fn from(f: PhysicalDeviceSurfaceInfo2Khr<'s>) -> vks::VkPhysicalDeviceSurfaceInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceSurfaceInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceSurfaceInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SURFACE			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceSurfaceInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
    raw: vks::VkPhysicalDeviceSurfaceInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceSurfaceInfo2KhrFlags,
}

impl<'b> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
    pub fn new() -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        PhysicalDeviceSurfaceInfo2KhrBuilder {
            raw: vks::VkPhysicalDeviceSurfaceInfo2KHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceSurfaceInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn surface<'m, H>(mut self, surface: H) -> PhysicalDeviceSurfaceInfo2KhrBuilder<'b>
            where H: Handle<Target=SurfaceKhrHandle> {
        self.raw.surface = surface.handle().0;
        self.set_mask |= PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_SURFACE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_PNEXT != PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_surface<'a>(&'a self) -> Option<vks::VkSurfaceKHR> {
        if self.set_mask & PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_SURFACE != PhysicalDeviceSurfaceInfo2KhrFlags::FLAG_SURFACE { return None }
        Some( self.raw.surface )
    }

    pub fn build(self) -> PhysicalDeviceSurfaceInfo2Khr<'b> {
        PhysicalDeviceSurfaceInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceCapabilities2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceCapabilities2Khr<'s> {
    raw: vks::VkSurfaceCapabilities2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceCapabilities2Khr<'s> {
    pub fn builder<'b>() -> SurfaceCapabilities2KhrBuilder<'b> {
        SurfaceCapabilities2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceCapabilities2KHR) -> SurfaceCapabilities2Khr<'s> {
        SurfaceCapabilities2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn surface_capabilities<'a>(&'a self) -> &'a SurfaceCapabilitiesKhr {
         unsafe { &*(&self.raw.surfaceCapabilities as *const vks::VkSurfaceCapabilitiesKHR as *const SurfaceCapabilitiesKhr) }
    }

    pub fn surface_capabilities_mut<'a>(&'a mut self) -> &'a mut SurfaceCapabilitiesKhr {
        unsafe { &mut *(&mut self.raw.surfaceCapabilities as *mut  vks::VkSurfaceCapabilitiesKHR as *mut SurfaceCapabilitiesKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_capabilities<'m>(&mut self, surface_capabilities: SurfaceCapabilitiesKhr) {
        self.raw.surfaceCapabilities = surface_capabilities.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceCapabilities2KHR {
        &self.raw
    }
}

impl<'s> From<SurfaceCapabilities2Khr<'s>> for vks::VkSurfaceCapabilities2KHR {
    fn from(f: SurfaceCapabilities2Khr<'s>) -> vks::VkSurfaceCapabilities2KHR {
        f.raw
    }
}


/// Bitflags for `VkSurfaceCapabilities2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SurfaceCapabilities2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SURFACECAPABILITIES			 = 0b100;
    }
}


/// A builder for `VkSurfaceCapabilities2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceCapabilities2KhrBuilder<'b> {
    raw: vks::VkSurfaceCapabilities2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SurfaceCapabilities2KhrFlags,
}

impl<'b> SurfaceCapabilities2KhrBuilder<'b> {
    pub fn new() -> SurfaceCapabilities2KhrBuilder<'b> {
        SurfaceCapabilities2KhrBuilder {
            raw: vks::VkSurfaceCapabilities2KHR::default(),
            _p: PhantomData,
            set_mask: SurfaceCapabilities2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceCapabilities2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SurfaceCapabilities2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn surface_capabilities<'m>(mut self, surface_capabilities: SurfaceCapabilitiesKhr) -> SurfaceCapabilities2KhrBuilder<'b> {
        self.raw.surfaceCapabilities = surface_capabilities.raw;
        self.set_mask |= SurfaceCapabilities2KhrFlags::FLAG_SURFACECAPABILITIES;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SurfaceCapabilities2KhrFlags::FLAG_PNEXT != SurfaceCapabilities2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_surface_capabilities<'a>(&'a self) -> Option<&'a SurfaceCapabilitiesKhr> {
        if self.set_mask & SurfaceCapabilities2KhrFlags::FLAG_SURFACECAPABILITIES != SurfaceCapabilities2KhrFlags::FLAG_SURFACECAPABILITIES { return None }
        Some(  unsafe { &*(&self.raw.surfaceCapabilities as *const vks::VkSurfaceCapabilitiesKHR as *const SurfaceCapabilitiesKhr) } )
    }

    pub fn get_surface_capabilities_mut<'a>(&'a mut self) -> Option<&'a mut SurfaceCapabilitiesKhr> {
        if self.set_mask & SurfaceCapabilities2KhrFlags::FLAG_SURFACECAPABILITIES != SurfaceCapabilities2KhrFlags::FLAG_SURFACECAPABILITIES { return None }
        Some( unsafe { &mut *(&mut self.raw.surfaceCapabilities as *mut  vks::VkSurfaceCapabilitiesKHR as *mut SurfaceCapabilitiesKhr) } )
    }

    pub fn build(self) -> SurfaceCapabilities2Khr<'b> {
        SurfaceCapabilities2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSurfaceFormat2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SurfaceFormat2Khr<'s> {
    raw: vks::VkSurfaceFormat2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SurfaceFormat2Khr<'s> {
    pub fn builder<'b>() -> SurfaceFormat2KhrBuilder<'b> {
        SurfaceFormat2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSurfaceFormat2KHR) -> SurfaceFormat2Khr<'s> {
        SurfaceFormat2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn surface_format<'a>(&'a self) -> &'a SurfaceFormatKhr {
         unsafe { &*(&self.raw.surfaceFormat as *const vks::VkSurfaceFormatKHR as *const SurfaceFormatKhr) }
    }

    pub fn surface_format_mut<'a>(&'a mut self) -> &'a mut SurfaceFormatKhr {
        unsafe { &mut *(&mut self.raw.surfaceFormat as *mut  vks::VkSurfaceFormatKHR as *mut SurfaceFormatKhr) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_surface_format<'m>(&mut self, surface_format: SurfaceFormatKhr) {
        self.raw.surfaceFormat = surface_format.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSurfaceFormat2KHR {
        &self.raw
    }
}

impl<'s> From<SurfaceFormat2Khr<'s>> for vks::VkSurfaceFormat2KHR {
    fn from(f: SurfaceFormat2Khr<'s>) -> vks::VkSurfaceFormat2KHR {
        f.raw
    }
}


/// Bitflags for `VkSurfaceFormat2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SurfaceFormat2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SURFACEFORMAT			 = 0b100;
    }
}


/// A builder for `VkSurfaceFormat2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SurfaceFormat2KhrBuilder<'b> {
    raw: vks::VkSurfaceFormat2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SurfaceFormat2KhrFlags,
}

impl<'b> SurfaceFormat2KhrBuilder<'b> {
    pub fn new() -> SurfaceFormat2KhrBuilder<'b> {
        SurfaceFormat2KhrBuilder {
            raw: vks::VkSurfaceFormat2KHR::default(),
            _p: PhantomData,
            set_mask: SurfaceFormat2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SurfaceFormat2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SurfaceFormat2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn surface_format<'m>(mut self, surface_format: SurfaceFormatKhr) -> SurfaceFormat2KhrBuilder<'b> {
        self.raw.surfaceFormat = surface_format.raw;
        self.set_mask |= SurfaceFormat2KhrFlags::FLAG_SURFACEFORMAT;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SurfaceFormat2KhrFlags::FLAG_PNEXT != SurfaceFormat2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_surface_format<'a>(&'a self) -> Option<&'a SurfaceFormatKhr> {
        if self.set_mask & SurfaceFormat2KhrFlags::FLAG_SURFACEFORMAT != SurfaceFormat2KhrFlags::FLAG_SURFACEFORMAT { return None }
        Some(  unsafe { &*(&self.raw.surfaceFormat as *const vks::VkSurfaceFormatKHR as *const SurfaceFormatKhr) } )
    }

    pub fn get_surface_format_mut<'a>(&'a mut self) -> Option<&'a mut SurfaceFormatKhr> {
        if self.set_mask & SurfaceFormat2KhrFlags::FLAG_SURFACEFORMAT != SurfaceFormat2KhrFlags::FLAG_SURFACEFORMAT { return None }
        Some( unsafe { &mut *(&mut self.raw.surfaceFormat as *mut  vks::VkSurfaceFormatKHR as *mut SurfaceFormatKhr) } )
    }

    pub fn build(self) -> SurfaceFormat2Khr<'b> {
        SurfaceFormat2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSharedPresentSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SharedPresentSurfaceCapabilitiesKhr<'s> {
    raw: vks::VkSharedPresentSurfaceCapabilitiesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SharedPresentSurfaceCapabilitiesKhr<'s> {
    pub fn builder<'b>() -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        SharedPresentSurfaceCapabilitiesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSharedPresentSurfaceCapabilitiesKHR) -> SharedPresentSurfaceCapabilitiesKhr<'s> {
        SharedPresentSurfaceCapabilitiesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn shared_present_supported_usage_flags<'a>(&'a self) -> ImageUsageFlags {
        ImageUsageFlags::from_bits(self.raw.sharedPresentSupportedUsageFlags)
            .expect("SharedPresentSurfaceCapabilitiesKhr::shared_present_supported_usage_flags: error converting flags")
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_shared_present_supported_usage_flags<'m>(&mut self, shared_present_supported_usage_flags: ImageUsageFlags) {
        self.raw.sharedPresentSupportedUsageFlags = shared_present_supported_usage_flags.bits();
    }

    pub fn as_raw(&self) -> &vks::VkSharedPresentSurfaceCapabilitiesKHR {
        &self.raw
    }
}

impl<'s> From<SharedPresentSurfaceCapabilitiesKhr<'s>> for vks::VkSharedPresentSurfaceCapabilitiesKHR {
    fn from(f: SharedPresentSurfaceCapabilitiesKhr<'s>) -> vks::VkSharedPresentSurfaceCapabilitiesKHR {
        f.raw
    }
}


/// Bitflags for `VkSharedPresentSurfaceCapabilitiesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SharedPresentSurfaceCapabilitiesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SHAREDPRESENTSUPPORTEDUSAGEFLAGS			 = 0b100;
    }
}


/// A builder for `VkSharedPresentSurfaceCapabilitiesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
    raw: vks::VkSharedPresentSurfaceCapabilitiesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SharedPresentSurfaceCapabilitiesKhrFlags,
}

impl<'b> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
    pub fn new() -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        SharedPresentSurfaceCapabilitiesKhrBuilder {
            raw: vks::VkSharedPresentSurfaceCapabilitiesKHR::default(),
            _p: PhantomData,
            set_mask: SharedPresentSurfaceCapabilitiesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn shared_present_supported_usage_flags<'m>(mut self, shared_present_supported_usage_flags: ImageUsageFlags) -> SharedPresentSurfaceCapabilitiesKhrBuilder<'b> {
        self.raw.sharedPresentSupportedUsageFlags = shared_present_supported_usage_flags.bits();
        self.set_mask |= SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_SHAREDPRESENTSUPPORTEDUSAGEFLAGS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_PNEXT != SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_shared_present_supported_usage_flags<'a>(&'a self) -> Option<ImageUsageFlags> {
        if self.set_mask & SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_SHAREDPRESENTSUPPORTEDUSAGEFLAGS != SharedPresentSurfaceCapabilitiesKhrFlags::FLAG_SHAREDPRESENTSUPPORTEDUSAGEFLAGS { return None }
        Some( ImageUsageFlags::from_bits(self.raw.sharedPresentSupportedUsageFlags)
            .expect("SharedPresentSurfaceCapabilitiesKhr::shared_present_supported_usage_flags: error converting flags") )
    }

    pub fn build(self) -> SharedPresentSurfaceCapabilitiesKhr<'b> {
        SharedPresentSurfaceCapabilitiesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDevice16BitStorageFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDevice16BitStorageFeaturesKhr<'s> {
    raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDevice16BitStorageFeaturesKhr<'s> {
    pub fn builder<'b>() -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        PhysicalDevice16BitStorageFeaturesKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR) -> PhysicalDevice16BitStorageFeaturesKhr<'s> {
        PhysicalDevice16BitStorageFeaturesKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.storageBuffer16BitAccess != 0
    }

    pub fn uniform_and_storage_buffer_16_bit_access<'a>(&'a self) -> bool {
        self.raw.uniformAndStorageBuffer16BitAccess != 0
    }

    pub fn storage_push_constant_16<'a>(&'a self) -> bool {
        self.raw.storagePushConstant16 != 0
    }

    pub fn storage_input_output_16<'a>(&'a self) -> bool {
        self.raw.storageInputOutput16 != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_storage_buffer_16_bit_access<'m>(&mut self, storage_buffer_16_bit_access: bool) {
        self.raw.storageBuffer16BitAccess = storage_buffer_16_bit_access as u32;
    }

    pub fn set_uniform_and_storage_buffer_16_bit_access<'m>(&mut self, uniform_and_storage_buffer_16_bit_access: bool) {
        self.raw.uniformAndStorageBuffer16BitAccess = uniform_and_storage_buffer_16_bit_access as u32;
    }

    pub fn set_storage_push_constant_16<'m>(&mut self, storage_push_constant_16: bool) {
        self.raw.storagePushConstant16 = storage_push_constant_16 as u32;
    }

    pub fn set_storage_input_output_16<'m>(&mut self, storage_input_output_16: bool) {
        self.raw.storageInputOutput16 = storage_input_output_16 as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDevice16BitStorageFeaturesKHR {
        &self.raw
    }
}

impl<'s> From<PhysicalDevice16BitStorageFeaturesKhr<'s>> for vks::VkPhysicalDevice16BitStorageFeaturesKHR {
    fn from(f: PhysicalDevice16BitStorageFeaturesKhr<'s>) -> vks::VkPhysicalDevice16BitStorageFeaturesKHR {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDevice16BitStorageFeaturesKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDevice16BitStorageFeaturesKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_STORAGEBUFFER16BITACCESS			 = 0b100;
        const FLAG_UNIFORMANDSTORAGEBUFFER16BITACCESS			 = 0b1000;
        const FLAG_STORAGEPUSHCONSTANT16			 = 0b10000;
        const FLAG_STORAGEINPUTOUTPUT16			 = 0b100000;
    }
}


/// A builder for `VkPhysicalDevice16BitStorageFeaturesKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
    raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDevice16BitStorageFeaturesKhrFlags,
}

impl<'b> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
    pub fn new() -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        PhysicalDevice16BitStorageFeaturesKhrBuilder {
            raw: vks::VkPhysicalDevice16BitStorageFeaturesKHR::default(),
            _p: PhantomData,
            set_mask: PhysicalDevice16BitStorageFeaturesKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn storage_buffer_16_bit_access<'m>(mut self, storage_buffer_16_bit_access: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storageBuffer16BitAccess = storage_buffer_16_bit_access as u32;
        self.set_mask |= PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEBUFFER16BITACCESS;
        self
    }

    pub fn uniform_and_storage_buffer_16_bit_access<'m>(mut self, uniform_and_storage_buffer_16_bit_access: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.uniformAndStorageBuffer16BitAccess = uniform_and_storage_buffer_16_bit_access as u32;
        self.set_mask |= PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_UNIFORMANDSTORAGEBUFFER16BITACCESS;
        self
    }

    pub fn storage_push_constant_16<'m>(mut self, storage_push_constant_16: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storagePushConstant16 = storage_push_constant_16 as u32;
        self.set_mask |= PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEPUSHCONSTANT16;
        self
    }

    pub fn storage_input_output_16<'m>(mut self, storage_input_output_16: bool) -> PhysicalDevice16BitStorageFeaturesKhrBuilder<'b> {
        self.raw.storageInputOutput16 = storage_input_output_16 as u32;
        self.set_mask |= PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEINPUTOUTPUT16;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_PNEXT != PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_storage_buffer_16_bit_access<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEBUFFER16BITACCESS != PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEBUFFER16BITACCESS { return None }
        Some( self.raw.storageBuffer16BitAccess != 0 )
    }

    pub fn get_uniform_and_storage_buffer_16_bit_access<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_UNIFORMANDSTORAGEBUFFER16BITACCESS != PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_UNIFORMANDSTORAGEBUFFER16BITACCESS { return None }
        Some( self.raw.uniformAndStorageBuffer16BitAccess != 0 )
    }

    pub fn get_storage_push_constant_16<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEPUSHCONSTANT16 != PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEPUSHCONSTANT16 { return None }
        Some( self.raw.storagePushConstant16 != 0 )
    }

    pub fn get_storage_input_output_16<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEINPUTOUTPUT16 != PhysicalDevice16BitStorageFeaturesKhrFlags::FLAG_STORAGEINPUTOUTPUT16 { return None }
        Some( self.raw.storageInputOutput16 != 0 )
    }

    pub fn build(self) -> PhysicalDevice16BitStorageFeaturesKhr<'b> {
        PhysicalDevice16BitStorageFeaturesKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkBufferMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct BufferMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkBufferMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> BufferMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        BufferMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkBufferMemoryRequirementsInfo2KHR) -> BufferMemoryRequirementsInfo2Khr<'s> {
        BufferMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkBufferMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<BufferMemoryRequirementsInfo2Khr<'s>> for vks::VkBufferMemoryRequirementsInfo2KHR {
    fn from(f: BufferMemoryRequirementsInfo2Khr<'s>) -> vks::VkBufferMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkBufferMemoryRequirementsInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct BufferMemoryRequirementsInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_BUFFER			 = 0b100;
    }
}


/// A builder for `VkBufferMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct BufferMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkBufferMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: BufferMemoryRequirementsInfo2KhrFlags,
}

impl<'b> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        BufferMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkBufferMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
            set_mask: BufferMemoryRequirementsInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> BufferMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= BufferMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> BufferMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= BufferMemoryRequirementsInfo2KhrFlags::FLAG_BUFFER;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & BufferMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT != BufferMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & BufferMemoryRequirementsInfo2KhrFlags::FLAG_BUFFER != BufferMemoryRequirementsInfo2KhrFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn build(self) -> BufferMemoryRequirementsInfo2Khr<'b> {
        BufferMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkImageMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageMemoryRequirementsInfo2KHR) -> ImageMemoryRequirementsInfo2Khr<'s> {
        ImageMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<ImageMemoryRequirementsInfo2Khr<'s>> for vks::VkImageMemoryRequirementsInfo2KHR {
    fn from(f: ImageMemoryRequirementsInfo2Khr<'s>) -> vks::VkImageMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkImageMemoryRequirementsInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageMemoryRequirementsInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_IMAGE			 = 0b100;
    }
}


/// A builder for `VkImageMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkImageMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageMemoryRequirementsInfo2KhrFlags,
}

impl<'b> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkImageMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
            set_mask: ImageMemoryRequirementsInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= ImageMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT != ImageMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & ImageMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE != ImageMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn build(self) -> ImageMemoryRequirementsInfo2Khr<'b> {
        ImageMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkImageSparseMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct ImageSparseMemoryRequirementsInfo2Khr<'s> {
    raw: vks::VkImageSparseMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> ImageSparseMemoryRequirementsInfo2Khr<'s> {
    pub fn builder<'b>() -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageSparseMemoryRequirementsInfo2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkImageSparseMemoryRequirementsInfo2KHR) -> ImageSparseMemoryRequirementsInfo2Khr<'s> {
        ImageSparseMemoryRequirementsInfo2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkImageSparseMemoryRequirementsInfo2KHR {
        &self.raw
    }
}

impl<'s> From<ImageSparseMemoryRequirementsInfo2Khr<'s>> for vks::VkImageSparseMemoryRequirementsInfo2KHR {
    fn from(f: ImageSparseMemoryRequirementsInfo2Khr<'s>) -> vks::VkImageSparseMemoryRequirementsInfo2KHR {
        f.raw
    }
}


/// Bitflags for `VkImageSparseMemoryRequirementsInfo2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct ImageSparseMemoryRequirementsInfo2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_IMAGE			 = 0b100;
    }
}


/// A builder for `VkImageSparseMemoryRequirementsInfo2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
    raw: vks::VkImageSparseMemoryRequirementsInfo2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: ImageSparseMemoryRequirementsInfo2KhrFlags,
}

impl<'b> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
    pub fn new() -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        ImageSparseMemoryRequirementsInfo2KhrBuilder {
            raw: vks::VkImageSparseMemoryRequirementsInfo2KHR::default(),
            _p: PhantomData,
            set_mask: ImageSparseMemoryRequirementsInfo2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> ImageSparseMemoryRequirementsInfo2KhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT != ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE != ImageSparseMemoryRequirementsInfo2KhrFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn build(self) -> ImageSparseMemoryRequirementsInfo2Khr<'b> {
        ImageSparseMemoryRequirementsInfo2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryRequirements2Khr<'s> {
    raw: vks::VkMemoryRequirements2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryRequirements2Khr<'s> {
    pub fn builder<'b>() -> MemoryRequirements2KhrBuilder<'b> {
        MemoryRequirements2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryRequirements2KHR) -> MemoryRequirements2Khr<'s> {
        MemoryRequirements2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_requirements<'a>(&'a self) -> &'a MemoryRequirements {
         unsafe { &*(&self.raw.memoryRequirements as *const vks::VkMemoryRequirements as *const MemoryRequirements) }
    }

    pub fn memory_requirements_mut<'a>(&'a mut self) -> &'a mut MemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkMemoryRequirements as *mut MemoryRequirements) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_requirements<'m>(&mut self, memory_requirements: MemoryRequirements) {
        self.raw.memoryRequirements = memory_requirements.raw;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryRequirements2KHR {
        &self.raw
    }
}

impl<'s> From<MemoryRequirements2Khr<'s>> for vks::VkMemoryRequirements2KHR {
    fn from(f: MemoryRequirements2Khr<'s>) -> vks::VkMemoryRequirements2KHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryRequirements2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryRequirements2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORYREQUIREMENTS			 = 0b100;
    }
}


/// A builder for `VkMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryRequirements2KhrBuilder<'b> {
    raw: vks::VkMemoryRequirements2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryRequirements2KhrFlags,
}

impl<'b> MemoryRequirements2KhrBuilder<'b> {
    pub fn new() -> MemoryRequirements2KhrBuilder<'b> {
        MemoryRequirements2KhrBuilder {
            raw: vks::VkMemoryRequirements2KHR::default(),
            _p: PhantomData,
            set_mask: MemoryRequirements2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryRequirements2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryRequirements2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory_requirements<'m>(mut self, memory_requirements: MemoryRequirements) -> MemoryRequirements2KhrBuilder<'b> {
        self.raw.memoryRequirements = memory_requirements.raw;
        self.set_mask |= MemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & MemoryRequirements2KhrFlags::FLAG_PNEXT != MemoryRequirements2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory_requirements<'a>(&'a self) -> Option<&'a MemoryRequirements> {
        if self.set_mask & MemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS != MemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS { return None }
        Some(  unsafe { &*(&self.raw.memoryRequirements as *const vks::VkMemoryRequirements as *const MemoryRequirements) } )
    }

    pub fn get_memory_requirements_mut<'a>(&'a mut self) -> Option<&'a mut MemoryRequirements> {
        if self.set_mask & MemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS != MemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS { return None }
        Some( unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkMemoryRequirements as *mut MemoryRequirements) } )
    }

    pub fn build(self) -> MemoryRequirements2Khr<'b> {
        MemoryRequirements2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSparseImageMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SparseImageMemoryRequirements2Khr<'s> {
    raw: vks::VkSparseImageMemoryRequirements2KHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> SparseImageMemoryRequirements2Khr<'s> {
    pub fn builder<'b>() -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        SparseImageMemoryRequirements2KhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSparseImageMemoryRequirements2KHR) -> SparseImageMemoryRequirements2Khr<'s> {
        SparseImageMemoryRequirements2Khr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn memory_requirements<'a>(&'a self) -> &'a SparseImageMemoryRequirements {
         unsafe { &*(&self.raw.memoryRequirements as *const vks::VkSparseImageMemoryRequirements as *const SparseImageMemoryRequirements) }
    }

    pub fn memory_requirements_mut<'a>(&'a mut self) -> &'a mut SparseImageMemoryRequirements {
        unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkSparseImageMemoryRequirements as *mut SparseImageMemoryRequirements) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_memory_requirements<'m>(&mut self, memory_requirements: SparseImageMemoryRequirements) {
        self.raw.memoryRequirements = memory_requirements.raw;
    }

    pub fn as_raw(&self) -> &vks::VkSparseImageMemoryRequirements2KHR {
        &self.raw
    }
}

impl<'s> From<SparseImageMemoryRequirements2Khr<'s>> for vks::VkSparseImageMemoryRequirements2KHR {
    fn from(f: SparseImageMemoryRequirements2Khr<'s>) -> vks::VkSparseImageMemoryRequirements2KHR {
        f.raw
    }
}


/// Bitflags for `VkSparseImageMemoryRequirements2KHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SparseImageMemoryRequirements2KhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_MEMORYREQUIREMENTS			 = 0b100;
    }
}


/// A builder for `VkSparseImageMemoryRequirements2KHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SparseImageMemoryRequirements2KhrBuilder<'b> {
    raw: vks::VkSparseImageMemoryRequirements2KHR,
    _p: PhantomData<&'b ()>, 
    set_mask: SparseImageMemoryRequirements2KhrFlags,
}

impl<'b> SparseImageMemoryRequirements2KhrBuilder<'b> {
    pub fn new() -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        SparseImageMemoryRequirements2KhrBuilder {
            raw: vks::VkSparseImageMemoryRequirements2KHR::default(),
            _p: PhantomData,
            set_mask: SparseImageMemoryRequirements2KhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SparseImageMemoryRequirements2KhrFlags::FLAG_PNEXT;
        self
    }

    pub fn memory_requirements<'m>(mut self, memory_requirements: SparseImageMemoryRequirements) -> SparseImageMemoryRequirements2KhrBuilder<'b> {
        self.raw.memoryRequirements = memory_requirements.raw;
        self.set_mask |= SparseImageMemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & SparseImageMemoryRequirements2KhrFlags::FLAG_PNEXT != SparseImageMemoryRequirements2KhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_memory_requirements<'a>(&'a self) -> Option<&'a SparseImageMemoryRequirements> {
        if self.set_mask & SparseImageMemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS != SparseImageMemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS { return None }
        Some(  unsafe { &*(&self.raw.memoryRequirements as *const vks::VkSparseImageMemoryRequirements as *const SparseImageMemoryRequirements) } )
    }

    pub fn get_memory_requirements_mut<'a>(&'a mut self) -> Option<&'a mut SparseImageMemoryRequirements> {
        if self.set_mask & SparseImageMemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS != SparseImageMemoryRequirements2KhrFlags::FLAG_MEMORYREQUIREMENTS { return None }
        Some( unsafe { &mut *(&mut self.raw.memoryRequirements as *mut  vks::VkSparseImageMemoryRequirements as *mut SparseImageMemoryRequirements) } )
    }

    pub fn build(self) -> SparseImageMemoryRequirements2Khr<'b> {
        SparseImageMemoryRequirements2Khr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryDedicatedRequirementsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryDedicatedRequirementsKhr<'s> {
    raw: vks::VkMemoryDedicatedRequirementsKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryDedicatedRequirementsKhr<'s> {
    pub fn builder<'b>() -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        MemoryDedicatedRequirementsKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryDedicatedRequirementsKHR) -> MemoryDedicatedRequirementsKhr<'s> {
        MemoryDedicatedRequirementsKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn prefers_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.prefersDedicatedAllocation != 0
    }

    pub fn requires_dedicated_allocation<'a>(&'a self) -> bool {
        self.raw.requiresDedicatedAllocation != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_prefers_dedicated_allocation<'m>(&mut self, prefers_dedicated_allocation: bool) {
        self.raw.prefersDedicatedAllocation = prefers_dedicated_allocation as u32;
    }

    pub fn set_requires_dedicated_allocation<'m>(&mut self, requires_dedicated_allocation: bool) {
        self.raw.requiresDedicatedAllocation = requires_dedicated_allocation as u32;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryDedicatedRequirementsKHR {
        &self.raw
    }
}

impl<'s> From<MemoryDedicatedRequirementsKhr<'s>> for vks::VkMemoryDedicatedRequirementsKHR {
    fn from(f: MemoryDedicatedRequirementsKhr<'s>) -> vks::VkMemoryDedicatedRequirementsKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryDedicatedRequirementsKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryDedicatedRequirementsKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_PREFERSDEDICATEDALLOCATION			 = 0b100;
        const FLAG_REQUIRESDEDICATEDALLOCATION			 = 0b1000;
    }
}


/// A builder for `VkMemoryDedicatedRequirementsKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryDedicatedRequirementsKhrBuilder<'b> {
    raw: vks::VkMemoryDedicatedRequirementsKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryDedicatedRequirementsKhrFlags,
}

impl<'b> MemoryDedicatedRequirementsKhrBuilder<'b> {
    pub fn new() -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        MemoryDedicatedRequirementsKhrBuilder {
            raw: vks::VkMemoryDedicatedRequirementsKHR::default(),
            _p: PhantomData,
            set_mask: MemoryDedicatedRequirementsKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryDedicatedRequirementsKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn prefers_dedicated_allocation<'m>(mut self, prefers_dedicated_allocation: bool) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.prefersDedicatedAllocation = prefers_dedicated_allocation as u32;
        self.set_mask |= MemoryDedicatedRequirementsKhrFlags::FLAG_PREFERSDEDICATEDALLOCATION;
        self
    }

    pub fn requires_dedicated_allocation<'m>(mut self, requires_dedicated_allocation: bool) -> MemoryDedicatedRequirementsKhrBuilder<'b> {
        self.raw.requiresDedicatedAllocation = requires_dedicated_allocation as u32;
        self.set_mask |= MemoryDedicatedRequirementsKhrFlags::FLAG_REQUIRESDEDICATEDALLOCATION;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & MemoryDedicatedRequirementsKhrFlags::FLAG_PNEXT != MemoryDedicatedRequirementsKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_prefers_dedicated_allocation<'a>(&'a self) -> Option<bool> {
        if self.set_mask & MemoryDedicatedRequirementsKhrFlags::FLAG_PREFERSDEDICATEDALLOCATION != MemoryDedicatedRequirementsKhrFlags::FLAG_PREFERSDEDICATEDALLOCATION { return None }
        Some( self.raw.prefersDedicatedAllocation != 0 )
    }

    pub fn get_requires_dedicated_allocation<'a>(&'a self) -> Option<bool> {
        if self.set_mask & MemoryDedicatedRequirementsKhrFlags::FLAG_REQUIRESDEDICATEDALLOCATION != MemoryDedicatedRequirementsKhrFlags::FLAG_REQUIRESDEDICATEDALLOCATION { return None }
        Some( self.raw.requiresDedicatedAllocation != 0 )
    }

    pub fn build(self) -> MemoryDedicatedRequirementsKhr<'b> {
        MemoryDedicatedRequirementsKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkMemoryDedicatedAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct MemoryDedicatedAllocateInfoKhr<'s> {
    raw: vks::VkMemoryDedicatedAllocateInfoKHR,
    _p: PhantomData<&'s ()>,
}

impl<'s> MemoryDedicatedAllocateInfoKhr<'s> {
    pub fn builder<'b>() -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        MemoryDedicatedAllocateInfoKhrBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkMemoryDedicatedAllocateInfoKHR) -> MemoryDedicatedAllocateInfoKhr<'s> {
        MemoryDedicatedAllocateInfoKhr { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn image<'a>(&'a self) -> vks::VkImage {
        self.raw.image
    }

    pub fn buffer<'a>(&'a self) -> vks::VkBuffer {
        self.raw.buffer
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_image<'m, H>(&mut self, image: H)
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
    }

    pub fn set_buffer<'m, H>(&mut self, buffer: H)
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
    }

    pub fn as_raw(&self) -> &vks::VkMemoryDedicatedAllocateInfoKHR {
        &self.raw
    }
}

impl<'s> From<MemoryDedicatedAllocateInfoKhr<'s>> for vks::VkMemoryDedicatedAllocateInfoKHR {
    fn from(f: MemoryDedicatedAllocateInfoKhr<'s>) -> vks::VkMemoryDedicatedAllocateInfoKHR {
        f.raw
    }
}


/// Bitflags for `VkMemoryDedicatedAllocateInfoKHR`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct MemoryDedicatedAllocateInfoKhrFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_IMAGE			 = 0b100;
        const FLAG_BUFFER			 = 0b1000;
    }
}


/// A builder for `VkMemoryDedicatedAllocateInfoKHR`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct MemoryDedicatedAllocateInfoKhrBuilder<'b> {
    raw: vks::VkMemoryDedicatedAllocateInfoKHR,
    _p: PhantomData<&'b ()>, 
    set_mask: MemoryDedicatedAllocateInfoKhrFlags,
}

impl<'b> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
    pub fn new() -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        MemoryDedicatedAllocateInfoKhrBuilder {
            raw: vks::VkMemoryDedicatedAllocateInfoKHR::default(),
            _p: PhantomData,
            set_mask: MemoryDedicatedAllocateInfoKhrFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> MemoryDedicatedAllocateInfoKhrBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= MemoryDedicatedAllocateInfoKhrFlags::FLAG_PNEXT;
        self
    }

    pub fn image<'m, H>(mut self, image: H) -> MemoryDedicatedAllocateInfoKhrBuilder<'b>
            where H: Handle<Target=ImageHandle> {
        self.raw.image = image.handle().0;
        self.set_mask |= MemoryDedicatedAllocateInfoKhrFlags::FLAG_IMAGE;
        self
    }

    pub fn buffer<'m, H>(mut self, buffer: H) -> MemoryDedicatedAllocateInfoKhrBuilder<'b>
            where H: Handle<Target=BufferHandle> {
        self.raw.buffer = buffer.handle().0;
        self.set_mask |= MemoryDedicatedAllocateInfoKhrFlags::FLAG_BUFFER;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & MemoryDedicatedAllocateInfoKhrFlags::FLAG_PNEXT != MemoryDedicatedAllocateInfoKhrFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_image<'a>(&'a self) -> Option<vks::VkImage> {
        if self.set_mask & MemoryDedicatedAllocateInfoKhrFlags::FLAG_IMAGE != MemoryDedicatedAllocateInfoKhrFlags::FLAG_IMAGE { return None }
        Some( self.raw.image )
    }

    pub fn get_buffer<'a>(&'a self) -> Option<vks::VkBuffer> {
        if self.set_mask & MemoryDedicatedAllocateInfoKhrFlags::FLAG_BUFFER != MemoryDedicatedAllocateInfoKhrFlags::FLAG_BUFFER { return None }
        Some( self.raw.buffer )
    }

    pub fn build(self) -> MemoryDedicatedAllocateInfoKhr<'b> {
        MemoryDedicatedAllocateInfoKhr {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkTextureLODGatherFormatPropertiesAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct TextureLODGatherFormatPropertiesAmd<'s> {
    raw: vks::VkTextureLODGatherFormatPropertiesAMD,
    _p: PhantomData<&'s ()>,
}

impl<'s> TextureLODGatherFormatPropertiesAmd<'s> {
    pub fn builder<'b>() -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        TextureLODGatherFormatPropertiesAmdBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkTextureLODGatherFormatPropertiesAMD) -> TextureLODGatherFormatPropertiesAmd<'s> {
        TextureLODGatherFormatPropertiesAmd { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn supports_texture_gather_lodbias_amd<'a>(&'a self) -> bool {
        self.raw.supportsTextureGatherLODBiasAMD != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_supports_texture_gather_lodbias_amd<'m>(&mut self, supports_texture_gather_lodbias_amd: bool) {
        self.raw.supportsTextureGatherLODBiasAMD = supports_texture_gather_lodbias_amd as u32;
    }

    pub fn as_raw(&self) -> &vks::VkTextureLODGatherFormatPropertiesAMD {
        &self.raw
    }
}

impl<'s> From<TextureLODGatherFormatPropertiesAmd<'s>> for vks::VkTextureLODGatherFormatPropertiesAMD {
    fn from(f: TextureLODGatherFormatPropertiesAmd<'s>) -> vks::VkTextureLODGatherFormatPropertiesAMD {
        f.raw
    }
}


/// Bitflags for `VkTextureLODGatherFormatPropertiesAMD`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct TextureLODGatherFormatPropertiesAmdFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SUPPORTSTEXTUREGATHERLODBIASAMD			 = 0b100;
    }
}


/// A builder for `VkTextureLODGatherFormatPropertiesAMD`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct TextureLODGatherFormatPropertiesAmdBuilder<'b> {
    raw: vks::VkTextureLODGatherFormatPropertiesAMD,
    _p: PhantomData<&'b ()>, 
    set_mask: TextureLODGatherFormatPropertiesAmdFlags,
}

impl<'b> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
    pub fn new() -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        TextureLODGatherFormatPropertiesAmdBuilder {
            raw: vks::VkTextureLODGatherFormatPropertiesAMD::default(),
            _p: PhantomData,
            set_mask: TextureLODGatherFormatPropertiesAmdFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= TextureLODGatherFormatPropertiesAmdFlags::FLAG_PNEXT;
        self
    }

    pub fn supports_texture_gather_lodbias_amd<'m>(mut self, supports_texture_gather_lodbias_amd: bool) -> TextureLODGatherFormatPropertiesAmdBuilder<'b> {
        self.raw.supportsTextureGatherLODBiasAMD = supports_texture_gather_lodbias_amd as u32;
        self.set_mask |= TextureLODGatherFormatPropertiesAmdFlags::FLAG_SUPPORTSTEXTUREGATHERLODBIASAMD;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & TextureLODGatherFormatPropertiesAmdFlags::FLAG_PNEXT != TextureLODGatherFormatPropertiesAmdFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_supports_texture_gather_lodbias_amd<'a>(&'a self) -> Option<bool> {
        if self.set_mask & TextureLODGatherFormatPropertiesAmdFlags::FLAG_SUPPORTSTEXTUREGATHERLODBIASAMD != TextureLODGatherFormatPropertiesAmdFlags::FLAG_SUPPORTSTEXTUREGATHERLODBIASAMD { return None }
        Some( self.raw.supportsTextureGatherLODBiasAMD != 0 )
    }

    pub fn build(self) -> TextureLODGatherFormatPropertiesAmd<'b> {
        TextureLODGatherFormatPropertiesAmd {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCoverageToColorStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCoverageToColorStateCreateInfoNv<'s> {
    raw: vks::VkPipelineCoverageToColorStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCoverageToColorStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        PipelineCoverageToColorStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCoverageToColorStateCreateInfoNV) -> PipelineCoverageToColorStateCreateInfoNv<'s> {
        PipelineCoverageToColorStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCoverageToColorStateCreateFlagsNv {
        PipelineCoverageToColorStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageToColorStateCreateInfoNv::flags: error converting flags")
    }

    pub fn coverage_to_color_enable<'a>(&'a self) -> bool {
        self.raw.coverageToColorEnable != 0
    }

    pub fn coverage_to_color_location<'a>(&'a self) -> u32 {
        self.raw.coverageToColorLocation.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCoverageToColorStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_coverage_to_color_enable<'m>(&mut self, coverage_to_color_enable: bool) {
        self.raw.coverageToColorEnable = coverage_to_color_enable as u32;
    }

    pub fn set_coverage_to_color_location<'m>(&mut self, coverage_to_color_location: u32) {
        self.raw.coverageToColorLocation = coverage_to_color_location.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCoverageToColorStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineCoverageToColorStateCreateInfoNv<'s>> for vks::VkPipelineCoverageToColorStateCreateInfoNV {
    fn from(f: PipelineCoverageToColorStateCreateInfoNv<'s>) -> vks::VkPipelineCoverageToColorStateCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkPipelineCoverageToColorStateCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineCoverageToColorStateCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_COVERAGETOCOLORENABLE			 = 0b1000;
        const FLAG_COVERAGETOCOLORLOCATION			 = 0b10000;
    }
}


/// A builder for `VkPipelineCoverageToColorStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineCoverageToColorStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineCoverageToColorStateCreateInfoNvFlags,
}

impl<'b> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        PipelineCoverageToColorStateCreateInfoNvBuilder {
            raw: vks::VkPipelineCoverageToColorStateCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: PipelineCoverageToColorStateCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCoverageToColorStateCreateFlagsNv) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_FLAGS;
        self
    }

    pub fn coverage_to_color_enable<'m>(mut self, coverage_to_color_enable: bool) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.coverageToColorEnable = coverage_to_color_enable as u32;
        self.set_mask |= PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORENABLE;
        self
    }

    pub fn coverage_to_color_location<'m>(mut self, coverage_to_color_location: u32) -> PipelineCoverageToColorStateCreateInfoNvBuilder<'b> {
        self.raw.coverageToColorLocation = coverage_to_color_location.into();
        self.set_mask |= PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORLOCATION;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_PNEXT != PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineCoverageToColorStateCreateFlagsNv> {
        if self.set_mask & PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_FLAGS != PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_FLAGS { return None }
        Some( PipelineCoverageToColorStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageToColorStateCreateInfoNv::flags: error converting flags") )
    }

    pub fn get_coverage_to_color_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORENABLE != PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORENABLE { return None }
        Some( self.raw.coverageToColorEnable != 0 )
    }

    pub fn get_coverage_to_color_location<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORLOCATION != PipelineCoverageToColorStateCreateInfoNvFlags::FLAG_COVERAGETOCOLORLOCATION { return None }
        Some( self.raw.coverageToColorLocation.into() )
    }

    pub fn build(self) -> PipelineCoverageToColorStateCreateInfoNv<'b> {
        PipelineCoverageToColorStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn filter_minmax_single_component_formats<'a>(&'a self) -> bool {
        self.raw.filterMinmaxSingleComponentFormats != 0
    }

    pub fn filter_minmax_image_component_mapping<'a>(&'a self) -> bool {
        self.raw.filterMinmaxImageComponentMapping != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_filter_minmax_single_component_formats<'m>(&mut self, filter_minmax_single_component_formats: bool) {
        self.raw.filterMinmaxSingleComponentFormats = filter_minmax_single_component_formats as u32;
    }

    pub fn set_filter_minmax_image_component_mapping<'m>(&mut self, filter_minmax_image_component_mapping: bool) {
        self.raw.filterMinmaxImageComponentMapping = filter_minmax_image_component_mapping as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s>> for vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    fn from(f: PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'s>) -> vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FILTERMINMAXSINGLECOMPONENTFORMATS			 = 0b100;
        const FLAG_FILTERMINMAXIMAGECOMPONENTMAPPING			 = 0b1000;
    }
}


/// A builder for `VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags,
}

impl<'b> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_PNEXT;
        self
    }

    pub fn filter_minmax_single_component_formats<'m>(mut self, filter_minmax_single_component_formats: bool) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.filterMinmaxSingleComponentFormats = filter_minmax_single_component_formats as u32;
        self.set_mask |= PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXSINGLECOMPONENTFORMATS;
        self
    }

    pub fn filter_minmax_image_component_mapping<'m>(mut self, filter_minmax_image_component_mapping: bool) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExtBuilder<'b> {
        self.raw.filterMinmaxImageComponentMapping = filter_minmax_image_component_mapping as u32;
        self.set_mask |= PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXIMAGECOMPONENTMAPPING;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_PNEXT != PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_filter_minmax_single_component_formats<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXSINGLECOMPONENTFORMATS != PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXSINGLECOMPONENTFORMATS { return None }
        Some( self.raw.filterMinmaxSingleComponentFormats != 0 )
    }

    pub fn get_filter_minmax_image_component_mapping<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXIMAGECOMPONENTMAPPING != PhysicalDeviceSamplerFilterMinmaxPropertiesExtFlags::FLAG_FILTERMINMAXIMAGECOMPONENTMAPPING { return None }
        Some( self.raw.filterMinmaxImageComponentMapping != 0 )
    }

    pub fn build(self) -> PhysicalDeviceSamplerFilterMinmaxPropertiesExt<'b> {
        PhysicalDeviceSamplerFilterMinmaxPropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkSamplerReductionModeCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct SamplerReductionModeCreateInfoExt<'s> {
    raw: vks::VkSamplerReductionModeCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> SamplerReductionModeCreateInfoExt<'s> {
    pub fn builder<'b>() -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        SamplerReductionModeCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkSamplerReductionModeCreateInfoEXT) -> SamplerReductionModeCreateInfoExt<'s> {
        SamplerReductionModeCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn reduction_mode<'a>(&'a self) -> SamplerReductionModeExt {
        self.raw.reductionMode.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_reduction_mode<'m>(&mut self, reduction_mode: SamplerReductionModeExt) {
        self.raw.reductionMode = reduction_mode.into();
    }

    pub fn as_raw(&self) -> &vks::VkSamplerReductionModeCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<SamplerReductionModeCreateInfoExt<'s>> for vks::VkSamplerReductionModeCreateInfoEXT {
    fn from(f: SamplerReductionModeCreateInfoExt<'s>) -> vks::VkSamplerReductionModeCreateInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkSamplerReductionModeCreateInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct SamplerReductionModeCreateInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_REDUCTIONMODE			 = 0b100;
    }
}


/// A builder for `VkSamplerReductionModeCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct SamplerReductionModeCreateInfoExtBuilder<'b> {
    raw: vks::VkSamplerReductionModeCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: SamplerReductionModeCreateInfoExtFlags,
}

impl<'b> SamplerReductionModeCreateInfoExtBuilder<'b> {
    pub fn new() -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        SamplerReductionModeCreateInfoExtBuilder {
            raw: vks::VkSamplerReductionModeCreateInfoEXT::default(),
            _p: PhantomData,
            set_mask: SamplerReductionModeCreateInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= SamplerReductionModeCreateInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn reduction_mode<'m>(mut self, reduction_mode: SamplerReductionModeExt) -> SamplerReductionModeCreateInfoExtBuilder<'b> {
        self.raw.reductionMode = reduction_mode.into();
        self.set_mask |= SamplerReductionModeCreateInfoExtFlags::FLAG_REDUCTIONMODE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & SamplerReductionModeCreateInfoExtFlags::FLAG_PNEXT != SamplerReductionModeCreateInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_reduction_mode<'a>(&'a self) -> Option<SamplerReductionModeExt> {
        if self.set_mask & SamplerReductionModeCreateInfoExtFlags::FLAG_REDUCTIONMODE != SamplerReductionModeCreateInfoExtFlags::FLAG_REDUCTIONMODE { return None }
        Some( self.raw.reductionMode.into() )
    }

    pub fn build(self) -> SamplerReductionModeCreateInfoExt<'b> {
        SamplerReductionModeCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) -> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn advanced_blend_coherent_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendCoherentOperations != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_advanced_blend_coherent_operations<'m>(&mut self, advanced_blend_coherent_operations: bool) {
        self.raw.advancedBlendCoherentOperations = advanced_blend_coherent_operations as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s>> for vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn from(f: PhysicalDeviceBlendOperationAdvancedFeaturesExt<'s>) -> vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_ADVANCEDBLENDCOHERENTOPERATIONS			 = 0b100;
    }
}


/// A builder for `VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags,
}

impl<'b> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder {
            raw: vks::VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_PNEXT;
        self
    }

    pub fn advanced_blend_coherent_operations<'m>(mut self, advanced_blend_coherent_operations: bool) -> PhysicalDeviceBlendOperationAdvancedFeaturesExtBuilder<'b> {
        self.raw.advancedBlendCoherentOperations = advanced_blend_coherent_operations as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_ADVANCEDBLENDCOHERENTOPERATIONS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_PNEXT != PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_advanced_blend_coherent_operations<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_ADVANCEDBLENDCOHERENTOPERATIONS != PhysicalDeviceBlendOperationAdvancedFeaturesExtFlags::FLAG_ADVANCEDBLENDCOHERENTOPERATIONS { return None }
        Some( self.raw.advancedBlendCoherentOperations != 0 )
    }

    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedFeaturesExt<'b> {
        PhysicalDeviceBlendOperationAdvancedFeaturesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
    pub fn builder<'b>() -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) -> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *mut c_void {
        self.raw.pNext
    }

    pub fn advanced_blend_max_color_attachments<'a>(&'a self) -> u32 {
        self.raw.advancedBlendMaxColorAttachments.into()
    }

    pub fn advanced_blend_independent_blend<'a>(&'a self) -> bool {
        self.raw.advancedBlendIndependentBlend != 0
    }

    pub fn advanced_blend_non_premultiplied_src_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedSrcColor != 0
    }

    pub fn advanced_blend_non_premultiplied_dst_color<'a>(&'a self) -> bool {
        self.raw.advancedBlendNonPremultipliedDstColor != 0
    }

    pub fn advanced_blend_correlated_overlap<'a>(&'a self) -> bool {
        self.raw.advancedBlendCorrelatedOverlap != 0
    }

    pub fn advanced_blend_all_operations<'a>(&'a self) -> bool {
        self.raw.advancedBlendAllOperations != 0
    }

    pub unsafe fn set_next<'m>(&mut self, next: *mut c_void) {
        self.raw.pNext = next;
    }

    pub fn set_advanced_blend_max_color_attachments<'m>(&mut self, advanced_blend_max_color_attachments: u32) {
        self.raw.advancedBlendMaxColorAttachments = advanced_blend_max_color_attachments.into();
    }

    pub fn set_advanced_blend_independent_blend<'m>(&mut self, advanced_blend_independent_blend: bool) {
        self.raw.advancedBlendIndependentBlend = advanced_blend_independent_blend as u32;
    }

    pub fn set_advanced_blend_non_premultiplied_src_color<'m>(&mut self, advanced_blend_non_premultiplied_src_color: bool) {
        self.raw.advancedBlendNonPremultipliedSrcColor = advanced_blend_non_premultiplied_src_color as u32;
    }

    pub fn set_advanced_blend_non_premultiplied_dst_color<'m>(&mut self, advanced_blend_non_premultiplied_dst_color: bool) {
        self.raw.advancedBlendNonPremultipliedDstColor = advanced_blend_non_premultiplied_dst_color as u32;
    }

    pub fn set_advanced_blend_correlated_overlap<'m>(&mut self, advanced_blend_correlated_overlap: bool) {
        self.raw.advancedBlendCorrelatedOverlap = advanced_blend_correlated_overlap as u32;
    }

    pub fn set_advanced_blend_all_operations<'m>(&mut self, advanced_blend_all_operations: bool) {
        self.raw.advancedBlendAllOperations = advanced_blend_all_operations as u32;
    }

    pub fn as_raw(&self) -> &vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        &self.raw
    }
}

impl<'s> From<PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s>> for vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn from(f: PhysicalDeviceBlendOperationAdvancedPropertiesExt<'s>) -> vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
        f.raw
    }
}


/// Bitflags for `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_ADVANCEDBLENDMAXCOLORATTACHMENTS			 = 0b100;
        const FLAG_ADVANCEDBLENDINDEPENDENTBLEND			 = 0b1000;
        const FLAG_ADVANCEDBLENDNONPREMULTIPLIEDSRCCOLOR			 = 0b10000;
        const FLAG_ADVANCEDBLENDNONPREMULTIPLIEDDSTCOLOR			 = 0b100000;
        const FLAG_ADVANCEDBLENDCORRELATEDOVERLAP			 = 0b1000000;
        const FLAG_ADVANCEDBLENDALLOPERATIONS			 = 0b10000000;
    }
}


/// A builder for `VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
    raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags,
}

impl<'b> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
    pub fn new() -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder {
            raw: vks::VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::default(),
            _p: PhantomData,
            set_mask: PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *mut c_void) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_PNEXT;
        self
    }

    pub fn advanced_blend_max_color_attachments<'m>(mut self, advanced_blend_max_color_attachments: u32) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendMaxColorAttachments = advanced_blend_max_color_attachments.into();
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDMAXCOLORATTACHMENTS;
        self
    }

    pub fn advanced_blend_independent_blend<'m>(mut self, advanced_blend_independent_blend: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendIndependentBlend = advanced_blend_independent_blend as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDINDEPENDENTBLEND;
        self
    }

    pub fn advanced_blend_non_premultiplied_src_color<'m>(mut self, advanced_blend_non_premultiplied_src_color: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendNonPremultipliedSrcColor = advanced_blend_non_premultiplied_src_color as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDSRCCOLOR;
        self
    }

    pub fn advanced_blend_non_premultiplied_dst_color<'m>(mut self, advanced_blend_non_premultiplied_dst_color: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendNonPremultipliedDstColor = advanced_blend_non_premultiplied_dst_color as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDDSTCOLOR;
        self
    }

    pub fn advanced_blend_correlated_overlap<'m>(mut self, advanced_blend_correlated_overlap: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendCorrelatedOverlap = advanced_blend_correlated_overlap as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDCORRELATEDOVERLAP;
        self
    }

    pub fn advanced_blend_all_operations<'m>(mut self, advanced_blend_all_operations: bool) -> PhysicalDeviceBlendOperationAdvancedPropertiesExtBuilder<'b> {
        self.raw.advancedBlendAllOperations = advanced_blend_all_operations as u32;
        self.set_mask |= PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDALLOPERATIONS;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*mut c_void> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_PNEXT != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_advanced_blend_max_color_attachments<'a>(&'a self) -> Option<u32> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDMAXCOLORATTACHMENTS != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDMAXCOLORATTACHMENTS { return None }
        Some( self.raw.advancedBlendMaxColorAttachments.into() )
    }

    pub fn get_advanced_blend_independent_blend<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDINDEPENDENTBLEND != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDINDEPENDENTBLEND { return None }
        Some( self.raw.advancedBlendIndependentBlend != 0 )
    }

    pub fn get_advanced_blend_non_premultiplied_src_color<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDSRCCOLOR != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDSRCCOLOR { return None }
        Some( self.raw.advancedBlendNonPremultipliedSrcColor != 0 )
    }

    pub fn get_advanced_blend_non_premultiplied_dst_color<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDDSTCOLOR != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDNONPREMULTIPLIEDDSTCOLOR { return None }
        Some( self.raw.advancedBlendNonPremultipliedDstColor != 0 )
    }

    pub fn get_advanced_blend_correlated_overlap<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDCORRELATEDOVERLAP != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDCORRELATEDOVERLAP { return None }
        Some( self.raw.advancedBlendCorrelatedOverlap != 0 )
    }

    pub fn get_advanced_blend_all_operations<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDALLOPERATIONS != PhysicalDeviceBlendOperationAdvancedPropertiesExtFlags::FLAG_ADVANCEDBLENDALLOPERATIONS { return None }
        Some( self.raw.advancedBlendAllOperations != 0 )
    }

    pub fn build(self) -> PhysicalDeviceBlendOperationAdvancedPropertiesExt<'b> {
        PhysicalDeviceBlendOperationAdvancedPropertiesExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineColorBlendAdvancedStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
    raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
    pub fn builder<'b>() -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExtBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT) -> PipelineColorBlendAdvancedStateCreateInfoExt<'s> {
        PipelineColorBlendAdvancedStateCreateInfoExt { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn src_premultiplied<'a>(&'a self) -> bool {
        self.raw.srcPremultiplied != 0
    }

    pub fn dst_premultiplied<'a>(&'a self) -> bool {
        self.raw.dstPremultiplied != 0
    }

    pub fn blend_overlap<'a>(&'a self) -> BlendOverlapExt {
        self.raw.blendOverlap.into()
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_src_premultiplied<'m>(&mut self, src_premultiplied: bool) {
        self.raw.srcPremultiplied = src_premultiplied as u32;
    }

    pub fn set_dst_premultiplied<'m>(&mut self, dst_premultiplied: bool) {
        self.raw.dstPremultiplied = dst_premultiplied as u32;
    }

    pub fn set_blend_overlap<'m>(&mut self, blend_overlap: BlendOverlapExt) {
        self.raw.blendOverlap = blend_overlap.into();
    }

    pub fn as_raw(&self) -> &vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
        &self.raw
    }
}

impl<'s> From<PipelineColorBlendAdvancedStateCreateInfoExt<'s>> for vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    fn from(f: PipelineColorBlendAdvancedStateCreateInfoExt<'s>) -> vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT {
        f.raw
    }
}


/// Bitflags for `VkPipelineColorBlendAdvancedStateCreateInfoEXT`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineColorBlendAdvancedStateCreateInfoExtFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_SRCPREMULTIPLIED			 = 0b100;
        const FLAG_DSTPREMULTIPLIED			 = 0b1000;
        const FLAG_BLENDOVERLAP			 = 0b10000;
    }
}


/// A builder for `VkPipelineColorBlendAdvancedStateCreateInfoEXT`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
    raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineColorBlendAdvancedStateCreateInfoExtFlags,
}

impl<'b> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
    pub fn new() -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExtBuilder {
            raw: vks::VkPipelineColorBlendAdvancedStateCreateInfoEXT::default(),
            _p: PhantomData,
            set_mask: PipelineColorBlendAdvancedStateCreateInfoExtFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_PNEXT;
        self
    }

    pub fn src_premultiplied<'m>(mut self, src_premultiplied: bool) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.srcPremultiplied = src_premultiplied as u32;
        self.set_mask |= PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_SRCPREMULTIPLIED;
        self
    }

    pub fn dst_premultiplied<'m>(mut self, dst_premultiplied: bool) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.dstPremultiplied = dst_premultiplied as u32;
        self.set_mask |= PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_DSTPREMULTIPLIED;
        self
    }

    pub fn blend_overlap<'m>(mut self, blend_overlap: BlendOverlapExt) -> PipelineColorBlendAdvancedStateCreateInfoExtBuilder<'b> {
        self.raw.blendOverlap = blend_overlap.into();
        self.set_mask |= PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_BLENDOVERLAP;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_PNEXT != PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_src_premultiplied<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_SRCPREMULTIPLIED != PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_SRCPREMULTIPLIED { return None }
        Some( self.raw.srcPremultiplied != 0 )
    }

    pub fn get_dst_premultiplied<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_DSTPREMULTIPLIED != PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_DSTPREMULTIPLIED { return None }
        Some( self.raw.dstPremultiplied != 0 )
    }

    pub fn get_blend_overlap<'a>(&'a self) -> Option<BlendOverlapExt> {
        if self.set_mask & PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_BLENDOVERLAP != PipelineColorBlendAdvancedStateCreateInfoExtFlags::FLAG_BLENDOVERLAP { return None }
        Some( self.raw.blendOverlap.into() )
    }

    pub fn build(self) -> PipelineColorBlendAdvancedStateCreateInfoExt<'b> {
        PipelineColorBlendAdvancedStateCreateInfoExt {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


/// A `VkPipelineCoverageModulationStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
#[repr(C)]
pub struct PipelineCoverageModulationStateCreateInfoNv<'s> {
    raw: vks::VkPipelineCoverageModulationStateCreateInfoNV,
    _p: PhantomData<&'s ()>,
}

impl<'s> PipelineCoverageModulationStateCreateInfoNv<'s> {
    pub fn builder<'b>() -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        PipelineCoverageModulationStateCreateInfoNvBuilder::new()
    }

    pub unsafe fn from_raw(raw: vks::VkPipelineCoverageModulationStateCreateInfoNV) -> PipelineCoverageModulationStateCreateInfoNv<'s> {
        PipelineCoverageModulationStateCreateInfoNv { raw, _p: PhantomData }
    }

    pub fn next<'a>(&'a self) -> *const c_void {
        self.raw.pNext
    }

    pub fn flags<'a>(&'a self) -> PipelineCoverageModulationStateCreateFlagsNv {
        PipelineCoverageModulationStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageModulationStateCreateInfoNv::flags: error converting flags")
    }

    pub fn coverage_modulation_mode<'a>(&'a self) -> CoverageModulationModeNv {
        self.raw.coverageModulationMode.into()
    }

    pub fn coverage_modulation_table_enable<'a>(&'a self) -> bool {
        self.raw.coverageModulationTableEnable != 0
    }

    pub fn coverage_modulation_table<'a>(&'a self) -> &'a [f32] {
        unsafe { slice::from_raw_parts(self.raw.pCoverageModulationTable as *const _, self.raw.coverageModulationTableCount as usize) }
    }

    pub unsafe fn set_next<'m>(&mut self, next: *const c_void) {
        self.raw.pNext = next;
    }

    pub fn set_flags<'m>(&mut self, flags: PipelineCoverageModulationStateCreateFlagsNv) {
        self.raw.flags = flags.bits();
    }

    pub fn set_coverage_modulation_mode<'m>(&mut self, coverage_modulation_mode: CoverageModulationModeNv) {
        self.raw.coverageModulationMode = coverage_modulation_mode.into();
    }

    pub fn set_coverage_modulation_table_enable<'m>(&mut self, coverage_modulation_table_enable: bool) {
        self.raw.coverageModulationTableEnable = coverage_modulation_table_enable as u32;
    }

    pub fn set_coverage_modulation_table<'m, 'a>(&mut self, coverage_modulation_table: &'a [f32])
            where 'a: 's {
        assert!(self.raw.coverageModulationTableCount == 0 || self.raw.coverageModulationTableCount == coverage_modulation_table.len() as _, 
            "count inconsistency found when specifying `PipelineCoverageModulationStateCreateInfoNv::coverage_modulation_table`.");
        self.raw.coverageModulationTableCount = coverage_modulation_table.len() as _;
        self.raw.pCoverageModulationTable = coverage_modulation_table.as_ptr() as *const f32 as *const _;
    }

    pub fn as_raw(&self) -> &vks::VkPipelineCoverageModulationStateCreateInfoNV {
        &self.raw
    }
}

impl<'s> From<PipelineCoverageModulationStateCreateInfoNv<'s>> for vks::VkPipelineCoverageModulationStateCreateInfoNV {
    fn from(f: PipelineCoverageModulationStateCreateInfoNv<'s>) -> vks::VkPipelineCoverageModulationStateCreateInfoNV {
        f.raw
    }
}


/// Bitflags for `VkPipelineCoverageModulationStateCreateInfoNV`.
///
/// 
bitflags! {
    #[derive(Default)]
    pub struct PipelineCoverageModulationStateCreateInfoNvFlags: u32 {
        const FLAG_STYPE			 = 0b1;
        const FLAG_PNEXT			 = 0b10;
        const FLAG_FLAGS			 = 0b100;
        const FLAG_COVERAGEMODULATIONMODE			 = 0b1000;
        const FLAG_COVERAGEMODULATIONTABLEENABLE			 = 0b10000;
        const FLAG_COVERAGEMODULATIONTABLECOUNT			 = 0b100000;
        const FLAG_PCOVERAGEMODULATIONTABLE			 = 0b1000000;
    }
}


/// A builder for `VkPipelineCoverageModulationStateCreateInfoNV`.
///
/// 
#[derive(Debug, Clone, Default)]
pub struct PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
    raw: vks::VkPipelineCoverageModulationStateCreateInfoNV,
    _p: PhantomData<&'b ()>, 
    set_mask: PipelineCoverageModulationStateCreateInfoNvFlags,
}

impl<'b> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
    pub fn new() -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        PipelineCoverageModulationStateCreateInfoNvBuilder {
            raw: vks::VkPipelineCoverageModulationStateCreateInfoNV::default(),
            _p: PhantomData,
            set_mask: PipelineCoverageModulationStateCreateInfoNvFlags::default(),
        }
    }

    pub unsafe fn next<'m>(mut self, next: *const c_void) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.pNext = next;
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PNEXT;
        self
    }

    pub fn flags<'m>(mut self, flags: PipelineCoverageModulationStateCreateFlagsNv) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.flags = flags.bits();
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_FLAGS;
        self
    }

    pub fn coverage_modulation_mode<'m>(mut self, coverage_modulation_mode: CoverageModulationModeNv) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.coverageModulationMode = coverage_modulation_mode.into();
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONMODE;
        self
    }

    pub fn coverage_modulation_table_enable<'m>(mut self, coverage_modulation_table_enable: bool) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b> {
        self.raw.coverageModulationTableEnable = coverage_modulation_table_enable as u32;
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONTABLEENABLE;
        self
    }

    pub fn coverage_modulation_table<'m, 'a>(mut self, coverage_modulation_table: &'a [f32]) -> PipelineCoverageModulationStateCreateInfoNvBuilder<'b>
            where 'a: 'b {
        assert!(self.raw.coverageModulationTableCount == 0 || self.raw.coverageModulationTableCount == coverage_modulation_table.len() as _, 
            "count inconsistency found when specifying `PipelineCoverageModulationStateCreateInfoNv::coverage_modulation_table`.");
        self.raw.coverageModulationTableCount = coverage_modulation_table.len() as _;
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONTABLECOUNT;
        self.raw.pCoverageModulationTable = coverage_modulation_table.as_ptr() as *const f32 as *const _;
        self.set_mask |= PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PCOVERAGEMODULATIONTABLE;
        self
    }

    pub fn get_next<'a>(&'a self) -> Option<*const c_void> {
        if self.set_mask & PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PNEXT != PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PNEXT { return None }
        Some( self.raw.pNext )
    }

    pub fn get_flags<'a>(&'a self) -> Option<PipelineCoverageModulationStateCreateFlagsNv> {
        if self.set_mask & PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_FLAGS != PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_FLAGS { return None }
        Some( PipelineCoverageModulationStateCreateFlagsNv::from_bits(self.raw.flags)
            .expect("PipelineCoverageModulationStateCreateInfoNv::flags: error converting flags") )
    }

    pub fn get_coverage_modulation_mode<'a>(&'a self) -> Option<CoverageModulationModeNv> {
        if self.set_mask & PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONMODE != PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONMODE { return None }
        Some( self.raw.coverageModulationMode.into() )
    }

    pub fn get_coverage_modulation_table_enable<'a>(&'a self) -> Option<bool> {
        if self.set_mask & PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONTABLEENABLE != PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_COVERAGEMODULATIONTABLEENABLE { return None }
        Some( self.raw.coverageModulationTableEnable != 0 )
    }

    pub fn get_coverage_modulation_table<'a>(&'a self) -> Option<&'a [f32]> {
        if self.set_mask & PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PCOVERAGEMODULATIONTABLE != PipelineCoverageModulationStateCreateInfoNvFlags::FLAG_PCOVERAGEMODULATIONTABLE { return None }
        Some( unsafe { slice::from_raw_parts(self.raw.pCoverageModulationTable as *const _, self.raw.coverageModulationTableCount as usize) } )
    }

    pub fn build(self) -> PipelineCoverageModulationStateCreateInfoNv<'b> {
        PipelineCoverageModulationStateCreateInfoNv {
            raw: self.raw,
            _p: PhantomData,
        }
    }
}


